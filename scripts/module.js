var U=Object.defineProperty;var D=(e,i,t)=>i in e?U(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t;var S=(e,i,t)=>D(e,typeof i!="symbol"?i+"":i,t);const id="foundryvtt-gold-api";class dnd5e{constructor(){S(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}class a5e{constructor(){S(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}const SYSTEMS={SUPPORTED_SYSTEMS:{dnd5e:{latest:dnd5e},a5e:{latest:a5e}},DEFAULT_SETTINGS:{ACTOR_CURRENCY_ATTRIBUTE:""},_currentSystem:!1,get DATA(){var s;if(this._currentSystem)return this._currentSystem;const e=(s=this.SUPPORTED_SYSTEMS)==null?void 0:s[game.system.id.toLowerCase()];if(!e)return this.DEFAULT_SETTINGS;if(e[game.system.version])return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[game.system.version]),this._currentSystem;const i=Object.keys(e);if(i.length===1)return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[i[0]]),this._currentSystem;i.sort((o,l)=>o==="latest"||l==="latest"?-1/0:isNewerVersion(l,o)?-1:1);const t=i.find(o=>o==="latest"||!isNewerVersion(game.system.version,o));return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[t]),this._currentSystem}},CONSTANTS={MODULE_ID:id},moduleId=id,recentRolls=[],SETTINGS={ACTOR_CURRENCY_ATTRIBUTE:"actorCurrencyAttribute",WS_RELAY_URL:"wsRelayUrl",API_KEY:"apiKey",CUSTOM_NAME:"customName",LOG_LEVEL:"logLevel",PING_INTERVAL:"pingInterval",RECONNECT_MAX_ATTEMPTS:"reconnectMaxAttempts",RECONNECT_BASE_DELAY:"reconnectBaseDelay",MAX_ROLLS_STORED:"maxRollsStored",SYSTEM_FOUND:"systemFound",SYSTEM_NOT_FOUND_WARNING_SHOWN:"systemNotFoundWarningShown",SYSTEM_VERSION:"systemVersion",GET_DEFAULT(){return foundry.utils.deepClone(SETTINGS.DEFAULTS())},GET_SYSTEM_DEFAULTS(){return Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).filter(e=>e[1].system))},DEFAULTS:()=>({[SETTINGS.ACTOR_CURRENCY_ATTRIBUTE]:{name:"Actor Currency attribute",hint:"Reference path to the actor currency attribute",scope:"world",config:!1,system:!0,default:SYSTEMS.DATA.ACTOR_CURRENCY_ATTRIBUTE,type:String},[SETTINGS.SYSTEM_VERSION]:{scope:"world",config:!1,default:"0.0.0",type:String},[SETTINGS.SYSTEM_FOUND]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.WS_RELAY_URL]:{name:"WebSocket Relay URL",hint:"URL for the WebSocket relay server",scope:"world",config:!0,type:String,default:"http://localhost:3010",requiresReload:!0},[SETTINGS.API_KEY]:{name:"API Key",hint:"API Key for authentication with the relay server",scope:"world",config:!0,type:String,default:game.world.id,requiresReload:!0},[SETTINGS.CUSTOM_NAME]:{name:"Custom Client Name",hint:"A custom name to identify this client (optional)",scope:"world",config:!0,type:String,default:"",requiresReload:!0},[SETTINGS.LOG_LEVEL]:{name:"Log Level",hint:"Set the level of detail for module logging",scope:"world",config:!0,type:Number,choices:{0:"debug",1:"info",2:"warn",3:"error"},default:2},[SETTINGS.PING_INTERVAL]:{name:"Ping Interval (seconds)",hint:"How often (in seconds) the module sends a ping to the relay server to keep the connection alive.",scope:"world",config:!0,type:Number,default:30,range:{min:5,max:600,step:1},requiresReload:!0},[SETTINGS.RECONNECT_MAX_ATTEMPTS]:{name:"Max Reconnect Attempts",hint:"Maximum number of times the module will try to reconnect after losing connection.",scope:"world",config:!0,type:Number,default:20,requiresReload:!0},[SETTINGS.RECONNECT_BASE_DELAY]:{name:"Reconnect Base Delay (ms)",hint:"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.",scope:"world",config:!0,type:Number,default:1e3,requiresReload:!0},[SETTINGS.MAX_ROLLS_STORED]:{name:"Maximum Rolls Stored",hint:"Maximum number of recent rolls to store in memory",scope:"world",config:!0,type:Number,default:20,range:{min:5,max:100,step:1},requiresReload:!1}})};class ModuleLogger{static debugLevel(){return game.settings.get(moduleId,"logLevel")}static debug(i,...t){return this.debugLevel()<1&&console.log(`${moduleId} | ${i}`,...t),i}static info(i,...t){return this.debugLevel()<2&&console.log(`${moduleId} | ${i}`,...t),i}static warn(i,...t){return this.debugLevel()<3&&console.warn(`${moduleId} | ${i}`,...t),i}static error(i,...t){return this.debugLevel()<4&&console.error(`${moduleId} | ${i}`,...t),i}}var WSCloseCodes=(e=>(e[e.Normal=1e3]="Normal",e[e.NoClientId=4001]="NoClientId",e[e.NoAuth=4002]="NoAuth",e[e.NoConnectedGuild=4003]="NoConnectedGuild",e[e.InternalError=4e3]="InternalError",e[e.DuplicateConnection=4004]="DuplicateConnection",e[e.ServerShutdown=4005]="ServerShutdown",e))(WSCloseCodes||{});const N=class N{constructor(i,t){S(this,"url");S(this,"token");S(this,"socket",null);S(this,"messageHandlers",new Map);S(this,"reconnectTimer",null);S(this,"reconnectAttempts",0);S(this,"clientId");S(this,"pingInterval",null);S(this,"isConnecting",!1);S(this,"isPrimaryGM",!1);var s,o,l;this.url=i,this.token=t,this.clientId=`foundry-${((s=game.user)==null?void 0:s.id)||Math.random().toString(36).substring(2,15)}`,this.isPrimaryGM=this.checkIfPrimaryGM(),ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`),(o=game.user)!=null&&o.isGM&&((l=game.user)==null?void 0:l.role)===4&&(Hooks.on("userConnected",this.reevaluatePrimaryGM.bind(this)),Hooks.on("userDisconnected",this.reevaluatePrimaryGM.bind(this)))}static getInstance(i,t){var s,o;return!((s=game.user)!=null&&s.isGM)||((o=game.user)==null?void 0:o.role)!==4?(ModuleLogger.info("WebSocketManager not created - user is not a full GM"),null):(N.instance||(ModuleLogger.info("Creating new WebSocketManager instance"),N.instance=new N(i,t)),N.instance)}checkIfPrimaryGM(){var l,r,u,n,a,d;if(!((l=game.user)!=null&&l.isGM)||((r=game.user)==null?void 0:r.role)!==4)return!1;const i=(u=game.user)==null?void 0:u.id,t=((n=game.users)==null?void 0:n.filter(c=>c.role===4&&c.active))||[];if(t.length===0)return!1;const s=[...t].sort((c,p)=>(c.id||"").localeCompare(p.id||"")),o=((a=s[0])==null?void 0:a.id)===i;return ModuleLogger.info(`Primary GM check - Current user: ${i}, Primary GM: ${(d=s[0])==null?void 0:d.id}, isPrimary: ${o}`),o}reevaluatePrimaryGM(){const i=this.isPrimaryGM;this.isPrimaryGM=this.checkIfPrimaryGM(),i!==this.isPrimaryGM&&(ModuleLogger.info(`Primary GM status changed: ${i} -> ${this.isPrimaryGM}`),this.isPrimaryGM&&!this.isConnected()&&(ModuleLogger.info("Taking over as primary GM, connecting WebSocket"),this.connect()),!this.isPrimaryGM&&this.isConnected()&&(ModuleLogger.info("No longer primary GM, disconnecting WebSocket"),this.disconnect()))}connect(){var i,t;if(!((i=game.user)!=null&&i.isGM)||((t=game.user)==null?void 0:t.role)!==4){ModuleLogger.info("WebSocket connection aborted - user is not a full GM");return}if(!this.isPrimaryGM){ModuleLogger.info("WebSocket connection aborted - user is not the primary GM");return}if(this.isConnecting){ModuleLogger.info("Already attempting to connect");return}if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){ModuleLogger.info("WebSocket already connected or connecting");return}this.isConnecting=!0;try{const s=new URL(this.url);s.searchParams.set("id",this.clientId),s.searchParams.set("token",this.token),game.world&&(s.searchParams.set("worldId",game.world.id),s.searchParams.set("worldTitle",game.world.title)),s.searchParams.set("foundryVersion",game.version),s.searchParams.set("systemId",game.system.id),s.searchParams.set("systemTitle",game.system.title||game.system.id),s.searchParams.set("systemVersion",game.system.version||"unknown");const o=game.settings.get(moduleId,"customName");o&&s.searchParams.set("customName",o),ModuleLogger.info(`Connecting to WebSocket at ${s.toString()}`),this.socket=new WebSocket(s.toString());const l=window.setTimeout(()=>{this.socket&&this.socket.readyState===WebSocket.CONNECTING&&(ModuleLogger.error("Connection timed out"),this.socket.close(),this.socket=null,this.isConnecting=!1,this.scheduleReconnect())},5e3);this.socket.addEventListener("open",r=>{window.clearTimeout(l),this.onOpen(r)}),this.socket.addEventListener("close",r=>{window.clearTimeout(l),this.onClose(r)}),this.socket.addEventListener("error",r=>{window.clearTimeout(l),this.onError(r)}),this.socket.addEventListener("message",this.onMessage.bind(this))}catch(s){ModuleLogger.error("Error creating WebSocket:",s),this.isConnecting=!1,this.scheduleReconnect()}}disconnect(){this.socket&&(ModuleLogger.info("Disconnecting WebSocket"),this.socket.close(WSCloseCodes.Normal,"Disconnecting"),this.socket=null),this.reconnectTimer!==null&&(window.clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),this.reconnectAttempts=0,this.isConnecting=!1}isConnected(){return this.socket!==null&&this.socket.readyState===WebSocket.OPEN}getClientId(){return this.clientId}send(i){var t,s;if(ModuleLogger.info(`Send called, readyState: ${(t=this.socket)==null?void 0:t.readyState}`),this.socket&&this.socket.readyState===WebSocket.OPEN)try{return ModuleLogger.info("Sending message:",i),this.socket.send(JSON.stringify(i)),!0}catch(o){return ModuleLogger.error("Error sending message:",o),!1}else return ModuleLogger.warn(`WebSocket not ready, state: ${(s=this.socket)==null?void 0:s.readyState}`),!1}onMessageType(i,t){this.messageHandlers.set(i,t)}onOpen(i){ModuleLogger.info("WebSocket connected"),this.isConnecting=!1,this.reconnectAttempts=0,this.send({type:"ping"});const t=game.settings.get(moduleId,SETTINGS.PING_INTERVAL),s=t*1e3;ModuleLogger.info(`Starting application ping interval: ${t} seconds`),this.pingInterval!==null&&window.clearInterval(this.pingInterval),this.pingInterval=window.setInterval(()=>{this.isConnected()&&this.send({type:"ping"})},s)}onClose(i){ModuleLogger.info(`WebSocket disconnected: ${i.code} - ${i.reason}`),this.socket=null,this.isConnecting=!1,this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),i.code!==WSCloseCodes.Normal&&this.isPrimaryGM&&this.scheduleReconnect()}onError(i){ModuleLogger.error("WebSocket error:",i),this.isConnecting=!1}async onMessage(i){try{const t=JSON.parse(i.data);ModuleLogger.info("Received message:",t),t.type&&this.messageHandlers.has(t.type)?(ModuleLogger.info(`Handling message of type: ${t.type}`),this.messageHandlers.get(t.type)(t,{socketManager:this})):t.type&&ModuleLogger.warn(`No handler for message type: ${t.type}`)}catch(t){ModuleLogger.error("Error processing message:",t)}}scheduleReconnect(){if(this.reconnectTimer!==null)return;const i=game.settings.get(moduleId,SETTINGS.RECONNECT_MAX_ATTEMPTS),t=game.settings.get(moduleId,SETTINGS.RECONNECT_BASE_DELAY);if(this.reconnectAttempts++,this.reconnectAttempts>i){ModuleLogger.error(`Maximum reconnection attempts (${i}) reached`),this.reconnectAttempts=0;return}const s=Math.min(3e4,t*Math.pow(2,this.reconnectAttempts-1));ModuleLogger.info(`Scheduling reconnect in ${s}ms (attempt ${this.reconnectAttempts}/${i})`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=null,this.isPrimaryGM?(ModuleLogger.info("Attempting reconnect..."),this.connect()):(ModuleLogger.info("Reconnect attempt aborted - no longer primary GM."),this.reconnectAttempts=0)},s)}};S(N,"instance",null);let WebSocketManager=N;class Router{constructor(i,t=[]){S(this,"title");S(this,"routes");this.title=i,this.routes=t}addRoute(i){this.routes.push(i)}reflect(i){this.routes.forEach(t=>i.onMessageType(t.actionType,t.handler))}}const router$b=new Router("pingRouter");router$b.addRoute({actionType:"ping",handler:e=>{ModuleLogger.info("Received ping, sending pong"),e.socketManager.send({type:"pong"})}});router$b.addRoute({actionType:"pong",handler:()=>{ModuleLogger.info("Received pong")}});function deepSerializeEntity(e){var i,t,s,o,l;if(!e)return null;try{let r=e.toObject?e.toObject(!0):JSON.parse(JSON.stringify(e));if(e.system){if(e.system.attributes){for(const[u,n]of Object.entries(e.system.attributes))if(((t=(i=r.system)==null?void 0:i.attributes)==null?void 0:t[u])===null&&n!==null&&(r.system.attributes||(r.system.attributes={}),r.system.attributes[u]=JSON.parse(JSON.stringify(n))),typeof n=="object"&&n!==null)for(const[a,d]of Object.entries(n))((l=(o=(s=r.system)==null?void 0:s.attributes)==null?void 0:o[u])==null?void 0:l[a])===null&&d!==null&&(r.system.attributes[u]||(r.system.attributes[u]={}),r.system.attributes[u][a]=JSON.parse(JSON.stringify(d)))}["traits","abilities","skills","resources"].forEach(u=>{var n,a,d,c,p;if(e.system[u]){for(const[y,h]of Object.entries(e.system[u]))if(((a=(n=r.system)==null?void 0:n[u])==null?void 0:a[y])===null&&h!==null&&(r.system[u]||(r.system[u]={}),r.system[u][y]=JSON.parse(JSON.stringify(h))),typeof h=="object"&&h!==null)for(const[f,m]of Object.entries(h))((p=(c=(d=r.system)==null?void 0:d[u])==null?void 0:c[y])==null?void 0:p[f])===null&&m!==null&&(r.system[u][y]||(r.system[u][y]={}),r.system[u][y][f]=JSON.parse(JSON.stringify(m)))}})}if(e.items&&e.items.size>0&&Array.isArray(r.items))try{const u=e.items;if(Array.isArray(u.contents))for(let n=0;n<u.contents.length;n++)n<r.items.length&&(r.items[n]=deepSerializeEntity(u.contents[n]));else if(typeof u.entries=="function"){const n=Array.from(u.entries());for(let a=0;a<n.length;a++){const[d,c]=n[a];a<r.items.length&&(r.items[a]=deepSerializeEntity(c))}}}catch(u){ModuleLogger.warn("Failed to process entity.items collection:",u)}if(e.effects&&e.effects.size>0&&Array.isArray(r.effects))try{const u=e.effects;if(Array.isArray(u.contents))for(let n=0;n<u.contents.length;n++)n<r.effects.length&&(r.effects[n]=deepSerializeEntity(u.contents[n]));else if(typeof u.entries=="function"){const n=Array.from(u.entries());for(let a=0;a<n.length;a++){const[d,c]=n[a];a<r.effects.length&&(r.effects[a]=deepSerializeEntity(c))}}}catch(u){ModuleLogger.warn("Failed to process entity.effects collection:",u)}return r}catch(r){return ModuleLogger.error("Error deep serializing entity:",r),e.toObject?e.toObject():e}}const router$a=new Router("entityRouter");router$a.addRoute({actionType:"entity",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received entity request:",e);try{let o,l=[],r=e.uuid;if(e.selected){const u=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled;if(u)for(let n of u)e.actor?o=n.actor:o=n.document,o&&(r=o.uuid,l.push(deepSerializeEntity(o)))}else o=await fromUuid(e.uuid),l=o?deepSerializeEntity(o):null;if(!l){ModuleLogger.error(`Entity not found: ${e.uuid}`),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:"Entity not found",data:null});return}ModuleLogger.info(`Sending entity data for: ${e.uuid}`,l),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:r,data:l})}catch(o){ModuleLogger.error("Error getting entity:",o),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:o.message,data:null})}}});router$a.addRoute({actionType:"create",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received create entity request for type: ${e.entityType}`);try{const s=getDocumentClass(e.entityType);if(!s)throw new Error(`Invalid entity type: ${e.entityType}`);const o={...e.data,folder:e.folder||null},l=await s.create(o);if(!l)throw new Error("Failed to create entity");t==null||t.send({type:"create-result",requestId:e.requestId,uuid:l.uuid,entity:l.toObject()})}catch(s){ModuleLogger.error("Error creating entity:",s),t==null||t.send({type:"create-result",requestId:e.requestId,error:s.message,message:"Failed to create entity"})}}});router$a.addRoute({actionType:"decrease",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received decrease attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const o=[];if(e.selected){const r=((s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled)||[];for(const u of r)u.actor&&o.push(u.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&o.push(r)}if(o.length===0)throw new Error("No entities found to modify");const l=[];for(const r of o){const u=getProperty(r,e.attribute);if(typeof u!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof u}`);const n=u-e.amount,a={};a[e.attribute]=n,await r.update(a),l.push({uuid:r.uuid,attribute:e.attribute,oldValue:u,newValue:n})}t==null||t.send({type:"decrease-result",requestId:e.requestId,results:l,success:!0})}catch(o){ModuleLogger.error("Error decreasing attribute:",o),t==null||t.send({type:"decrease-result",requestId:e.requestId,success:!1,error:o.message})}}});router$a.addRoute({actionType:"increase",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received increase attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const o=[];if(e.selected){const r=((s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled)||[];for(const u of r)u.actor&&o.push(u.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&o.push(r)}if(o.length===0)throw new Error("No entities found to modify");const l=[];for(const r of o){const u=getProperty(r,e.attribute);if(typeof u!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof u}`);const n=u+e.amount,a={};a[e.attribute]=n,await r.update(a),l.push({uuid:r.uuid,attribute:e.attribute,oldValue:u,newValue:n})}t==null||t.send({type:"increase-result",requestId:e.requestId,results:l,success:!0})}catch(o){ModuleLogger.error("Error increasing attribute:",o),t==null||t.send({type:"increase-result",requestId:e.requestId,success:!1,error:o.message})}}});router$a.addRoute({actionType:"update",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received update entity request for UUID: ${e.uuid}`);try{let o=[];if(e.uuid)o.push(await fromUuid(e.uuid));else if(e.selected){const r=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled;if(r)for(let u of r)e.actor?o.push(u.actor):o.push(u.document)}if(o.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let r of o)await(r==null?void 0:r.update(e.data));let l=[];for(let r of o)l.push(await fromUuid(r.uuid));t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,entity:l.map(r=>r==null?void 0:r.toObject())})}catch(o){ModuleLogger.error("Error updating entity:",o),t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,error:o.message,message:"Failed to update entity"})}}});router$a.addRoute({actionType:"delete",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received delete entity request for UUID: ${e.uuid}`);try{let o=[];if(e.uuid)o.push(await fromUuid(e.uuid));else if(e.selected){const l=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled;if(l)for(let r of l)e.actor?o.push(r.actor):o.push(r.document)}if(!o||o.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let l of o)await(l==null?void 0:l.delete());t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,success:!0})}catch(o){ModuleLogger.error("Error deleting entity:",o),t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,error:o.message,message:"Failed to delete entity"})}}});router$a.addRoute({actionType:"kill",handler:async(e,i)=>{var s,o,l;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received kill request for UUID: ${e.uuid}`);try{const r=[];if(e.uuid){const n=await fromUuid(e.uuid);if(n)r.push(n);else throw new Error(`Entity not found: ${e.uuid}`)}else if(e.selected){const n=((s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled)||[];for(const a of n)a.document&&r.push(a.document)}if(r.length===0)throw new Error("No entities found to mark as defeated");const u=[];for(const n of r){let a=!1,d="";if(n.documentName==="Token"){const c=n,p=c.actor;if(!p)throw new Error("Token has no associated actor");const y=game.combat;if(y){const h=y.combatants.find(f=>{var m,g,w,I;return((m=f.token)==null?void 0:m.id)===c.id&&((w=(g=f.token)==null?void 0:g.parent)==null?void 0:w.id)===((I=c.parent)==null?void 0:I.id)});h&&(await h.update({defeated:!0}),ModuleLogger.info("Marked token as defeated in combat"))}try{hasProperty(p,"system.attributes.hp")?await p.update({"system.attributes.hp.value":0}):hasProperty(p,"system.health")?await p.update({"system.health.value":0}):hasProperty(p,"system.hp")?await p.update({"system.hp.value":0}):hasProperty(p,"data.attributes.hp")&&await p.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(h){ModuleLogger.warn(`Could not set HP to 0: ${h}`)}try{const h=(o=CONFIG.statusEffects)==null?void 0:o.find(f=>f.id==="dead"||f.id==="unconscious"||f.id==="defeated");h?(await c.toggleActiveEffect(h),ModuleLogger.info(`Added ${h.id} status effect to token`)):ModuleLogger.warn("No dead status effect found")}catch(h){ModuleLogger.warn(`Could not apply status effect: ${h}`)}a=!0,d="Token marked as defeated, HP set to 0, and dead effect applied"}else if(n.documentName==="Actor"){const c=n;let p=0;const y=game.scenes;if(y!=null&&y.viewed){const f=y.viewed.tokens.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});for(const m of f)try{const g=(l=CONFIG.statusEffects)==null?void 0:l.find(w=>w.id==="dead"||w.id==="unconscious"||w.id==="defeated");g&&(await m.toggleActiveEffect(g),p++)}catch(g){ModuleLogger.warn(`Could not apply status effect to token: ${g}`)}}const h=game.combat;if(h){const f=h.combatants.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});f.length>0&&(await Promise.all(f.map(m=>m.update({defeated:!0}))),ModuleLogger.info(`Marked ${f.length} combatants as defeated`))}try{hasProperty(c,"system.attributes.hp")?await c.update({"system.attributes.hp.value":0}):hasProperty(c,"system.health")?await c.update({"system.health.value":0}):hasProperty(c,"system.hp")?await c.update({"system.hp.value":0}):hasProperty(c,"data.attributes.hp")&&await c.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(f){ModuleLogger.warn(`Could not set HP to 0: ${f}`)}a=!0,d=`Actor marked as defeated, HP set to 0, and dead effect applied to ${p} tokens`}else throw new Error(`Cannot mark entity type ${n.documentName} as defeated`);u.push({uuid:n.uuid,success:a,message:d})}t==null||t.send({type:"kill-result",requestId:e.requestId,results:u})}catch(r){ModuleLogger.error("Error marking entities as defeated:",r),t==null||t.send({type:"kill-result",requestId:e.requestId,success:!1,error:r.message})}}});router$a.addRoute({actionType:"give",handler:async(e,i)=>{var s,o,l,r;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received give item request from ${e.fromUuid} to ${e.toUuid}`);try{if(!e.toUuid&&!e.selected)throw new Error("Target UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");let u=null;if(e.fromUuid&&(u=await fromUuid(e.fromUuid),(u==null?void 0:u.documentName)!=="Actor"))throw new Error(`Source entity must be an Actor, got ${u==null?void 0:u.documentName}`);e.selected&&(e.toUuid=(l=(o=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled[0])==null?void 0:o.actor)==null?void 0:l.uuid);const n=await fromUuid(e.toUuid);if(!n)throw new Error(`Target entity not found: ${e.toUuid}`);if(n.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${n.documentName}`);let a=null,d=null;if(e.itemUuid)a=await fromUuid(e.itemUuid),a&&(d=a.toObject());else if(e.itemName)if(u)a=u.items.find(m=>m.name.toLowerCase()===e.itemName.toLowerCase()),a&&(d=a.toObject());else{if(!window.QuickInsert)throw new Error("QuickInsert is not available for global item search.");window.QuickInsert.hasIndex||(ModuleLogger.info("QuickInsert index not ready, forcing index creation"),window.QuickInsert.forceIndex(),await new Promise(w=>setTimeout(w,500)));const g=(await window.QuickInsert.search(e.itemName,null,20)).find(w=>{var I;return((I=w.item)==null?void 0:I.documentType)==="Item"});if(g){const w=await g.item.get();w&&(d=w.toObject())}}if(!d)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);if(a&&a.documentName!=="Item")throw new Error(`Entity must be an Item, got ${a.documentName}`);if(a&&u&&((r=a.parent)==null?void 0:r.id)!==u.id)throw new Error(`Item ${e.itemUuid||e.itemName} does not belong to source actor ${e.fromUuid}`);const c=e.quantity||1,p=n.items.find(m=>m.name===d.name),y=p&&hasProperty(p.system,"quantity");if(a&&u){const m=getProperty(a,"system.quantity");typeof m=="number"&&c<m?await a.update({"system.quantity":m-c}):await a.delete()}let h,f;if(y){const m=p.system.quantity+c;await p.update({"system.quantity":m}),h=p.id,f=m}else delete d._id,(hasProperty(d,"system.quantity")||d.system)&&(d.system.quantity=c),f=c,h=(await n.createEmbeddedDocuments("Item",[d]))[0].id;t==null||t.send({type:"give-result",requestId:e.requestId,fromUuid:e.fromUuid,selected:e.selected,toUuid:e.toUuid,quantity:f,itemUuid:e.itemUuid,newItemId:h,success:!0})}catch(u){ModuleLogger.error("Error giving item:",u),t==null||t.send({type:"give-result",requestId:e.requestId,selected:e.selected,fromUuid:e.fromUuid||"",toUuid:e.toUuid||"",quantity:e.quantity,itemUuid:e.itemUuid||"",success:!1,error:u.message})}}});router$a.addRoute({actionType:"remove",handler:async(e,i)=>{var s,o,l;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received remove item request from actor: ${e.actorUuid}`);try{if(!e.actorUuid&&!e.selected)throw new Error("Target actor UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");e.selected&&(e.actorUuid=(l=(o=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled[0])==null?void 0:o.actor)==null?void 0:l.uuid);const r=await fromUuid(e.actorUuid);if(!r)throw new Error(`Target actor not found: ${e.actorUuid}`);if(r.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${r.documentName}`);let u=null;if(e.itemUuid?u=await fromUuid(e.itemUuid):e.itemName&&(u=r.items.find(c=>c.name.toLowerCase()===e.itemName.toLowerCase())),!u)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);const n=e.quantity||null,a=getProperty(u,"system.quantity");let d=0;n&&typeof a=="number"&&a>n?(d=a-n,await u.update({"system.quantity":d})):await u.delete(),t==null||t.send({type:"remove-result",requestId:e.requestId,actorUuid:e.actorUuid,itemUuid:u.uuid,quantity:d,success:!0})}catch(r){ModuleLogger.error("Error removing item:",r),t==null||t.send({type:"remove-result",requestId:e.requestId,success:!1,error:r.message})}}});const router$9=new Router("encounterRouter");router$9.addRoute({actionType:"encounters",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received request for encounters");try{const o=((s=game.combats)==null?void 0:s.contents.map(l=>{var r;return{id:l.id,name:l.name,round:l.round,turn:l.turn,current:l.id===((r=game.combat)==null?void 0:r.id),combatants:l.combatants.contents.map(u=>{var n,a;return{id:u.id,name:u.name,tokenUuid:(n=u.token)==null?void 0:n.uuid,actorUuid:(a=u.actor)==null?void 0:a.uuid,img:u.img,initiative:u.initiative,hidden:u.hidden,defeated:u.isDefeated}})}}))||[];t==null||t.send({type:"encounters-result",requestId:e.requestId,encounters:o})}catch(o){ModuleLogger.error("Error getting encounters list:",o),t==null||t.send({type:"encounters-result",requestId:e.requestId,error:o.message,encounters:[]})}}});router$9.addRoute({actionType:"start-encounter",handler:async(e,i)=>{var s,o,l;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received request to start encounter with options:",e);try{const r=await Combat.create({name:e.name||"New Encounter"});if(r){if(await r.startCombat(),e.tokenUuids&&e.tokenUuids.length>0){const n=[];for(const a of e.tokenUuids)try{const d=await fromUuid(a);d&&n.push({tokenId:d.id??"",sceneId:d.parent.id})}catch(d){ModuleLogger.warn(`Failed to add token ${a} to combat:`,d)}n.length>0&&await r.createEmbeddedDocuments("Combatant",n)}let u=new Set;if(e.startWithPlayers){const n=(s=game.scenes)==null?void 0:s.viewed;if(n){const d=(((o=n.tokens)==null?void 0:o.filter(c=>!!c.actor&&c.actor.hasPlayerOwner))??[]).map(c=>(u.add(c.id),{tokenId:c.id,sceneId:n.id}));d.length>0&&await r.createEmbeddedDocuments("Combatant",d)}}if(e.startWithSelected){const n=((l=canvas==null?void 0:canvas.tokens)==null?void 0:l.controlled.filter(a=>!u.has(a.id)).map(a=>({tokenId:a.id,sceneId:a.scene.id})))??[];n.length>0&&await r.createEmbeddedDocuments("Combatant",n)}e.rollNPC&&await r.rollNPC(),e.rollAll&&await r.rollAll(),await r.activate(),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,encounterId:r.id,encounter:{id:r.id,name:r.name,round:r.round,turn:r.turn,combatants:r.combatants.contents.map(n=>{var a,d;return{id:n.id,name:n.name,tokenUuid:(a=n.token)==null?void 0:a.uuid,actorUuid:(d=n.actor)==null?void 0:d.uuid,img:n.img,initiative:n.initiative,hidden:n.hidden,defeated:n.isDefeated}})}})}else throw new Error("Failed to create encounter")}catch(r){ModuleLogger.error("Error starting encounter:",r),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,error:r.message})}}});router$9.addRoute({actionType:"next-turn",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request for next turn in encounter: ${e.encounterId||"active"}`);try{const n=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await n.nextTurn(),t==null||t.send({type:"next-turn-result",requestId:e.requestId,encounterId:n.id,action:"nextTurn",currentTurn:n.turn,currentRound:n.round,actorTurn:(l=(o=n.combatant)==null?void 0:o.actor)==null?void 0:l.uuid,tokenTurn:(u=(r=n.combatant)==null?void 0:r.token)==null?void 0:u.uuid,encounter:{id:n.id,name:n.name,round:n.round,turn:n.turn}})}catch(n){ModuleLogger.error("Error advancing to next turn:",n),t==null||t.send({type:"next-turn-result",requestId:e.requestId,error:n.message})}}});router$9.addRoute({actionType:"next-round",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request for next round in encounter: ${e.encounterId||"active"}`);try{const n=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await n.nextRound(),t==null||t.send({type:"next-round-result",requestId:e.requestId,encounterId:n.id,action:"nextRound",currentTurn:n.turn,currentRound:n.round,actorTurn:(l=(o=n.combatant)==null?void 0:o.actor)==null?void 0:l.uuid,tokenTurn:(u=(r=n.combatant)==null?void 0:r.token)==null?void 0:u.uuid,encounter:{id:n.id,name:n.name,round:n.round,turn:n.turn}})}catch(n){ModuleLogger.error("Error advancing to next round:",n),t==null||t.send({type:"next-round-result",requestId:e.requestId,error:n.message})}}});router$9.addRoute({actionType:"last-turn",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request for previous turn in encounter: ${e.encounterId||"active"}`);try{const n=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await n.previousTurn(),t==null||t.send({type:"last-turn-result",requestId:e.requestId,encounterId:n.id,action:"previousTurn",currentTurn:n.turn,currentRound:n.round,actorTurn:(l=(o=n.combatant)==null?void 0:o.actor)==null?void 0:l.uuid,tokenTurn:(u=(r=n.combatant)==null?void 0:r.token)==null?void 0:u.uuid,encounter:{id:n.id,name:n.name,round:n.round,turn:n.turn}})}catch(n){ModuleLogger.error("Error going back to previous turn:",n),t==null||t.send({type:"last-turn-result",requestId:e.requestId,error:n.message})}}});router$9.addRoute({actionType:"last-round",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request for previous round in encounter: ${e.encounterId||"active"}`);try{const n=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await n.previousRound(),t==null||t.send({type:"last-round-result",requestId:e.requestId,encounterId:n.id,action:"previousRound",currentTurn:n.turn,currentRound:n.round,actorTurn:(l=(o=n.combatant)==null?void 0:o.actor)==null?void 0:l.uuid,tokenTurn:(u=(r=n.combatant)==null?void 0:r.token)==null?void 0:u.uuid,encounter:{id:n.id,name:n.name,round:n.round,turn:n.turn}})}catch(n){ModuleLogger.error("Error going back to previous round:",n),t==null||t.send({type:"encounter-navigation",requestId:e.requestId,error:n.message})}}});router$9.addRoute({actionType:"end-encounter",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request to end encounter: ${e.encounterId}`);try{let l=e.encounterId;l||(l=(s=game.combat)==null?void 0:s.id);const r=(o=game.combats)==null?void 0:o.get(l);if(!r)throw new Error("No encounter not found");await r.delete(),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,encounterId:l,message:"Encounter successfully ended"})}catch(l){ModuleLogger.error("Error ending encounter:",l),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,error:l.message})}}});router$9.addRoute({actionType:"add-to-encounter",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received add-to-encounter request for encounter: ${e.encounterId}`);try{const n=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const a=[],d=[];if(e.uuids&&Array.isArray(e.uuids))for(const c of e.uuids)try{const p=await fromUuid(c);if(!p){d.push({uuid:c,reason:"Entity not found"});continue}if(p.documentName==="Token"){const y=p,h={tokenId:y.id,sceneId:(o=y.parent)==null?void 0:o.id};await n.createEmbeddedDocuments("Combatant",[h]),a.push(c)}else if(p.documentName==="Actor"){const y=(l=game.scenes)==null?void 0:l.viewed;if(y){const h=(r=y.tokens)==null?void 0:r.find(f=>{var m;return((m=f.actor)==null?void 0:m.id)===p.id});if(h){const f={tokenId:h.id,sceneId:y.id};await n.createEmbeddedDocuments("Combatant",[f]),a.push(c)}else d.push({uuid:c,reason:"No token found for this actor in the current scene"})}else d.push({uuid:c,reason:"No active scene"})}else d.push({uuid:c,reason:"Entity must be a Token or Actor"})}catch(p){d.push({uuid:c,reason:p.message})}if(e.selected===!0){const c=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[];for(const p of c)try{if(!n.combatants.find(y=>{var h,f,m;return((h=y.token)==null?void 0:h.id)===p.id&&((m=(f=y.combat)==null?void 0:f.scene)==null?void 0:m.id)===p.scene.id})){const y={tokenId:p.id,sceneId:p.scene.id};await n.createEmbeddedDocuments("Combatant",[y]),a.push(p.document.uuid)}}catch(y){d.push({uuid:p.document.uuid,reason:y.message})}}e.rollInitiative===!0&&a.length>0&&n.rollAll(),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,encounterId:n.id,added:a,failed:d})}catch(n){ModuleLogger.error("Error adding to encounter:",n),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,error:n.message})}}});router$9.addRoute({actionType:"remove-from-encounter",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received remove-from-encounter request for encounter: ${e.encounterId}`);try{const l=e.encounterId?(s=game.combats)==null?void 0:s.get(e.encounterId):game.combat;if(!l)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const r=[],u=[],n=[];if(e.uuids&&Array.isArray(e.uuids))for(const a of e.uuids)try{const d=await fromUuid(a);if(!d){u.push({uuid:a,reason:"Entity not found"});continue}let c=!1;if(d.documentName==="Token"){const p=l.combatants.find(y=>{var h,f,m,g;return((h=y.token)==null?void 0:h.id)===d.id&&((m=(f=y.combat)==null?void 0:f.scene)==null?void 0:m.id)===((g=d.parent)==null?void 0:g.id)});p&&(n.push(p.id),c=!0)}else if(d.documentName==="Actor"){const p=l.combatants.filter(y=>{var h;return((h=y.actor)==null?void 0:h.id)===d.id});p.length>0&&(n.push(...p.map(y=>y.id)),c=!0)}c?r.push(a):u.push({uuid:a,reason:"No combatant found for this entity"})}catch(d){u.push({uuid:a,reason:d.message})}if(e.selected===!0){const a=((o=canvas==null?void 0:canvas.tokens)==null?void 0:o.controlled)||[];for(const d of a){const c=l.combatants.find(p=>p.tokenId===d.id&&p.sceneId===d.scene.id);c&&(n.push(c.id),r.push(d.document.uuid))}}if(n.length>0){const a=n.filter(d=>d!==null);a.length>0&&await l.deleteEmbeddedDocuments("Combatant",a)}t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,encounterId:l.id,removed:r,failed:u})}catch(l){ModuleLogger.error("Error removing from encounter:",l),t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,error:l.message})}}});const router$8=new Router("rollRouter");router$8.addRoute({actionType:"rolls",handler:async(e,i)=>{var o,l,r,u,n,a,d,c,p,y,h,f,m,g;const t=i==null?void 0:i.socketManager;if(console.log("=== ROLL ROUTER CALLED ==="),console.log("Received data:",JSON.stringify(e,null,2)),ModuleLogger.info(`Received request for roll data${e.clear||e.refresh?" with clear/refresh flag":""}`),e.clear||e.refresh){console.log("=== ENHANCED REFRESH LOGIC TRIGGERED ==="),ModuleLogger.info("=== ENHANCED REFRESH START ==="),ModuleLogger.info(`refresh flag received: ${e.refresh}`),ModuleLogger.info(`clear flag received: ${e.clear}`),ModuleLogger.info(`recentRolls length before clear: ${recentRolls.length}`),recentRolls.length=0,console.log("recentRolls after clear:",0),ModuleLogger.info(`recentRolls length after clear: ${recentRolls.length}`);let w=0;if(game.messages&&game.messages.contents){console.log("=== STRATEGY 1: USING GAME.MESSAGES ===");const T=game.messages.contents;ModuleLogger.info(`Processing ${T.length} messages from game.messages`);for(let M=T.length-1;M>=0;M--){const v=T[M];if(v.isRoll&&((o=v.rolls)==null?void 0:o.length)>0){w++;const R={id:v.id,messageId:v.id,flavor:v.flavor||"",rollTotal:v.rolls[0].total,formula:v.rolls[0].formula,isCritical:v.rolls[0].isCritical||!1,isFumble:v.rolls[0].isFumble||!1,dice:((l=v.rolls[0].dice)==null?void 0:l.map(q=>({faces:q.faces,results:q.results.map(b=>({result:b.result,active:b.active}))})))||[],user:{id:(r=v.user)==null?void 0:r.id,name:((u=v.user)==null?void 0:u.name)||"Unknown"},timestamp:v.timestamp||Date.now()};recentRolls.unshift(R),ModuleLogger.info(`Collected roll from game.messages: ${R.formula} = ${R.rollTotal} from ${(n=R.user)==null?void 0:n.name}`)}}}console.log("=== STRATEGY 2: DOM SCANNING BACKUP ===");const I=Array.from(document.querySelectorAll(".chat-message"));ModuleLogger.info(`Scanning ${I.length} chat messages from DOM as backup`);for(const T of I)if(T.classList.contains("dice-roll")){const M=T.getAttribute("data-message-id")||`dom_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,v=T.querySelector(".roll-formula"),k=T.querySelector(".roll-total"),R=T.querySelector(".message-content"),q=T.querySelector(".message-sender");if(v&&k&&!recentRolls.find(b=>b.id===M)){const b={id:M,messageId:M,flavor:((a=R==null?void 0:R.textContent)==null?void 0:a.trim())||"",rollTotal:parseInt(((d=k.textContent)==null?void 0:d.replace(/[^\d-]/g,""))||"0"),formula:((c=v.textContent)==null?void 0:c.trim())||"",isCritical:T.classList.contains("critical")||!1,isFumble:T.classList.contains("fumble")||!1,dice:[],user:{id:"",name:((p=q==null?void 0:q.textContent)==null?void 0:p.trim())||"Unknown"},timestamp:Date.now()};recentRolls.unshift(b),w++,ModuleLogger.info(`Collected roll from DOM: ${b.formula} = ${b.rollTotal} from ${(y=b.user)==null?void 0:y.name}`)}}if(console.log("=== STRATEGY 3: CANVAS UI FALLBACK ==="),canvas&&canvas.tokens&&((h=canvas.tokens)!=null&&h.controlled)){const T=(f=canvas.tokens)==null?void 0:f.controlled;if(T&&T.length>0){const M=Array.from(document.querySelectorAll(".dice-result, .roll-result"));ModuleLogger.info(`Found ${M.length} roll result elements in UI`);for(const v of M){const k=(m=v.textContent)==null?void 0:m.trim();if(k&&/\d+/.test(k)){const R=`ui_${Date.now()}_${Math.random().toString(36).substring(2,15)}`;if(!recentRolls.find(q=>q.id===R)){const q={id:R,messageId:R,flavor:"",rollTotal:parseInt(((g=k.match(/\d+/))==null?void 0:g[0])||"0"),formula:"unknown",isCritical:!1,isFumble:!1,dice:[],user:{id:"",name:"UI Roll"},timestamp:Date.now()};recentRolls.unshift(q),w++,ModuleLogger.info(`Collected roll from UI: ${q.rollTotal} from UI element`)}}}}}recentRolls.sort((T,M)=>M.timestamp-T.timestamp);const E=game.settings.get(moduleId,SETTINGS.MAX_ROLLS_STORED)||20;recentRolls.length>E&&(recentRolls.length=E),console.log("=== ENHANCED REFRESH COMPLETE ==="),console.log(`Total rolls collected: ${w}`),console.log(`Final recentRolls length: ${recentRolls.length}`),console.log("Strategies used: game.messages, DOM scanning, UI fallback"),ModuleLogger.info(`Enhanced refresh complete: ${w} rolls collected using multiple strategies`),ModuleLogger.info(`Final recentRolls length: ${recentRolls.length}`),ModuleLogger.info("=== ENHANCED REFRESH END ===")}else console.log("=== NO REFRESH/CLEAR FLAGS ==="),console.log(`data.clear: ${e.clear}, data.refresh: ${e.refresh}`);const s=recentRolls.slice(0,e.limit||20);console.log("=== SENDING RESPONSE ==="),console.log("Response data length:",s.length),console.log(`Rolls in response: ${s.map(w=>`${w.formula}=${w.rollTotal}`).join(", ")}`),t==null||t.send({type:"rolls-result",requestId:e.requestId,data:s})}});router$8.addRoute({actionType:"last-roll",handler:(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received request for last roll data"),t==null||t.send({type:"last-roll-result",requestId:e.requestId,data:recentRolls.length>0?recentRolls[0]:null})}});router$8.addRoute({actionType:"roll",handler:async(e,i)=>{var s,o,l,r,u;const t=i==null?void 0:i.socketManager;try{const{formula:n,flavor:a,createChatMessage:d,speaker:c,whisper:p,requestId:y}=e;let h,f={},m=p&&p.length>0?CONST.DICE_ROLL_MODES.PRIVATE:CONST.DICE_ROLL_MODES.PUBLIC;if(c)try{const g=await fromUuid(c);if(g){if(g instanceof TokenDocument)f={token:g==null?void 0:g.id,actor:(s=g==null?void 0:g.actor)==null?void 0:s.id,scene:(o=g==null?void 0:g.parent)==null?void 0:o.id,alias:(g==null?void 0:g.name)||((l=g==null?void 0:g.actor)==null?void 0:l.name)};else if(g instanceof Actor){const w=(r=game.scenes)==null?void 0:r.active;if(w){const I=(u=w.tokens)==null?void 0:u.filter(E=>{var T;return((T=E.actor)==null?void 0:T.id)===g.id});if(I&&I.length>0){const E=I[0];f={token:E.id,actor:g.id,scene:w.id,alias:E.name||g.name}}else f={actor:g.id,alias:g.name}}}}}catch(g){ModuleLogger.warn(`Failed to process speaker: ${g}`)}try{const g=new Roll(n);await g.evaluate(),d&&await g.toMessage({speaker:f,flavor:a||"",rollMode:m,whisper:p||[]}),h={id:`manual_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!!d,roll:{formula:n,total:g.total,isCritical:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===g.terms[0].faces)}),isFumble:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===1)}),dice:g.dice.map(w=>({faces:w.faces,results:w.results.map(I=>({result:I.result,active:I.active}))})),timestamp:Date.now()}}}catch(g){ModuleLogger.error(`Error rolling formula: ${g}`),t==null||t.send({type:"roll-result",requestId:y,success:!1,error:`Failed to roll formula: ${g.message}`});return}t==null||t.send({type:"roll-result",requestId:y,success:!0,data:h})}catch(n){ModuleLogger.error(`Error in roll handler: ${n}`),t==null||t.send({type:"roll-result",requestId:e.requestId,success:!1,error:n.message||"Unknown error occurred during roll"})}}});function parseFilterString(e){if(!e.includes(":"))return{documentType:e};const i={},t=e.split(",");for(const s of t)if(s.includes(":")){const[o,l]=s.split(":");o&&l&&(i[o.trim()]=l.trim())}return i}function matchesAllFilters(e,i){var t,s;for(const[o,l]of Object.entries(i)){if(!l)continue;if(o==="resultType"){const u=(s=(t=e.item)==null?void 0:t.constructor)==null?void 0:s.name;if(!u||u.toLowerCase()!==l.toLowerCase())return!1;continue}if(o==="package"&&e.item){const u=e.item.package;if(!u||u.toLowerCase()!==l.toLowerCase()&&`Compendium.${u}`.toLowerCase()!==l.toLowerCase())return!1;continue}if(o==="folder"&&e.item){const u=e.item.folder;if(!u&&l)return!1;if(u){const n=typeof u=="object"?u.id:u;if(l===n||l===`Folder.${n}`||`Folder.${l}`===n)continue;return!1}continue}let r;if(!o.includes(".")&&e.item&&e.item[o]!==void 0)r=e.item[o];else{const u=o.split(".");let n=e;for(const a of u){if(n==null){r=void 0;break}n=n[a]}r=n}if(r===void 0||typeof r=="string"&&r.toLowerCase()!==l.toLowerCase())return!1}return!0}const router$7=new Router("searchRouter");router$7.addRoute({actionType:"search",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received search request:",e);try{if(!window.QuickInsert){ModuleLogger.error("QuickInsert not available"),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert not available",results:[]});return}if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(l=>setTimeout(l,500))}catch(l){ModuleLogger.error("Failed to force QuickInsert index:",l),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert index not ready",results:[]});return}}let s=null;if(e.filter){const l=typeof e.filter=="string"?parseFilterString(e.filter):e.filter;s=r=>matchesAllFilters(r,l)}const o=await window.QuickInsert.search(e.query,s,200);ModuleLogger.info(`Search returned ${o.length} results`),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,filter:e.filter,results:o.map(l=>{var u;const r=l.item;return{documentType:r.documentType,folder:r.folder,id:r.id,name:r.name,package:r.package,packageName:r.packageName,subType:r.subType,uuid:r.uuid,icon:r.icon,journalLink:r.journalLink,tagline:r.tagline||"",formattedMatch:l.formattedMatch||"",resultType:(u=r.constructor)==null?void 0:u.name}})})}catch(s){ModuleLogger.error("Error performing search:",s),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:s.message,results:[]})}}});const router$6=new Router("structureRouter");router$6.addRoute({actionType:"structure",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received structure request with params:",e);try{const l=e.includeEntityData??!1,r=e.path||null,u=e.recursive??!1,n=e.recursiveDepth??5,a=e.type?Array.isArray(e.types)?e.types:[e.types]:["Scene","Actor","Item","JournalEntry","RollTable","Cards","Macro","Playlist"],d={Scene:game.scenes,Actor:game.actors,Item:game.items,JournalEntry:game.journal,RollTable:game.tables,Cards:game.cards,Macro:game.macros,Playlist:game.playlists},c=h=>l?h.toObject(!1):{uuid:h.uuid,name:h.name,id:h.id,type:h.documentName},p=(h,f=0)=>{var I;if(!u||f>=n)return{};const m={},w=(((I=game.folders)==null?void 0:I.contents)||[]).filter(E=>{var T;return((T=E.folder)==null?void 0:T.id)===(h==null?void 0:h.id)&&a.includes(E.type)});for(const E of w){const T=E.name||E.id;m[T]={id:E.id,uuid:E.uuid,type:E.type,...p(E,f+1)};const M=E.contents.filter(v=>a.includes(v.documentName)).map(c);M.length>0&&(m[T].entities=M)}return m};let y={};if(r&&r.startsWith("Compendium.")){const h=game.packs.get(r.replace("Compendium.",""));if(!h)throw new Error(`Compendium not found: ${r}`);const m=(await h.getIndex()).contents.map(g=>l?{...g}:{uuid:g.uuid||`${h.collection}.${g._id}`,name:g.name,id:g._id,type:h.documentName});y={compendium:{name:h.title,type:h.documentName,entities:m}}}else if(r&&r.startsWith("Folder.")){const h=r.match(/Folder\.([a-zA-Z0-9]+)/);if(!h)throw new Error(`Invalid folder path: ${r}`);const f=h[1],m=(s=game.folders)==null?void 0:s.get(f);if(!m)throw new Error(`Folder not found: ${r}`);if(!a.includes(m.type))throw new Error(`Folder type ${m.type} not included in requested types`);y.folders=p(m);const g=m.contents.filter(w=>a.includes(w.documentName)).map(c);g.length>0&&(y.entities=g)}else{if(u)y.folders=p(null);else{const f=((o=game.folders)==null?void 0:o.contents)||[];y.folders={};for(const m of a){const g=f.filter(w=>w.type===m&&!w.folder);for(const w of g){const I=w.name||w.id;if(y.folders[I]={id:w.id,uuid:w.uuid,type:w.type},l||!u){const E=w.contents.filter(T=>a.includes(T.documentName)).map(c);E.length>0&&(y.folders[I].entities=E)}}}}const h={};for(const f of a){const m=d[f];if(m){const g=m.filter(w=>!w.folder).map(c);g.length>0&&(h[f.toLowerCase()+"s"]=g)}}if(Object.keys(h).length>0&&(y.entities=h),!r){const f={};for(const m of game.packs.contents)if(a.includes(m.documentName)){const g=m.title||m.collection;f[g]={id:m.collection,name:m.title,type:m.documentName,uuid:`Compendium.${m.collection}`};try{const I=(await m.getIndex()).contents.map(E=>l?{...E}:{uuid:E.uuid||`${m.collection}.${E._id}`,name:E.name,id:E._id,type:m.documentName});I.length>0&&(f[g].entities=I)}catch(w){ModuleLogger.warn(`Failed to load entities for compendium ${m.collection}:`,w)}}Object.keys(f).length>0&&(y.compendiumPacks=f)}}t==null||t.send({type:"structure-result",requestId:e.requestId,data:y})}catch(l){ModuleLogger.error("Error getting structure:",l),t==null||t.send({type:"structure-result",requestId:e.requestId,error:l.message,data:{}})}}});router$6.addRoute({actionType:"get-folder",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received get-folder request for name: ${e.name}`);try{const r=(((s=game.folders)==null?void 0:s.contents)||[]).find(n=>n.name===e.name);if(!r)throw new Error(`Folder not found with name: ${e.name}`);const u=r.contents.map(n=>({uuid:n.uuid,id:n.id,name:n.name,type:n.documentName,img:"img"in n?n.img:null}));t==null||t.send({type:"get-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((o=r.folder)==null?void 0:o.id)||null,contents:u}})}catch(l){ModuleLogger.error("Error getting folder:",l),t==null||t.send({type:"get-folder-result",requestId:e.requestId,error:l.message,data:null})}}});router$6.addRoute({actionType:"create-folder",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received create-folder request:",e);try{const l={name:e.name,type:e.folderType};if(e.parentFolderId){if(!((s=game.folders)==null?void 0:s.get(e.parentFolderId)))throw new Error(`Parent folder not found with ID: ${e.parentFolderId}`);l.folder=e.parentFolderId}const r=await Folder.create(l);t==null||t.send({type:"create-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((o=r.folder)==null?void 0:o.id)||null}})}catch(l){ModuleLogger.error("Error creating folder:",l),t==null||t.send({type:"create-folder-result",requestId:e.requestId,error:l.message,data:null})}}});router$6.addRoute({actionType:"delete-folder",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received delete-folder request:",e);try{const l=(s=game.folders)==null?void 0:s.get(e.folderId);if(!l)throw new Error(`Folder not found with ID: ${e.folderId}`);const r=e.deleteAll??!1;let u=0,n=0;const a=async d=>{var m;let c=0,p=0;const h=(((m=game.folders)==null?void 0:m.contents)||[]).filter(g=>{var w;return((w=g.folder)==null?void 0:w.id)===d.id});for(const g of h){const w=await a(g);c+=w.entities,p+=w.folders}const f=d.contents;c+=f.length;for(const g of f)await g.delete();return await d.delete(),p+=1,{entities:c,folders:p}};if(r){const d=await a(l);u=d.entities,n=d.folders}else{const c=(((o=game.folders)==null?void 0:o.contents)||[]).filter(p=>{var y;return((y=p.folder)==null?void 0:y.id)===l.id});if(l.contents.length>0)throw new Error(`Folder contains ${l.contents.length} entities. Use deleteAll=true to delete them or move them first.`);if(c.length>0)throw new Error(`Folder contains ${c.length} child folders. Use deleteAll=true to delete them or move them first.`);await l.delete(),n=1}t==null||t.send({type:"delete-folder-result",requestId:e.requestId,data:{deleted:!0,folderId:e.folderId,entitiesDeleted:u,foldersDeleted:n}})}catch(l){ModuleLogger.error("Error deleting folder:",l),t==null||t.send({type:"delete-folder-result",requestId:e.requestId,error:l.message,data:null})}}});router$6.addRoute({actionType:"contents",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received contents request for path: ${e.path}`);try{let o=[];if(e.path.startsWith("Compendium.")){const l=game.packs.get(e.path.replace("Compendium.",""));if(!l)throw new Error(`Compendium not found: ${e.path}`);o=(await l.getIndex()).contents.map(u=>({...u}))}else{const l=e.path.match(/Folder\.([a-zA-Z0-9]+)/);if(!l)throw new Error(`Invalid folder path: ${e.path}`);const r=l[1],u=(s=game.folders)==null?void 0:s.get(r);if(!u)throw new Error(`Folder not found: ${e.path}`);o=u.contents.map(n=>({uuid:n.uuid,id:n.id,name:n.name,img:"img"in n?n.img:null,type:n.documentName}))}t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,entities:o})}catch(o){ModuleLogger.error("Error getting contents:",o),t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,error:o.message,entities:[]})}}});function getFoundryVersion(){return game.version}function getFoundryVersionMajor(){return parseInt(getFoundryVersion().split(".")[0],10)}const router$5=new Router("sheetRouter");router$5.addRoute({actionType:"get-sheet",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;if(ModuleLogger.info(`Received sheet request for UUID: ${e.uuid}`),getFoundryVersionMajor()>12){ModuleLogger.error(`Foundry version ${getFoundryVersionMajor()} does not support this endpoint`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"This endpoint is only supported in Foundry VTT version 12"}});return}try{let l=null;if(e.uuid)l=await fromUuid(e.uuid);else if(e.selected){const u=(s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled;u&&u.length>0&&(e.actor?l=u[0].actor:l=u[0].document)}if(!l){ModuleLogger.error(`Entity not found for UUID: ${e.uuid}`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Entity not found",uuid:e.uuid}});return}const r=(o=l.sheet)==null?void 0:o.render(!0);setTimeout(async()=>{try{let u=function(b){b.classList&&b.classList.length&&b.classList.forEach(L=>h.add(L)),b.id&&f.add(b.id);for(let L=0;L<b.children.length;L++)u(b.children[L])};if(!r.element||!r.element[0])throw new Error("Failed to render actor sheet");let n=r.element[0].outerHTML,a="";const d=String(r.appId);document.querySelectorAll("style[data-appid]").forEach(b=>{b.dataset.appid===d&&(a+=b.textContent+`
`)}),document.querySelectorAll(`style[id^="system-${l.type}"]`).forEach(b=>{a+=b.textContent+`
`});const y=document.createElement("div");y.innerHTML=n;const h=new Set,f=new Set;u(y);const m=Array.from(h),g=Array.from(f);ModuleLogger.debug(`Extracted ${m.length} unique classes and ${g.length} unique IDs`);const w=document.querySelectorAll("style"),I=document.querySelectorAll('link[rel="stylesheet"]');w.forEach(b=>{if(b.dataset.appid&&b.dataset.appid===d)return;const L=b.textContent||"";(m.some(C=>L.includes(`.${C}`))||g.some(C=>L.includes(`#${C}`))||L.includes(".window-app")||L.includes(".sheet")||L.includes(".actor-sheet")||L.includes(`.${l.type}-sheet`))&&(ModuleLogger.debug("Adding relevant inline style"),a+=L+`
`)});const E=Array.from(I).map(async b=>{try{const L=b.getAttribute("href");if(!L||L.includes("fonts.googleapis.com"))return"";ModuleLogger.debug(`Fetching external CSS from: ${L}`);const A=L.startsWith("http")?L:L.startsWith("/")?`${window.location.origin}${L}`:`${window.location.origin}/${L}`,C=await fetch(A);return C.ok?await C.text():(ModuleLogger.warn(`Failed to fetch CSS: ${A}, status: ${C.status}`),"")}catch(L){return ModuleLogger.warn(`Failed to fetch external CSS: ${L}`),""}}),T=window.location.origin;ModuleLogger.debug(`Base URL for fetching CSS: ${T}`);const M=[`${T}/css/style.css`,`${T}/styles/style.css`,`${T}/styles/foundry.css`,`${T}/ui/sheets.css`,`${T}/game/styles/foundry.css`,`${T}/game/ui/sheets.css`,`${T}/systems/${game.system.id}/system.css`,`${T}/systems/${game.system.id}/styles/system.css`,`${T}/game/systems/${game.system.id}/system.css`,`${T}/game/systems/${game.system.id}/styles/system.css`];ModuleLogger.debug("All stylesheet links in document:",Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(b=>b.getAttribute("href")).filter(Boolean));const v=Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(b=>b.getAttribute("href")).filter(b=>b!==null&&!b.includes("fonts.googleapis.com")&&!b.includes("//"));M.push(...v),ModuleLogger.debug("All style elements in document:",document.querySelectorAll("style").length);const k=M.map(async b=>{try{ModuleLogger.debug(`Fetching core CSS from: ${b}`);const L=await fetch(b);return L.ok?(ModuleLogger.info(`Successfully loaded CSS from: ${b}`),await L.text()):(ModuleLogger.warn(`Failed to fetch CSS: ${b}, status: ${L.status}`),"")}catch(L){return ModuleLogger.warn(`Failed to fetch core CSS: ${L}`),""}}),R=[...E,...k];(await Promise.all(R)).forEach(b=>{a+=b+`
`}),a.length<100&&(ModuleLogger.warn("CSS fetch failed or returned minimal content. Adding fallback styles."),a+=`
              .window-app {
                font-family: "Signika", sans-serif;
                background: #f0f0e0;
                border-radius: 5px;
                box-shadow: 0 0 20px #000;
                color: #191813;
              }
              .window-content {
                background: rgba(255, 255, 240, 0.9);
                padding: 8px;
                overflow-y: auto;
                background: url(${window.location.origin}/ui/parchment.jpg) repeat;
              }
              input, select, textarea {
                border: 1px solid #7a7971;
                background: rgba(255, 255, 255, 0.8);
              }
              button {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid #7a7971;
                border-radius: 3px;
                cursor: pointer;
              }
              .profile-img {
                border: none;
                max-width: 100%;
                max-height: 220px;
              }
            `),ModuleLogger.debug(`Collected CSS: ${a.length} bytes`),n=n.replace(/src="([^"]+)"/g,(b,L)=>L.startsWith("http")?b:L.startsWith("/")?`src="${window.location.origin}${L}"`:`src="${window.location.origin}/${L}"`),a=a.replace(/url\(['"]?([^'")]+)['"]?\)/g,(b,L)=>L.startsWith("http")||L.startsWith("data:")?b:L.startsWith("/")?`url('${window.location.origin}${L}')`:`url('${window.location.origin}/${L}')`),r.close(),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{html:n,css:a,uuid:e.uuid}}),ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${e.requestId}`),ModuleLogger.debug(`HTML length: ${n.length}, CSS length: ${a.length}`)}catch(u){ModuleLogger.error("Error capturing actor sheet HTML:",u),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to capture actor sheet HTML",uuid:e.uuid}}),r&&typeof r.close=="function"&&r.close()}},500)}catch(l){ModuleLogger.error("Error rendering actor sheet:",l),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to render actor sheet",uuid:e.uuid}})}}});const router$4=new Router("macroRouter");router$4.addRoute({actionType:"macros",handler:async(e,i)=>{var s;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received request for macros");try{const o=((s=game.macros)==null?void 0:s.contents.map(l=>{var r,u;return{uuid:l.uuid,id:l.id,name:l.name,type:l.type||((r=l.data)==null?void 0:r.type)||"unknown",author:((u=l.author)==null?void 0:u.name)||"unknown",command:l.command||"",img:l.img,scope:l.scope,canExecute:l.canExecute}}))||[];t==null||t.send({type:"macros-result",requestId:e.requestId,macros:o})}catch(o){ModuleLogger.error("Error getting macros list:",o),t==null||t.send({type:"macros-result",requestId:e.requestId,error:o.message,macros:[]})}}});router$4.addRoute({actionType:"macro-execute",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info(`Received request to execute macro: ${e.uuid}`);try{if(!e.uuid)throw new Error("Macro UUID is required");const s=await fromUuid(e.uuid);if(!s)throw new Error(`Macro not found with UUID: ${e.uuid}`);if(!(s instanceof CONFIG.Macro.documentClass))throw new Error(`Entity with UUID ${e.uuid} is not a macro`);if(!s.canExecute)throw new Error(`Macro '${s.name}' cannot be executed by the current user`);const o=e.args||{};let l;typeof o=="object"?l=await s.execute({args:o}):l=await s.execute(),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid,success:!0,result:typeof l=="object"?l:{value:l}})}catch(s){ModuleLogger.error("Error executing macro:",s),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid||"",success:!1,error:s.message})}}});const router$3=new Router("utilityRouter");router$3.addRoute({actionType:"execute-js",handler:async(data,context)=>{const socketManager=context==null?void 0:context.socketManager;ModuleLogger.info("Received execute-js request:",data);try{const{script,requestId}=data;if(!script||typeof script!="string")throw new Error("Invalid script provided");let result;try{result=await(async()=>eval(`(async () => { ${script} })()`))()}catch(e){const i=e instanceof Error?e.message:String(e);throw new Error(`Error executing script: ${i}`)}socketManager==null||socketManager.send({type:"execute-js-result",requestId,success:!0,result})}catch(e){ModuleLogger.error("Error in execute-js handler:",e),socketManager==null||socketManager.send({type:"execute-js-result",requestId:data.requestId,success:!1,error:e.message})}}});router$3.addRoute({actionType:"select",handler:async(e,i)=>{var s,o,l,r,u,n,a;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received select entities request:",e);try{const d=(s=game.scenes)==null?void 0:s.active;if(!d)throw new Error("No active scene found");e.overwrite&&((o=canvas==null?void 0:canvas.tokens)==null||o.releaseAll());const c=new Set;e.all&&(((l=d.tokens)==null?void 0:l.contents)||[]).forEach(f=>c.add(f)),e.uuids&&Array.isArray(e.uuids)&&(((r=d.tokens)==null?void 0:r.filter(f=>e.uuids.includes(f.uuid)))||[]).forEach(f=>c.add(f)),e.name&&(((u=d.tokens)==null?void 0:u.filter(f=>{var m,g;return((m=f.name)==null?void 0:m.toLowerCase())===((g=e.name)==null?void 0:g.toLowerCase())}))||[]).forEach(f=>c.add(f)),e.data&&(((n=d.tokens)==null?void 0:n.filter(f=>Object.entries(e.data).every(([m,g])=>{if(m.startsWith("actor.")&&f.actor){const I=m.replace("actor.","");return getProperty(f.actor,I)===g}const w=f.toObject();return getProperty(w,m)===g})))||[]).forEach(f=>c.add(f));const p=Array.from(c);if(p.length===0)throw new Error("No matching entities found");for(const h of p){const f=h.id?(a=canvas==null?void 0:canvas.tokens)==null?void 0:a.get(h.id):null;f&&f.control({releaseOthers:!1})}const y=p.map(h=>h.uuid);t==null||t.send({type:"select-result",requestId:e.requestId,success:!0,count:p.length,message:`${p.length} entities selected`,selected:y})}catch(d){ModuleLogger.error("Error selecting entities:",d),t==null||t.send({type:"select-result",requestId:e.requestId,success:!1,error:d.message})}}});router$3.addRoute({actionType:"selected",handler:async(e,i)=>{var s,o;const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received get selected entities request:",e);try{if(!((s=game.scenes)==null?void 0:s.active))throw new Error("No active scene found");const u=(((o=canvas==null?void 0:canvas.tokens)==null?void 0:o.controlled)||[]).map(n=>{var a;return{tokenUuid:n.document.uuid,actorUuid:((a=n.actor)==null?void 0:a.uuid)||null}});t==null||t.send({type:"selected-result",requestId:e.requestId,success:!0,selected:u})}catch(l){ModuleLogger.error("Error getting selected entities:",l),t==null||t.send({type:"selected-result",requestId:e.requestId,success:!1,error:l.message})}}});const router$2=new Router("fileSystemRouter");router$2.addRoute({actionType:"file-system",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received get file system request:",e);try{const s=e.path||"",o=e.source||"data",l=!!e.recursive,r=await FilePicker.browse(o,s),u=Array.isArray(r.dirs)?r.dirs.map(c=>({name:c.split("/").pop()||c,path:c,type:"directory"})):[],n=Array.isArray(r.files)?r.files.map(c=>({name:c.split("/").pop()||c,path:c,type:"file"})):[];let a=[];if(l&&u.length>0)for(const c of u)try{const p=await FilePicker.browse(o,c.path),y=Array.isArray(p.dirs)?p.dirs.map(f=>({name:f.split("/").pop()||f,path:f,type:"directory"})):[],h=Array.isArray(p.files)?p.files.map(f=>({name:f.split("/").pop()||f,path:f,type:"file"})):[];if(a=a.concat(y,h),l===!0&&y.length>0&&c.path.split("/").length<3)for(const f of y)try{const m=await FilePicker.browse(o,f.path),g=Array.isArray(m.dirs)?m.dirs.map(I=>({name:I.split("/").pop()||I,path:I,type:"directory"})):[],w=Array.isArray(m.files)?m.files.map(I=>({name:I.split("/").pop()||I,path:I,type:"file"})):[];a=a.concat(g,w)}catch(m){ModuleLogger.error(`Error processing deep subdirectory ${f.path}:`,m)}}catch(p){ModuleLogger.error(`Error processing subdirectory ${c.path}:`,p)}const d=[...u,...n];l&&d.push(...a),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!0,path:s,source:o,results:d,recursive:l})}catch(s){ModuleLogger.error("Error getting file system:",s),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!1,error:s.message})}}});router$2.addRoute({actionType:"upload-file",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received upload file request:",e);try{const{path:s,filename:o,source:l,fileData:r,mimeType:u,binaryData:n,overwrite:a}=e;if(!s||!o)throw new Error("Missing required parameters (path, filename)");let d;if(n){if(!Array.isArray(n)||n.length===0)throw new Error("Invalid binary data: must be non-empty array");const f=new Uint8Array(n),m=new Blob([f],{type:u||"application/octet-stream"});d=new File([m],o,{type:u||"application/octet-stream"}),ModuleLogger.info(`Created file from binary data: ${f.length} bytes`)}else if(r){if(!r.includes(",")||!r.startsWith("data:"))throw new Error("Invalid file data format: must be data URL with base64 content");const f=r.split(",")[1];if(!f)throw new Error("No base64 data found in file data");let m;try{m=atob(f)}catch(I){throw new Error(`Invalid base64 data: ${I.message}`)}if(m.length===0)throw new Error("Decoded file data is empty");const g=new Uint8Array(m.length);for(let I=0;I<m.length;I++)g[I]=m.charCodeAt(I);const w=new Blob([g],{type:u||"application/octet-stream"});d=new File([w],o,{type:u||"application/octet-stream"}),ModuleLogger.info(`Created file from base64 data: ${g.length} bytes`)}else throw new Error("Missing file data (either binaryData or fileData is required)");const c=l||"data";if(s&&s!=="/"&&s!=="")try{const f=s.split("/").filter(g=>g.length>0);let m="";for(const g of f){m=m?`${m}/${g}`:g;try{await FilePicker.createDirectory(c,m),ModuleLogger.info(`Created/verified directory: ${m}`)}catch(w){const I=w.message||String(w);if(!I.includes("already exists"))throw ModuleLogger.error(`Error creating directory ${m}:`,w),new Error(`Could not create directory '${m}': ${I}`)}}}catch(f){throw ModuleLogger.error(`Error creating directories for path '${s}':`,f),new Error(`Could not create directory structure: ${f.message}`)}let p=null;try{const f=s&&s!=="/"?`${s}/${o}`:o;p=await FilePicker.browse(c,f)}catch{}if(p&&!a)throw new Error("File already exists. Set overwrite to true to replace it.");const y=await FilePicker.upload(c,s,d);if(!y)throw new Error("FilePicker.upload returned null/undefined result");const h=y&&typeof y=="object"&&"path"in y?y.path:`${s}/${o}`;ModuleLogger.info(`File uploaded successfully: ${h}`),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!0,path:h})}catch(s){ModuleLogger.error("Error uploading file:",s),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!1,error:s.message})}}});router$2.addRoute({actionType:"download-file",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received download file request:",e);try{const{path:s}=e;if(!s)throw new Error("Missing required parameter (path)");const o=await fetch(s.startsWith("http")?s:foundry.utils.getRoute(s));if(!o.ok)throw new Error(`Failed to download file: ${o.status} ${o.statusText}`);const l=await o.blob(),r=new FileReader,u=await new Promise((n,a)=>{r.onload=()=>n(r.result),r.onerror=a,r.readAsDataURL(l)});t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!0,path:s,fileData:u,filename:s.split("/").pop()||"file",mimeType:l.type})}catch(s){ModuleLogger.error("Error downloading file:",s),t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!1,error:s.message})}}});const router$1=new Router("dnd5eRouter");Hooks.once("init",()=>{if(game.system.id==="dnd5e"){router$1.addRoute({actionType:"get-actor-details",handler:async(t,s)=>{const o=s==null?void 0:s.socketManager;ModuleLogger.info("Received get-actor-details request:",t);try{const{actorUuid:l,details:r}=t;if(!l)throw new Error("actorUuid is required");if(!r||!Array.isArray(r)||r.length===0)throw new Error("details array is required and cannot be empty");const u=await fromUuid(l);if(!u)throw new Error(`Actor not found with UUID: ${l}`);const n={uuid:l};r.includes("resources")&&(n.resources=u.system.resources),r.includes("spells")&&(n.spells=u.items.filter(a=>a.type==="spell")),r.includes("items")&&(n.items=u.items.filter(a=>["weapon","equipment","consumable","tool","loot","backpack"].includes(a.type))),r.includes("features")&&(n.features=u.items.filter(a=>["feat","background","class"].includes(a.type))),o==null||o.send({type:"get-actor-details-result",requestId:t.requestId,data:n})}catch(l){ModuleLogger.error("Error in get-actor-details:",l),o==null||o.send({type:"get-actor-details-result",requestId:t.requestId,error:l.message})}}}),router$1.addRoute({actionType:"modify-item-charges",handler:async(t,s)=>{const o=s==null?void 0:s.socketManager;ModuleLogger.info("Received modify-item-charges request:",t);try{const{actorUuid:l,itemUuid:r,itemName:u,amount:n}=t;if(!l)throw new Error("actorUuid is required");if(!r&&!u)throw new Error("itemUuid or itemName is required");if(typeof n!="number")throw new Error("amount must be a number");const a=await fromUuid(l);if(!a)throw new Error(`Actor not found with UUID: ${l}`);let d=null;if(r?d=a.items.get(r.split(".").pop()):u&&(d=a.items.find(w=>w.name.toLowerCase()===u.toLowerCase())),!d)throw new Error(`Item not found on actor ${a.name}`);const c=d.system.uses||{},p=c.spent||0,y=c.value??c.max??0,h=c.max||0,f=Math.max(0,Math.min(h,p-n)),m=Math.max(0,Math.min(h,y+n)),g={system:{...d.system,uses:{...d.system.uses,spent:f,value:m}}};await d.update(g),o==null||o.send({type:"modify-item-charges-result",requestId:t.requestId,data:{itemUuid:d.uuid,oldCharges:y,newCharges:m}})}catch(l){ModuleLogger.error("Error in modify-item-charges:",l),o==null||o.send({type:"modify-item-charges-result",requestId:t.requestId,error:l.message})}}});const i=async(t,s,o)=>{var u,n,a;const l=s==null?void 0:s.socketManager,r=o?`use-${o}`:"use-ability";ModuleLogger.info(`Received ${r} request:`,t);try{const{actorUuid:d,abilityUuid:c,abilityName:p,targetUuid:y}=t;if(!d)throw new Error("actorUuid is required");if(!c&&!p)throw new Error("abilityUuid or abilityName is required");const h=await fromUuid(d);if(!h)throw new Error(`Actor not found with UUID: ${d}`);let f=null;if(c?f=await fromUuid(c):p&&(f=h.items.find(I=>I.name.toLowerCase()===p.toLowerCase()?o?o==="item"?I.type!=="feat"&&I.type!=="spell":I.type===o:!0:!1)),!f)throw new Error(`Ability not found on actor ${h.name}`);let m=null;if(y){const w=await fromUuid(y);if(w&&w.documentName==="Token")m=w;else if(w&&w.documentName==="Actor"){const I=(u=game.scenes)==null?void 0:u.active;if(I){const E=(n=I.tokens)==null?void 0:n.filter(T=>{var M;return((M=T.actor)==null?void 0:M.id)===w.id});E&&E.length>0&&(m=E[0])}}if(m&&(canvas!=null&&canvas.tokens)){(a=game.user)==null||a.targets.forEach(E=>E.setTarget(!1,{releaseOthers:!1}));const I=canvas.tokens.get(m.id);I&&I.setTarget(!0,{releaseOthers:!0})}}const g=await f.use();l==null||l.send({type:`${r}-result`,requestId:t.requestId,data:{uuid:d,ability:f.name,result:g?g.id:null}})}catch(d){ModuleLogger.error(`Error in ${r}:`,d),l==null||l.send({type:`${r}-result`,requestId:t.requestId,error:d.message})}};router$1.addRoute({actionType:"use-ability",handler:(t,s)=>i(t,s,null)}),router$1.addRoute({actionType:"use-feature",handler:(t,s)=>i(t,s,"feat")}),router$1.addRoute({actionType:"use-spell",handler:(t,s)=>i(t,s,"spell")}),router$1.addRoute({actionType:"use-item",handler:(t,s)=>i(t,s,"item")}),router$1.addRoute({actionType:"modify-experience",handler:async(t,s)=>{var l;const o=s==null?void 0:s.socketManager;ModuleLogger.info("Received modify-experience request:",t);try{const{actorUuid:r,selected:u,amount:n}=t;if(!r&&!u)throw new Error("Either actorUuid or selected must be provided");if(typeof n!="number")throw new Error("amount must be a number");let a=null;if(r)a=await fromUuid(r);else if(u){const p=(l=canvas.tokens)==null?void 0:l.controlled;if(!p||p.length===0)throw new Error("No token selected");p.length>1&&ModuleLogger.warn("Multiple tokens selected, using the first one."),a=p[0].actor}if(!a)throw new Error("Actor not found");const d=a.system.details.xp.value,c=d+n;await a.update({"system.details.xp.value":c}),o==null||o.send({type:"modify-experience-result",requestId:t.requestId,data:{actorUuid:a.uuid,oldXp:d,newXp:c}})}catch(r){ModuleLogger.error("Error in modify-experience:",r),o==null||o.send({type:"modify-experience-result",requestId:t.requestId,error:r.message})}}})}});function mapToFoundryMessageType(e){return["base","ic","ooc","roll","emote","other","player-chat"].includes(e)?e:{"gm-message":"base",gm:"base",dm:"base","player-chat":"base",whisper:"ic",blind:"base",private:"ic"}[e]||"base"}function refreshChatData(){var e;try{const i=((e=game.messages)==null?void 0:e.contents)||[];window.recentChatMessages||(window.recentChatMessages=[]),window.recentChatMessages.length=0,i.forEach(s=>{var o,l;if(!s.isRoll){const r={id:s.id,messageId:s.id,user:{id:(o=s.user)==null?void 0:o.id,name:(l=s.user)==null?void 0:l.name},content:s.content,flavor:s.flavor||"",type:mapToFoundryMessageType(s.type)||"player-chat",timestamp:s.timestamp||Date.now(),speaker:s.speaker,whisper:s.whisper||[],blind:s.blind||!1};window.recentChatMessages.unshift(r)}});const t=100;window.recentChatMessages.length>t&&(window.recentChatMessages.length=t),ModuleLogger.debug(`Refreshed chat messages: ${window.recentChatMessages.length} messages`)}catch(i){ModuleLogger.error("Error refreshing chat messages:",i)}}const router=new Router("chatRouter");router.addRoute({actionType:"chat",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received incoming chat message from relay server:",e);try{const s=e.message||e;if(!s||!s.message){ModuleLogger.warn("Invalid chat message format - missing message content");return}const o={content:s.message,speaker:{alias:s.speaker||"The Gold Box AI"},type:mapToFoundryMessageType(s.type)||"ic",flavor:s.flavor||""};await ChatMessage.create(o),ModuleLogger.info(`Successfully created chat message from relay server: ${s.message.substring(0,50)}...`),t==null||t.send({type:"chat-result",requestId:e.requestId,success:!0,message:"Chat message delivered successfully"})}catch(s){ModuleLogger.error("Error processing incoming chat message:",s),t==null||t.send({type:"chat-result",requestId:e.requestId,success:!1,error:s instanceof Error?s.message:String(s)})}}});router.addRoute({actionType:"chat-messages",handler:async(e,i)=>{const t=i==null?void 0:i.socketManager;ModuleLogger.info("Received request for chat messages:",e);try{const s=e.limit||50,o=e.sort||"timestamp",l=e.order||"desc",r=e.refresh||!1,u=game.modules.get(moduleId);let n=[];u&&u.api&&u.api.getChatMessages?n=[...u.api.getChatMessages()]:ModuleLogger.warn("Module API or getChatMessages method not available"),r&&(ModuleLogger.info(`Refreshing chat data before returning messages. Current count: ${n.length}, refresh flag: ${r}`),refreshChatData(),u&&u.api&&u.api.getChatMessages&&(n=[...u.api.getChatMessages()]),ModuleLogger.info(`After refresh - new message count: ${n.length}`)),o==="timestamp"&&n.sort((d,c)=>l==="desc"?c.timestamp-d.timestamp:d.timestamp-c.timestamp);const a=n.slice(0,s);ModuleLogger.info(`Returning ${a.length} chat messages`),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,messages:a,total:n.length})}catch(s){ModuleLogger.error("Error processing chat messages request:",s),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,error:s instanceof Error?s.message:String(s),messages:[]})}}});const routers=[router$b,router$a,router$9,router,router$8,router$7,router$6,router$5,router$4,router$3,router$2,router$1];function initializeWebSocket(){const e=game.settings.get(moduleId,"wsRelayUrl"),i=game.settings.get(moduleId,"apiKey"),t=game.modules.get(moduleId);if(!e){ModuleLogger.error("WebSocket relay URL is empty. Please configure it in module settings.");return}ModuleLogger.info(`Initializing WebSocket with URL: ${e}`);try{if(t.socketManager?ModuleLogger.info("WebSocket manager already exists, not creating a new one"):(t.socketManager=WebSocketManager.getInstance(e,i),t.socketManager&&t.socketManager.connect()),!t.socketManager){ModuleLogger.warn("No WebSocket manager available, skipping message handler setup");return}const s=t.socketManager;routers.forEach(o=>{o.reflect(s)}),ModuleLogger.info(`Registered ${routers.length} routers with WebSocket manager`)}catch(s){ModuleLogger.error("Error initializing WebSocket:",s)}}Hooks.once("init",()=>{console.log(`Initializing ${moduleId}`);for(let[i,t]of Object.entries(SETTINGS.GET_DEFAULT()))game.settings.register(CONSTANTS.MODULE_ID,i,t);const e=game.modules.get(moduleId);e.api={getWebSocketManager:()=>e.socketManager?e.socketManager:(ModuleLogger.warn("WebSocketManager requested but not initialized"),null),search:async(i,t)=>{if(!window.QuickInsert)return ModuleLogger.error("QuickInsert not available"),[];if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(o=>setTimeout(o,500))}catch(o){ModuleLogger.error("Failed to force QuickInsert index:",o)}}let s=null;return t&&(s=o=>o.documentType===t),window.QuickInsert.search(i,s,100)},getByUuid:async i=>{try{return await fromUuid(i)}catch(t){return ModuleLogger.error("Error getting entity by UUID:",t),null}},getChatMessages:(i=50)=>{var t;return ModuleLogger.info(`getChatMessages called with limit: ${i}`),((t=window.recentChatMessages)==null?void 0:t.slice(0,i))||[]}}});Hooks.on("renderSettingsConfig",(e,i)=>{const t=i instanceof HTMLElement?$(i):i,s=t.find(`input[name="${moduleId}.apiKey"]`);if(s.length){s.attr("type","password");const l=$('<button type="button" style="margin-left: 10px;"><i class="fas fa-info-circle"></i> Show Client Info</button>');s.after(l),l.on("click",()=>{const u=game.modules.get(moduleId).api.getWebSocketManager();if(u){const n=u.getClientId(),a=game.world.id,d=game.world.title,c=game.version,p=game.system.id,y=game.system.title||game.system.id,h=game.system.version||"unknown",f=game.settings.get(moduleId,"customName");new Dialog({title:"Client Information",content:`
            <div class="form-group">
                <label>Client ID</label>
                <div class="form-fields">
                    <input type="text" value="${n}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World ID</label>
                <div class="form-fields">
                    <input type="text" value="${a}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World Title</label>
                <div class="form-fields">
                    <input type="text" value="${d}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Foundry Version</label>
                <div class="form-fields">
                    <input type="text" value="${c}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System ID</label>
                <div class="form-fields">
                    <input type="text" value="${p}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Title</label>
                <div class="form-fields">
                    <input type="text" value="${y}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Version</label>
                <div class="form-fields">
                    <input type="text" value="${h}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Custom Name</label>
                <div class="form-fields">
                    <input type="text" value="${f}" readonly>
                </div>
            </div>
            <p class="notes">Click any field to copy its value.</p>
          `,buttons:{ok:{label:"OK"}},render:m=>{const w=(m instanceof HTMLElement?$(m):m).find('input[type="text"]');w.css("cursor","pointer"),w.on("click",I=>{const E=I.currentTarget;navigator.clipboard.writeText(E.value).then(()=>{ui.notifications.info("Copied to clipboard."),E.select()})})}}).render(!0)}else ui.notifications.warn("WebSocketManager is not available.")}),s.on("change",r=>{const u=r.target.value;game.settings.set(moduleId,"apiKey",u).then(()=>{new Dialog({title:"Reload Required",content:"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})}const o=t.find(`input[name="${moduleId}.customName"]`);o.length&&o.on("change",l=>{const r=l.target.value;game.settings.set(moduleId,"customName",r).then(()=>{new Dialog({title:"Reload Required",content:"<p>The Custom Name has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})});Hooks.once("ready",()=>{var e;window.recentChatMessages||(window.recentChatMessages=[]);try{const i=((e=game.messages)==null?void 0:e.contents)||[];ModuleLogger.info(`Found ${i.length} existing chat messages to populate recentChatMessages and recentRolls`),i.forEach(o=>{var l,r,u,n,a,d,c;if(o.isRoll){if(o.isRoll&&((u=o.rolls)==null?void 0:u.length)>0){const p=o.id,y={id:p,messageId:o.id,user:{id:(n=o.user)==null?void 0:n.id,name:(a=o.user)==null?void 0:a.name},speaker:o.speaker,flavor:o.flavor||"",rollTotal:o.rolls[0].total,formula:o.rolls[0].formula,isCritical:o.rolls[0].isCritical||!1,isFumble:o.rolls[0].isFumble||!1,dice:(d=o.rolls[0].dice)==null?void 0:d.map(f=>({faces:f.faces,results:f.results.map(m=>({result:m.result,active:m.active}))})),timestamp:o.timestamp||Date.now()},h=recentRolls.findIndex(f=>f.id===p);h!==-1?recentRolls[h]=y:recentRolls.unshift(y),ModuleLogger.debug(`Populated historical roll: ${y.formula} = ${y.rollTotal} from ${(c=y.user)==null?void 0:c.name}`)}}else{const p={id:o.id,messageId:o.id,user:{id:(l=o.user)==null?void 0:l.id,name:(r=o.user)==null?void 0:r.name},content:o.content,flavor:o.flavor||"",type:o.type||"player-chat",timestamp:o.timestamp||Date.now(),speaker:o.speaker,whisper:o.whisper||[],blind:o.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const y=window.recentChatMessages.findIndex(h=>h.id===o.id);y!==-1?window.recentChatMessages[y]=p:window.recentChatMessages.unshift(p)}});const t=100;window.recentChatMessages.length>t&&(window.recentChatMessages.length=t);const s=game.settings.get(moduleId,SETTINGS.MAX_ROLLS_STORED);recentRolls.length>s&&(recentRolls.length=s),ModuleLogger.info(`Populated recentChatMessages with ${window.recentChatMessages.length} messages from existing chat log`),ModuleLogger.info(`Populated recentRolls with ${recentRolls.length} rolls from existing chat log`)}catch(i){ModuleLogger.error("Error populating chat messages and rolls from existing log:",i)}setTimeout(()=>{initializeWebSocket()},1e3)});Hooks.on("createChatMessage",e=>{var i,t,s,o,l,r,u,n,a;if(!e.isRoll){ModuleLogger.info(`Collecting chat message from ${((i=e.user)==null?void 0:i.name)||"unknown"}`);const d={id:e.id,messageId:e.id,user:{id:(t=e.user)==null?void 0:t.id,name:(s=e.user)==null?void 0:s.name},content:e.content,flavor:e.flavor||"",type:e.type||"player-chat",timestamp:Date.now(),speaker:e.speaker,whisper:e.whisper||[],blind:e.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const c=window.recentChatMessages.findIndex(y=>y.id===e.id);c!==-1?window.recentChatMessages[c]=d:window.recentChatMessages.unshift(d);const p=100;window.recentChatMessages.length>p&&(window.recentChatMessages.length=p)}if(e.isRoll&&((o=e.rolls)==null?void 0:o.length)>0){ModuleLogger.info(`Detected dice roll from ${((l=e.user)==null?void 0:l.name)||"unknown"}`);const d=e.id,c={id:d,messageId:e.id,user:{id:(r=e.user)==null?void 0:r.id,name:(u=e.user)==null?void 0:u.name},speaker:e.speaker,flavor:e.flavor||"",rollTotal:e.rolls[0].total,formula:e.rolls[0].formula,isCritical:e.rolls[0].isCritical||!1,isFumble:e.rolls[0].isFumble||!1,dice:(n=e.rolls[0].dice)==null?void 0:n.map(h=>({faces:h.faces,results:h.results.map(f=>({result:f.result,active:f.active}))})),timestamp:Date.now()},p=recentRolls.findIndex(h=>h.id===d);if(p!==-1)recentRolls[p]=c;else{recentRolls.unshift(c);const h=game.settings.get(moduleId,SETTINGS.MAX_ROLLS_STORED);recentRolls.length>h&&(recentRolls.length=h)}const y=game.modules.get(moduleId);(a=y.socketManager)!=null&&a.isConnected()&&y.socketManager.send({type:"roll-data",data:c})}});
//# sourceMappingURL=module.js.map
