var A=Object.defineProperty;var U=(e,s,t)=>s in e?A(e,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[s]=t;var M=(e,s,t)=>U(e,typeof s!="symbol"?s+"":s,t);const id="foundryvtt-gold-api";class dnd5e{constructor(){M(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}class a5e{constructor(){M(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}const SYSTEMS={SUPPORTED_SYSTEMS:{dnd5e:{latest:dnd5e},a5e:{latest:a5e}},DEFAULT_SETTINGS:{ACTOR_CURRENCY_ATTRIBUTE:""},_currentSystem:!1,get DATA(){var n;if(this._currentSystem)return this._currentSystem;const e=(n=this.SUPPORTED_SYSTEMS)==null?void 0:n[game.system.id.toLowerCase()];if(!e)return this.DEFAULT_SETTINGS;if(e[game.system.version])return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[game.system.version]),this._currentSystem;const s=Object.keys(e);if(s.length===1)return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[s[0]]),this._currentSystem;s.sort((o,u)=>o==="latest"||u==="latest"?-1/0:isNewerVersion(u,o)?-1:1);const t=s.find(o=>o==="latest"||!isNewerVersion(game.system.version,o));return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[t]),this._currentSystem}},CONSTANTS={MODULE_ID:id},moduleId=id,recentRolls=[],SETTINGS={ACTOR_CURRENCY_ATTRIBUTE:"actorCurrencyAttribute",WS_RELAY_URL:"wsRelayUrl",API_KEY:"apiKey",CUSTOM_NAME:"customName",LOG_LEVEL:"logLevel",PING_INTERVAL:"pingInterval",RECONNECT_MAX_ATTEMPTS:"reconnectMaxAttempts",RECONNECT_BASE_DELAY:"reconnectBaseDelay",MAX_ROLLS_STORED:"maxRollsStored",SYSTEM_FOUND:"systemFound",SYSTEM_NOT_FOUND_WARNING_SHOWN:"systemNotFoundWarningShown",SYSTEM_VERSION:"systemVersion",GET_DEFAULT(){return foundry.utils.deepClone(SETTINGS.DEFAULTS())},GET_SYSTEM_DEFAULTS(){return Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).filter(e=>e[1].system))},DEFAULTS:()=>({[SETTINGS.ACTOR_CURRENCY_ATTRIBUTE]:{name:"Actor Currency attribute",hint:"Reference path to the actor currency attribute",scope:"world",config:!1,system:!0,default:SYSTEMS.DATA.ACTOR_CURRENCY_ATTRIBUTE,type:String},[SETTINGS.SYSTEM_VERSION]:{scope:"world",config:!1,default:"0.0.0",type:String},[SETTINGS.SYSTEM_FOUND]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.WS_RELAY_URL]:{name:"WebSocket Relay URL",hint:"URL for the WebSocket relay server",scope:"world",config:!0,type:String,default:"http://localhost:3010",requiresReload:!0},[SETTINGS.API_KEY]:{name:"API Key",hint:"API Key for authentication with the relay server",scope:"world",config:!0,type:String,default:game.world.id,requiresReload:!0},[SETTINGS.CUSTOM_NAME]:{name:"Custom Client Name",hint:"A custom name to identify this client (optional)",scope:"world",config:!0,type:String,default:"",requiresReload:!0},[SETTINGS.LOG_LEVEL]:{name:"Log Level",hint:"Set the level of detail for module logging",scope:"world",config:!0,type:Number,choices:{0:"debug",1:"info",2:"warn",3:"error"},default:2},[SETTINGS.PING_INTERVAL]:{name:"Ping Interval (seconds)",hint:"How often (in seconds) the module sends a ping to the relay server to keep the connection alive.",scope:"world",config:!0,type:Number,default:30,range:{min:5,max:600,step:1},requiresReload:!0},[SETTINGS.RECONNECT_MAX_ATTEMPTS]:{name:"Max Reconnect Attempts",hint:"Maximum number of times the module will try to reconnect after losing connection.",scope:"world",config:!0,type:Number,default:20,requiresReload:!0},[SETTINGS.RECONNECT_BASE_DELAY]:{name:"Reconnect Base Delay (ms)",hint:"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.",scope:"world",config:!0,type:Number,default:1e3,requiresReload:!0},[SETTINGS.MAX_ROLLS_STORED]:{name:"Maximum Rolls Stored",hint:"Maximum number of recent rolls to store in memory",scope:"world",config:!0,type:Number,default:20,range:{min:5,max:100,step:1},requiresReload:!1}})};class ModuleLogger{static debugLevel(){return game.settings.get(moduleId,"logLevel")}static debug(s,...t){return this.debugLevel()<1&&console.log(`${moduleId} | ${s}`,...t),s}static info(s,...t){return this.debugLevel()<2&&console.log(`${moduleId} | ${s}`,...t),s}static warn(s,...t){return this.debugLevel()<3&&console.warn(`${moduleId} | ${s}`,...t),s}static error(s,...t){return this.debugLevel()<4&&console.error(`${moduleId} | ${s}`,...t),s}}var WSCloseCodes=(e=>(e[e.Normal=1e3]="Normal",e[e.NoClientId=4001]="NoClientId",e[e.NoAuth=4002]="NoAuth",e[e.NoConnectedGuild=4003]="NoConnectedGuild",e[e.InternalError=4e3]="InternalError",e[e.DuplicateConnection=4004]="DuplicateConnection",e[e.ServerShutdown=4005]="ServerShutdown",e))(WSCloseCodes||{});const S=class S{constructor(s,t){M(this,"url");M(this,"token");M(this,"socket",null);M(this,"messageHandlers",new Map);M(this,"reconnectTimer",null);M(this,"reconnectAttempts",0);M(this,"clientId");M(this,"pingInterval",null);M(this,"isConnecting",!1);M(this,"isPrimaryGM",!1);var n,o,u;this.url=s,this.token=t,this.clientId=`foundry-${((n=game.user)==null?void 0:n.id)||Math.random().toString(36).substring(2,15)}`,this.isPrimaryGM=this.checkIfPrimaryGM(),ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`),(o=game.user)!=null&&o.isGM&&((u=game.user)==null?void 0:u.role)===4&&(Hooks.on("userConnected",this.reevaluatePrimaryGM.bind(this)),Hooks.on("userDisconnected",this.reevaluatePrimaryGM.bind(this)))}static getInstance(s,t){var n,o;return!((n=game.user)!=null&&n.isGM)||((o=game.user)==null?void 0:o.role)!==4?(ModuleLogger.info("WebSocketManager not created - user is not a full GM"),null):(S.instance||(ModuleLogger.info("Creating new WebSocketManager instance"),S.instance=new S(s,t)),S.instance)}checkIfPrimaryGM(){var u,r,l,i,d,a;if(!((u=game.user)!=null&&u.isGM)||((r=game.user)==null?void 0:r.role)!==4)return!1;const s=(l=game.user)==null?void 0:l.id,t=((i=game.users)==null?void 0:i.filter(c=>c.role===4&&c.active))||[];if(t.length===0)return!1;const n=[...t].sort((c,p)=>(c.id||"").localeCompare(p.id||"")),o=((d=n[0])==null?void 0:d.id)===s;return ModuleLogger.info(`Primary GM check - Current user: ${s}, Primary GM: ${(a=n[0])==null?void 0:a.id}, isPrimary: ${o}`),o}reevaluatePrimaryGM(){const s=this.isPrimaryGM;this.isPrimaryGM=this.checkIfPrimaryGM(),s!==this.isPrimaryGM&&(ModuleLogger.info(`Primary GM status changed: ${s} -> ${this.isPrimaryGM}`),this.isPrimaryGM&&!this.isConnected()&&(ModuleLogger.info("Taking over as primary GM, connecting WebSocket"),this.connect()),!this.isPrimaryGM&&this.isConnected()&&(ModuleLogger.info("No longer primary GM, disconnecting WebSocket"),this.disconnect()))}connect(){var s,t;if(!((s=game.user)!=null&&s.isGM)||((t=game.user)==null?void 0:t.role)!==4){ModuleLogger.info("WebSocket connection aborted - user is not a full GM");return}if(!this.isPrimaryGM){ModuleLogger.info("WebSocket connection aborted - user is not the primary GM");return}if(this.isConnecting){ModuleLogger.info("Already attempting to connect");return}if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){ModuleLogger.info("WebSocket already connected or connecting");return}this.isConnecting=!0;try{const n=new URL(this.url);n.searchParams.set("id",this.clientId),n.searchParams.set("token",this.token),game.world&&(n.searchParams.set("worldId",game.world.id),n.searchParams.set("worldTitle",game.world.title)),n.searchParams.set("foundryVersion",game.version),n.searchParams.set("systemId",game.system.id),n.searchParams.set("systemTitle",game.system.title||game.system.id),n.searchParams.set("systemVersion",game.system.version||"unknown");const o=game.settings.get(moduleId,"customName");o&&n.searchParams.set("customName",o),ModuleLogger.info(`Connecting to WebSocket at ${n.toString()}`),this.socket=new WebSocket(n.toString());const u=window.setTimeout(()=>{this.socket&&this.socket.readyState===WebSocket.CONNECTING&&(ModuleLogger.error("Connection timed out"),this.socket.close(),this.socket=null,this.isConnecting=!1,this.scheduleReconnect())},5e3);this.socket.addEventListener("open",r=>{window.clearTimeout(u),this.onOpen(r)}),this.socket.addEventListener("close",r=>{window.clearTimeout(u),this.onClose(r)}),this.socket.addEventListener("error",r=>{window.clearTimeout(u),this.onError(r)}),this.socket.addEventListener("message",this.onMessage.bind(this))}catch(n){ModuleLogger.error("Error creating WebSocket:",n),this.isConnecting=!1,this.scheduleReconnect()}}disconnect(){this.socket&&(ModuleLogger.info("Disconnecting WebSocket"),this.socket.close(WSCloseCodes.Normal,"Disconnecting"),this.socket=null),this.reconnectTimer!==null&&(window.clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),this.reconnectAttempts=0,this.isConnecting=!1}isConnected(){return this.socket!==null&&this.socket.readyState===WebSocket.OPEN}getClientId(){return this.clientId}send(s){var t,n;if(ModuleLogger.info(`Send called, readyState: ${(t=this.socket)==null?void 0:t.readyState}`),this.socket&&this.socket.readyState===WebSocket.OPEN)try{return ModuleLogger.info("Sending message:",s),this.socket.send(JSON.stringify(s)),!0}catch(o){return ModuleLogger.error("Error sending message:",o),!1}else return ModuleLogger.warn(`WebSocket not ready, state: ${(n=this.socket)==null?void 0:n.readyState}`),!1}onMessageType(s,t){this.messageHandlers.set(s,t)}onOpen(s){ModuleLogger.info("WebSocket connected"),this.isConnecting=!1,this.reconnectAttempts=0,this.send({type:"ping"});const t=game.settings.get(moduleId,SETTINGS.PING_INTERVAL),n=t*1e3;ModuleLogger.info(`Starting application ping interval: ${t} seconds`),this.pingInterval!==null&&window.clearInterval(this.pingInterval),this.pingInterval=window.setInterval(()=>{this.isConnected()&&this.send({type:"ping"})},n)}onClose(s){ModuleLogger.info(`WebSocket disconnected: ${s.code} - ${s.reason}`),this.socket=null,this.isConnecting=!1,this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),s.code!==WSCloseCodes.Normal&&this.isPrimaryGM&&this.scheduleReconnect()}onError(s){ModuleLogger.error("WebSocket error:",s),this.isConnecting=!1}async onMessage(s){try{const t=JSON.parse(s.data);ModuleLogger.info("Received message:",t),t.type&&this.messageHandlers.has(t.type)?(ModuleLogger.info(`Handling message of type: ${t.type}`),this.messageHandlers.get(t.type)(t,{socketManager:this})):t.type&&ModuleLogger.warn(`No handler for message type: ${t.type}`)}catch(t){ModuleLogger.error("Error processing message:",t)}}scheduleReconnect(){if(this.reconnectTimer!==null)return;const s=game.settings.get(moduleId,SETTINGS.RECONNECT_MAX_ATTEMPTS),t=game.settings.get(moduleId,SETTINGS.RECONNECT_BASE_DELAY);if(this.reconnectAttempts++,this.reconnectAttempts>s){ModuleLogger.error(`Maximum reconnection attempts (${s}) reached`),this.reconnectAttempts=0;return}const n=Math.min(3e4,t*Math.pow(2,this.reconnectAttempts-1));ModuleLogger.info(`Scheduling reconnect in ${n}ms (attempt ${this.reconnectAttempts}/${s})`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=null,this.isPrimaryGM?(ModuleLogger.info("Attempting reconnect..."),this.connect()):(ModuleLogger.info("Reconnect attempt aborted - no longer primary GM."),this.reconnectAttempts=0)},n)}};M(S,"instance",null);let WebSocketManager=S;class Router{constructor(s,t=[]){M(this,"title");M(this,"routes");this.title=s,this.routes=t}addRoute(s){this.routes.push(s)}reflect(s){this.routes.forEach(t=>s.onMessageType(t.actionType,t.handler))}}const router$b=new Router("pingRouter");router$b.addRoute({actionType:"ping",handler:e=>{ModuleLogger.info("Received ping, sending pong"),e.socketManager.send({type:"pong"})}});router$b.addRoute({actionType:"pong",handler:()=>{ModuleLogger.info("Received pong")}});function deepSerializeEntity(e){var s,t,n,o,u;if(!e)return null;try{let r=e.toObject?e.toObject(!0):JSON.parse(JSON.stringify(e));if(e.system){if(e.system.attributes){for(const[l,i]of Object.entries(e.system.attributes))if(((t=(s=r.system)==null?void 0:s.attributes)==null?void 0:t[l])===null&&i!==null&&(r.system.attributes||(r.system.attributes={}),r.system.attributes[l]=JSON.parse(JSON.stringify(i))),typeof i=="object"&&i!==null)for(const[d,a]of Object.entries(i))((u=(o=(n=r.system)==null?void 0:n.attributes)==null?void 0:o[l])==null?void 0:u[d])===null&&a!==null&&(r.system.attributes[l]||(r.system.attributes[l]={}),r.system.attributes[l][d]=JSON.parse(JSON.stringify(a)))}["traits","abilities","skills","resources"].forEach(l=>{var i,d,a,c,p;if(e.system[l]){for(const[y,h]of Object.entries(e.system[l]))if(((d=(i=r.system)==null?void 0:i[l])==null?void 0:d[y])===null&&h!==null&&(r.system[l]||(r.system[l]={}),r.system[l][y]=JSON.parse(JSON.stringify(h))),typeof h=="object"&&h!==null)for(const[f,m]of Object.entries(h))((p=(c=(a=r.system)==null?void 0:a[l])==null?void 0:c[y])==null?void 0:p[f])===null&&m!==null&&(r.system[l][y]||(r.system[l][y]={}),r.system[l][y][f]=JSON.parse(JSON.stringify(m)))}})}if(e.items&&e.items.size>0&&Array.isArray(r.items))try{const l=e.items;if(Array.isArray(l.contents))for(let i=0;i<l.contents.length;i++)i<r.items.length&&(r.items[i]=deepSerializeEntity(l.contents[i]));else if(typeof l.entries=="function"){const i=Array.from(l.entries());for(let d=0;d<i.length;d++){const[a,c]=i[d];d<r.items.length&&(r.items[d]=deepSerializeEntity(c))}}}catch(l){ModuleLogger.warn("Failed to process entity.items collection:",l)}if(e.effects&&e.effects.size>0&&Array.isArray(r.effects))try{const l=e.effects;if(Array.isArray(l.contents))for(let i=0;i<l.contents.length;i++)i<r.effects.length&&(r.effects[i]=deepSerializeEntity(l.contents[i]));else if(typeof l.entries=="function"){const i=Array.from(l.entries());for(let d=0;d<i.length;d++){const[a,c]=i[d];d<r.effects.length&&(r.effects[d]=deepSerializeEntity(c))}}}catch(l){ModuleLogger.warn("Failed to process entity.effects collection:",l)}return r}catch(r){return ModuleLogger.error("Error deep serializing entity:",r),e.toObject?e.toObject():e}}const router$a=new Router("entityRouter");router$a.addRoute({actionType:"entity",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received entity request:",e);try{let o,u=[],r=e.uuid;if(e.selected){const l=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(l)for(let i of l)e.actor?o=i.actor:o=i.document,o&&(r=o.uuid,u.push(deepSerializeEntity(o)))}else o=await fromUuid(e.uuid),u=o?deepSerializeEntity(o):null;if(!u){ModuleLogger.error(`Entity not found: ${e.uuid}`),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:"Entity not found",data:null});return}ModuleLogger.info(`Sending entity data for: ${e.uuid}`,u),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:r,data:u})}catch(o){ModuleLogger.error("Error getting entity:",o),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:o.message,data:null})}}});router$a.addRoute({actionType:"create",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received create entity request for type: ${e.entityType}`);try{const n=getDocumentClass(e.entityType);if(!n)throw new Error(`Invalid entity type: ${e.entityType}`);const o={...e.data,folder:e.folder||null},u=await n.create(o);if(!u)throw new Error("Failed to create entity");t==null||t.send({type:"create-result",requestId:e.requestId,uuid:u.uuid,entity:u.toObject()})}catch(n){ModuleLogger.error("Error creating entity:",n),t==null||t.send({type:"create-result",requestId:e.requestId,error:n.message,message:"Failed to create entity"})}}});router$a.addRoute({actionType:"decrease",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received decrease attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const o=[];if(e.selected){const r=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const l of r)l.actor&&o.push(l.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&o.push(r)}if(o.length===0)throw new Error("No entities found to modify");const u=[];for(const r of o){const l=getProperty(r,e.attribute);if(typeof l!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof l}`);const i=l-e.amount,d={};d[e.attribute]=i,await r.update(d),u.push({uuid:r.uuid,attribute:e.attribute,oldValue:l,newValue:i})}t==null||t.send({type:"decrease-result",requestId:e.requestId,results:u,success:!0})}catch(o){ModuleLogger.error("Error decreasing attribute:",o),t==null||t.send({type:"decrease-result",requestId:e.requestId,success:!1,error:o.message})}}});router$a.addRoute({actionType:"increase",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received increase attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const o=[];if(e.selected){const r=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const l of r)l.actor&&o.push(l.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&o.push(r)}if(o.length===0)throw new Error("No entities found to modify");const u=[];for(const r of o){const l=getProperty(r,e.attribute);if(typeof l!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof l}`);const i=l+e.amount,d={};d[e.attribute]=i,await r.update(d),u.push({uuid:r.uuid,attribute:e.attribute,oldValue:l,newValue:i})}t==null||t.send({type:"increase-result",requestId:e.requestId,results:u,success:!0})}catch(o){ModuleLogger.error("Error increasing attribute:",o),t==null||t.send({type:"increase-result",requestId:e.requestId,success:!1,error:o.message})}}});router$a.addRoute({actionType:"update",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received update entity request for UUID: ${e.uuid}`);try{let o=[];if(e.uuid)o.push(await fromUuid(e.uuid));else if(e.selected){const r=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(r)for(let l of r)e.actor?o.push(l.actor):o.push(l.document)}if(o.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let r of o)await(r==null?void 0:r.update(e.data));let u=[];for(let r of o)u.push(await fromUuid(r.uuid));t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,entity:u.map(r=>r==null?void 0:r.toObject())})}catch(o){ModuleLogger.error("Error updating entity:",o),t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,error:o.message,message:"Failed to update entity"})}}});router$a.addRoute({actionType:"delete",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received delete entity request for UUID: ${e.uuid}`);try{let o=[];if(e.uuid)o.push(await fromUuid(e.uuid));else if(e.selected){const u=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(u)for(let r of u)e.actor?o.push(r.actor):o.push(r.document)}if(!o||o.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let u of o)await(u==null?void 0:u.delete());t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,success:!0})}catch(o){ModuleLogger.error("Error deleting entity:",o),t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,error:o.message,message:"Failed to delete entity"})}}});router$a.addRoute({actionType:"kill",handler:async(e,s)=>{var n,o,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received kill request for UUID: ${e.uuid}`);try{const r=[];if(e.uuid){const i=await fromUuid(e.uuid);if(i)r.push(i);else throw new Error(`Entity not found: ${e.uuid}`)}else if(e.selected){const i=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const d of i)d.document&&r.push(d.document)}if(r.length===0)throw new Error("No entities found to mark as defeated");const l=[];for(const i of r){let d=!1,a="";if(i.documentName==="Token"){const c=i,p=c.actor;if(!p)throw new Error("Token has no associated actor");const y=game.combat;if(y){const h=y.combatants.find(f=>{var m,g,w,I;return((m=f.token)==null?void 0:m.id)===c.id&&((w=(g=f.token)==null?void 0:g.parent)==null?void 0:w.id)===((I=c.parent)==null?void 0:I.id)});h&&(await h.update({defeated:!0}),ModuleLogger.info("Marked token as defeated in combat"))}try{hasProperty(p,"system.attributes.hp")?await p.update({"system.attributes.hp.value":0}):hasProperty(p,"system.health")?await p.update({"system.health.value":0}):hasProperty(p,"system.hp")?await p.update({"system.hp.value":0}):hasProperty(p,"data.attributes.hp")&&await p.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(h){ModuleLogger.warn(`Could not set HP to 0: ${h}`)}try{const h=(o=CONFIG.statusEffects)==null?void 0:o.find(f=>f.id==="dead"||f.id==="unconscious"||f.id==="defeated");h?(await c.toggleActiveEffect(h),ModuleLogger.info(`Added ${h.id} status effect to token`)):ModuleLogger.warn("No dead status effect found")}catch(h){ModuleLogger.warn(`Could not apply status effect: ${h}`)}d=!0,a="Token marked as defeated, HP set to 0, and dead effect applied"}else if(i.documentName==="Actor"){const c=i;let p=0;const y=game.scenes;if(y!=null&&y.viewed){const f=y.viewed.tokens.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});for(const m of f)try{const g=(u=CONFIG.statusEffects)==null?void 0:u.find(w=>w.id==="dead"||w.id==="unconscious"||w.id==="defeated");g&&(await m.toggleActiveEffect(g),p++)}catch(g){ModuleLogger.warn(`Could not apply status effect to token: ${g}`)}}const h=game.combat;if(h){const f=h.combatants.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});f.length>0&&(await Promise.all(f.map(m=>m.update({defeated:!0}))),ModuleLogger.info(`Marked ${f.length} combatants as defeated`))}try{hasProperty(c,"system.attributes.hp")?await c.update({"system.attributes.hp.value":0}):hasProperty(c,"system.health")?await c.update({"system.health.value":0}):hasProperty(c,"system.hp")?await c.update({"system.hp.value":0}):hasProperty(c,"data.attributes.hp")&&await c.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(f){ModuleLogger.warn(`Could not set HP to 0: ${f}`)}d=!0,a=`Actor marked as defeated, HP set to 0, and dead effect applied to ${p} tokens`}else throw new Error(`Cannot mark entity type ${i.documentName} as defeated`);l.push({uuid:i.uuid,success:d,message:a})}t==null||t.send({type:"kill-result",requestId:e.requestId,results:l})}catch(r){ModuleLogger.error("Error marking entities as defeated:",r),t==null||t.send({type:"kill-result",requestId:e.requestId,success:!1,error:r.message})}}});router$a.addRoute({actionType:"give",handler:async(e,s)=>{var n,o,u,r;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received give item request from ${e.fromUuid} to ${e.toUuid}`);try{if(!e.toUuid&&!e.selected)throw new Error("Target UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");let l=null;if(e.fromUuid&&(l=await fromUuid(e.fromUuid),(l==null?void 0:l.documentName)!=="Actor"))throw new Error(`Source entity must be an Actor, got ${l==null?void 0:l.documentName}`);e.selected&&(e.toUuid=(u=(o=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled[0])==null?void 0:o.actor)==null?void 0:u.uuid);const i=await fromUuid(e.toUuid);if(!i)throw new Error(`Target entity not found: ${e.toUuid}`);if(i.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${i.documentName}`);let d=null,a=null;if(e.itemUuid)d=await fromUuid(e.itemUuid),d&&(a=d.toObject());else if(e.itemName)if(l)d=l.items.find(m=>m.name.toLowerCase()===e.itemName.toLowerCase()),d&&(a=d.toObject());else{if(!window.QuickInsert)throw new Error("QuickInsert is not available for global item search.");window.QuickInsert.hasIndex||(ModuleLogger.info("QuickInsert index not ready, forcing index creation"),window.QuickInsert.forceIndex(),await new Promise(w=>setTimeout(w,500)));const g=(await window.QuickInsert.search(e.itemName,null,20)).find(w=>{var I;return((I=w.item)==null?void 0:I.documentType)==="Item"});if(g){const w=await g.item.get();w&&(a=w.toObject())}}if(!a)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);if(d&&d.documentName!=="Item")throw new Error(`Entity must be an Item, got ${d.documentName}`);if(d&&l&&((r=d.parent)==null?void 0:r.id)!==l.id)throw new Error(`Item ${e.itemUuid||e.itemName} does not belong to source actor ${e.fromUuid}`);const c=e.quantity||1,p=i.items.find(m=>m.name===a.name),y=p&&hasProperty(p.system,"quantity");if(d&&l){const m=getProperty(d,"system.quantity");typeof m=="number"&&c<m?await d.update({"system.quantity":m-c}):await d.delete()}let h,f;if(y){const m=p.system.quantity+c;await p.update({"system.quantity":m}),h=p.id,f=m}else delete a._id,(hasProperty(a,"system.quantity")||a.system)&&(a.system.quantity=c),f=c,h=(await i.createEmbeddedDocuments("Item",[a]))[0].id;t==null||t.send({type:"give-result",requestId:e.requestId,fromUuid:e.fromUuid,selected:e.selected,toUuid:e.toUuid,quantity:f,itemUuid:e.itemUuid,newItemId:h,success:!0})}catch(l){ModuleLogger.error("Error giving item:",l),t==null||t.send({type:"give-result",requestId:e.requestId,selected:e.selected,fromUuid:e.fromUuid||"",toUuid:e.toUuid||"",quantity:e.quantity,itemUuid:e.itemUuid||"",success:!1,error:l.message})}}});router$a.addRoute({actionType:"remove",handler:async(e,s)=>{var n,o,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove item request from actor: ${e.actorUuid}`);try{if(!e.actorUuid&&!e.selected)throw new Error("Target actor UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");e.selected&&(e.actorUuid=(u=(o=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled[0])==null?void 0:o.actor)==null?void 0:u.uuid);const r=await fromUuid(e.actorUuid);if(!r)throw new Error(`Target actor not found: ${e.actorUuid}`);if(r.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${r.documentName}`);let l=null;if(e.itemUuid?l=await fromUuid(e.itemUuid):e.itemName&&(l=r.items.find(c=>c.name.toLowerCase()===e.itemName.toLowerCase())),!l)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);const i=e.quantity||null,d=getProperty(l,"system.quantity");let a=0;i&&typeof d=="number"&&d>i?(a=d-i,await l.update({"system.quantity":a})):await l.delete(),t==null||t.send({type:"remove-result",requestId:e.requestId,actorUuid:e.actorUuid,itemUuid:l.uuid,quantity:a,success:!0})}catch(r){ModuleLogger.error("Error removing item:",r),t==null||t.send({type:"remove-result",requestId:e.requestId,success:!1,error:r.message})}}});const router$9=new Router("encounterRouter");router$9.addRoute({actionType:"encounters",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for encounters");try{const o=((n=game.combats)==null?void 0:n.contents.map(u=>{var r;return{id:u.id,name:u.name,round:u.round,turn:u.turn,current:u.id===((r=game.combat)==null?void 0:r.id),combatants:u.combatants.contents.map(l=>{var i,d;return{id:l.id,name:l.name,tokenUuid:(i=l.token)==null?void 0:i.uuid,actorUuid:(d=l.actor)==null?void 0:d.uuid,img:l.img,initiative:l.initiative,hidden:l.hidden,defeated:l.isDefeated}})}}))||[];t==null||t.send({type:"encounters-result",requestId:e.requestId,encounters:o})}catch(o){ModuleLogger.error("Error getting encounters list:",o),t==null||t.send({type:"encounters-result",requestId:e.requestId,error:o.message,encounters:[]})}}});router$9.addRoute({actionType:"start-encounter",handler:async(e,s)=>{var n,o,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request to start encounter with options:",e);try{const r=await Combat.create({name:e.name||"New Encounter"});if(r){if(await r.startCombat(),e.tokenUuids&&e.tokenUuids.length>0){const i=[];for(const d of e.tokenUuids)try{const a=await fromUuid(d);a&&i.push({tokenId:a.id??"",sceneId:a.parent.id})}catch(a){ModuleLogger.warn(`Failed to add token ${d} to combat:`,a)}i.length>0&&await r.createEmbeddedDocuments("Combatant",i)}let l=new Set;if(e.startWithPlayers){const i=(n=game.scenes)==null?void 0:n.viewed;if(i){const a=(((o=i.tokens)==null?void 0:o.filter(c=>!!c.actor&&c.actor.hasPlayerOwner))??[]).map(c=>(l.add(c.id),{tokenId:c.id,sceneId:i.id}));a.length>0&&await r.createEmbeddedDocuments("Combatant",a)}}if(e.startWithSelected){const i=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled.filter(d=>!l.has(d.id)).map(d=>({tokenId:d.id,sceneId:d.scene.id})))??[];i.length>0&&await r.createEmbeddedDocuments("Combatant",i)}e.rollNPC&&await r.rollNPC(),e.rollAll&&await r.rollAll(),await r.activate(),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,encounterId:r.id,encounter:{id:r.id,name:r.name,round:r.round,turn:r.turn,combatants:r.combatants.contents.map(i=>{var d,a;return{id:i.id,name:i.name,tokenUuid:(d=i.token)==null?void 0:d.uuid,actorUuid:(a=i.actor)==null?void 0:a.uuid,img:i.img,initiative:i.initiative,hidden:i.hidden,defeated:i.isDefeated}})}})}else throw new Error("Failed to create encounter")}catch(r){ModuleLogger.error("Error starting encounter:",r),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,error:r.message})}}});router$9.addRoute({actionType:"next-turn",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next turn in encounter: ${e.encounterId||"active"}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await i.nextTurn(),t==null||t.send({type:"next-turn-result",requestId:e.requestId,encounterId:i.id,action:"nextTurn",currentTurn:i.turn,currentRound:i.round,actorTurn:(u=(o=i.combatant)==null?void 0:o.actor)==null?void 0:u.uuid,tokenTurn:(l=(r=i.combatant)==null?void 0:r.token)==null?void 0:l.uuid,encounter:{id:i.id,name:i.name,round:i.round,turn:i.turn}})}catch(i){ModuleLogger.error("Error advancing to next turn:",i),t==null||t.send({type:"next-turn-result",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"next-round",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next round in encounter: ${e.encounterId||"active"}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await i.nextRound(),t==null||t.send({type:"next-round-result",requestId:e.requestId,encounterId:i.id,action:"nextRound",currentTurn:i.turn,currentRound:i.round,actorTurn:(u=(o=i.combatant)==null?void 0:o.actor)==null?void 0:u.uuid,tokenTurn:(l=(r=i.combatant)==null?void 0:r.token)==null?void 0:l.uuid,encounter:{id:i.id,name:i.name,round:i.round,turn:i.turn}})}catch(i){ModuleLogger.error("Error advancing to next round:",i),t==null||t.send({type:"next-round-result",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"last-turn",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous turn in encounter: ${e.encounterId||"active"}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await i.previousTurn(),t==null||t.send({type:"last-turn-result",requestId:e.requestId,encounterId:i.id,action:"previousTurn",currentTurn:i.turn,currentRound:i.round,actorTurn:(u=(o=i.combatant)==null?void 0:o.actor)==null?void 0:u.uuid,tokenTurn:(l=(r=i.combatant)==null?void 0:r.token)==null?void 0:l.uuid,encounter:{id:i.id,name:i.name,round:i.round,turn:i.turn}})}catch(i){ModuleLogger.error("Error going back to previous turn:",i),t==null||t.send({type:"last-turn-result",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"last-round",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous round in encounter: ${e.encounterId||"active"}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await i.previousRound(),t==null||t.send({type:"last-round-result",requestId:e.requestId,encounterId:i.id,action:"previousRound",currentTurn:i.turn,currentRound:i.round,actorTurn:(u=(o=i.combatant)==null?void 0:o.actor)==null?void 0:u.uuid,tokenTurn:(l=(r=i.combatant)==null?void 0:r.token)==null?void 0:l.uuid,encounter:{id:i.id,name:i.name,round:i.round,turn:i.turn}})}catch(i){ModuleLogger.error("Error going back to previous round:",i),t==null||t.send({type:"encounter-navigation",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"end-encounter",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to end encounter: ${e.encounterId}`);try{let u=e.encounterId;u||(u=(n=game.combat)==null?void 0:n.id);const r=(o=game.combats)==null?void 0:o.get(u);if(!r)throw new Error("No encounter not found");await r.delete(),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,encounterId:u,message:"Encounter successfully ended"})}catch(u){ModuleLogger.error("Error ending encounter:",u),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,error:u.message})}}});router$9.addRoute({actionType:"add-to-encounter",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received add-to-encounter request for encounter: ${e.encounterId}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const d=[],a=[];if(e.uuids&&Array.isArray(e.uuids))for(const c of e.uuids)try{const p=await fromUuid(c);if(!p){a.push({uuid:c,reason:"Entity not found"});continue}if(p.documentName==="Token"){const y=p,h={tokenId:y.id,sceneId:(o=y.parent)==null?void 0:o.id};await i.createEmbeddedDocuments("Combatant",[h]),d.push(c)}else if(p.documentName==="Actor"){const y=(u=game.scenes)==null?void 0:u.viewed;if(y){const h=(r=y.tokens)==null?void 0:r.find(f=>{var m;return((m=f.actor)==null?void 0:m.id)===p.id});if(h){const f={tokenId:h.id,sceneId:y.id};await i.createEmbeddedDocuments("Combatant",[f]),d.push(c)}else a.push({uuid:c,reason:"No token found for this actor in the current scene"})}else a.push({uuid:c,reason:"No active scene"})}else a.push({uuid:c,reason:"Entity must be a Token or Actor"})}catch(p){a.push({uuid:c,reason:p.message})}if(e.selected===!0){const c=((l=canvas==null?void 0:canvas.tokens)==null?void 0:l.controlled)||[];for(const p of c)try{if(!i.combatants.find(y=>{var h,f,m;return((h=y.token)==null?void 0:h.id)===p.id&&((m=(f=y.combat)==null?void 0:f.scene)==null?void 0:m.id)===p.scene.id})){const y={tokenId:p.id,sceneId:p.scene.id};await i.createEmbeddedDocuments("Combatant",[y]),d.push(p.document.uuid)}}catch(y){a.push({uuid:p.document.uuid,reason:y.message})}}e.rollInitiative===!0&&d.length>0&&i.rollAll(),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,encounterId:i.id,added:d,failed:a})}catch(i){ModuleLogger.error("Error adding to encounter:",i),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"remove-from-encounter",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove-from-encounter request for encounter: ${e.encounterId}`);try{const u=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!u)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const r=[],l=[],i=[];if(e.uuids&&Array.isArray(e.uuids))for(const d of e.uuids)try{const a=await fromUuid(d);if(!a){l.push({uuid:d,reason:"Entity not found"});continue}let c=!1;if(a.documentName==="Token"){const p=u.combatants.find(y=>{var h,f,m,g;return((h=y.token)==null?void 0:h.id)===a.id&&((m=(f=y.combat)==null?void 0:f.scene)==null?void 0:m.id)===((g=a.parent)==null?void 0:g.id)});p&&(i.push(p.id),c=!0)}else if(a.documentName==="Actor"){const p=u.combatants.filter(y=>{var h;return((h=y.actor)==null?void 0:h.id)===a.id});p.length>0&&(i.push(...p.map(y=>y.id)),c=!0)}c?r.push(d):l.push({uuid:d,reason:"No combatant found for this entity"})}catch(a){l.push({uuid:d,reason:a.message})}if(e.selected===!0){const d=((o=canvas==null?void 0:canvas.tokens)==null?void 0:o.controlled)||[];for(const a of d){const c=u.combatants.find(p=>p.tokenId===a.id&&p.sceneId===a.scene.id);c&&(i.push(c.id),r.push(a.document.uuid))}}if(i.length>0){const d=i.filter(a=>a!==null);d.length>0&&await u.deleteEmbeddedDocuments("Combatant",d)}t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,encounterId:u.id,removed:r,failed:l})}catch(u){ModuleLogger.error("Error removing from encounter:",u),t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,error:u.message})}}});const router$8=new Router("rollRouter");router$8.addRoute({actionType:"rolls",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for roll data"),t==null||t.send({type:"rolls-result",requestId:e.requestId,data:recentRolls.slice(0,e.limit||20)})}});router$8.addRoute({actionType:"last-roll",handler:(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for last roll data"),t==null||t.send({type:"last-roll-result",requestId:e.requestId,data:recentRolls.length>0?recentRolls[0]:null})}});router$8.addRoute({actionType:"roll",handler:async(e,s)=>{var n,o,u,r,l;const t=s==null?void 0:s.socketManager;try{const{formula:i,flavor:d,createChatMessage:a,speaker:c,whisper:p,requestId:y}=e;let h,f={},m=p&&p.length>0?CONST.DICE_ROLL_MODES.PRIVATE:CONST.DICE_ROLL_MODES.PUBLIC;if(c)try{const g=await fromUuid(c);if(g){if(g instanceof TokenDocument)f={token:g==null?void 0:g.id,actor:(n=g==null?void 0:g.actor)==null?void 0:n.id,scene:(o=g==null?void 0:g.parent)==null?void 0:o.id,alias:(g==null?void 0:g.name)||((u=g==null?void 0:g.actor)==null?void 0:u.name)};else if(g instanceof Actor){const w=(r=game.scenes)==null?void 0:r.active;if(w){const I=(l=w.tokens)==null?void 0:l.filter(E=>{var v;return((v=E.actor)==null?void 0:v.id)===g.id});if(I&&I.length>0){const E=I[0];f={token:E.id,actor:g.id,scene:w.id,alias:E.name||g.name}}else f={actor:g.id,alias:g.name}}}}}catch(g){ModuleLogger.warn(`Failed to process speaker: ${g}`)}try{const g=new Roll(i);await g.evaluate(),a&&await g.toMessage({speaker:f,flavor:d||"",rollMode:m,whisper:p||[]}),h={id:`manual_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!!a,roll:{formula:i,total:g.total,isCritical:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===g.terms[0].faces)}),isFumble:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===1)}),dice:g.dice.map(w=>({faces:w.faces,results:w.results.map(I=>({result:I.result,active:I.active}))})),timestamp:Date.now()}}}catch(g){ModuleLogger.error(`Error rolling formula: ${g}`),t==null||t.send({type:"roll-result",requestId:y,success:!1,error:`Failed to roll formula: ${g.message}`});return}t==null||t.send({type:"roll-result",requestId:y,success:!0,data:h})}catch(i){ModuleLogger.error(`Error in roll handler: ${i}`),t==null||t.send({type:"roll-result",requestId:e.requestId,success:!1,error:i.message||"Unknown error occurred during roll"})}}});function parseFilterString(e){if(!e.includes(":"))return{documentType:e};const s={},t=e.split(",");for(const n of t)if(n.includes(":")){const[o,u]=n.split(":");o&&u&&(s[o.trim()]=u.trim())}return s}function matchesAllFilters(e,s){var t,n;for(const[o,u]of Object.entries(s)){if(!u)continue;if(o==="resultType"){const l=(n=(t=e.item)==null?void 0:t.constructor)==null?void 0:n.name;if(!l||l.toLowerCase()!==u.toLowerCase())return!1;continue}if(o==="package"&&e.item){const l=e.item.package;if(!l||l.toLowerCase()!==u.toLowerCase()&&`Compendium.${l}`.toLowerCase()!==u.toLowerCase())return!1;continue}if(o==="folder"&&e.item){const l=e.item.folder;if(!l&&u)return!1;if(l){const i=typeof l=="object"?l.id:l;if(u===i||u===`Folder.${i}`||`Folder.${u}`===i)continue;return!1}continue}let r;if(!o.includes(".")&&e.item&&e.item[o]!==void 0)r=e.item[o];else{const l=o.split(".");let i=e;for(const d of l){if(i==null){r=void 0;break}i=i[d]}r=i}if(r===void 0||typeof r=="string"&&r.toLowerCase()!==u.toLowerCase())return!1}return!0}const router$7=new Router("searchRouter");router$7.addRoute({actionType:"search",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received search request:",e);try{if(!window.QuickInsert){ModuleLogger.error("QuickInsert not available"),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert not available",results:[]});return}if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(u=>setTimeout(u,500))}catch(u){ModuleLogger.error("Failed to force QuickInsert index:",u),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert index not ready",results:[]});return}}let n=null;if(e.filter){const u=typeof e.filter=="string"?parseFilterString(e.filter):e.filter;n=r=>matchesAllFilters(r,u)}const o=await window.QuickInsert.search(e.query,n,200);ModuleLogger.info(`Search returned ${o.length} results`),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,filter:e.filter,results:o.map(u=>{var l;const r=u.item;return{documentType:r.documentType,folder:r.folder,id:r.id,name:r.name,package:r.package,packageName:r.packageName,subType:r.subType,uuid:r.uuid,icon:r.icon,journalLink:r.journalLink,tagline:r.tagline||"",formattedMatch:u.formattedMatch||"",resultType:(l=r.constructor)==null?void 0:l.name}})})}catch(n){ModuleLogger.error("Error performing search:",n),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:n.message,results:[]})}}});const router$6=new Router("structureRouter");router$6.addRoute({actionType:"structure",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received structure request with params:",e);try{const u=e.includeEntityData??!1,r=e.path||null,l=e.recursive??!1,i=e.recursiveDepth??5,d=e.type?Array.isArray(e.types)?e.types:[e.types]:["Scene","Actor","Item","JournalEntry","RollTable","Cards","Macro","Playlist"],a={Scene:game.scenes,Actor:game.actors,Item:game.items,JournalEntry:game.journal,RollTable:game.tables,Cards:game.cards,Macro:game.macros,Playlist:game.playlists},c=h=>u?h.toObject(!1):{uuid:h.uuid,name:h.name,id:h.id,type:h.documentName},p=(h,f=0)=>{var I;if(!l||f>=i)return{};const m={},w=(((I=game.folders)==null?void 0:I.contents)||[]).filter(E=>{var v;return((v=E.folder)==null?void 0:v.id)===(h==null?void 0:h.id)&&d.includes(E.type)});for(const E of w){const v=E.name||E.id;m[v]={id:E.id,uuid:E.uuid,type:E.type,...p(E,f+1)};const L=E.contents.filter(R=>d.includes(R.documentName)).map(c);L.length>0&&(m[v].entities=L)}return m};let y={};if(r&&r.startsWith("Compendium.")){const h=game.packs.get(r.replace("Compendium.",""));if(!h)throw new Error(`Compendium not found: ${r}`);const m=(await h.getIndex()).contents.map(g=>u?{...g}:{uuid:g.uuid||`${h.collection}.${g._id}`,name:g.name,id:g._id,type:h.documentName});y={compendium:{name:h.title,type:h.documentName,entities:m}}}else if(r&&r.startsWith("Folder.")){const h=r.match(/Folder\.([a-zA-Z0-9]+)/);if(!h)throw new Error(`Invalid folder path: ${r}`);const f=h[1],m=(n=game.folders)==null?void 0:n.get(f);if(!m)throw new Error(`Folder not found: ${r}`);if(!d.includes(m.type))throw new Error(`Folder type ${m.type} not included in requested types`);y.folders=p(m);const g=m.contents.filter(w=>d.includes(w.documentName)).map(c);g.length>0&&(y.entities=g)}else{if(l)y.folders=p(null);else{const f=((o=game.folders)==null?void 0:o.contents)||[];y.folders={};for(const m of d){const g=f.filter(w=>w.type===m&&!w.folder);for(const w of g){const I=w.name||w.id;if(y.folders[I]={id:w.id,uuid:w.uuid,type:w.type},u||!l){const E=w.contents.filter(v=>d.includes(v.documentName)).map(c);E.length>0&&(y.folders[I].entities=E)}}}}const h={};for(const f of d){const m=a[f];if(m){const g=m.filter(w=>!w.folder).map(c);g.length>0&&(h[f.toLowerCase()+"s"]=g)}}if(Object.keys(h).length>0&&(y.entities=h),!r){const f={};for(const m of game.packs.contents)if(d.includes(m.documentName)){const g=m.title||m.collection;f[g]={id:m.collection,name:m.title,type:m.documentName,uuid:`Compendium.${m.collection}`};try{const I=(await m.getIndex()).contents.map(E=>u?{...E}:{uuid:E.uuid||`${m.collection}.${E._id}`,name:E.name,id:E._id,type:m.documentName});I.length>0&&(f[g].entities=I)}catch(w){ModuleLogger.warn(`Failed to load entities for compendium ${m.collection}:`,w)}}Object.keys(f).length>0&&(y.compendiumPacks=f)}}t==null||t.send({type:"structure-result",requestId:e.requestId,data:y})}catch(u){ModuleLogger.error("Error getting structure:",u),t==null||t.send({type:"structure-result",requestId:e.requestId,error:u.message,data:{}})}}});router$6.addRoute({actionType:"get-folder",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received get-folder request for name: ${e.name}`);try{const r=(((n=game.folders)==null?void 0:n.contents)||[]).find(i=>i.name===e.name);if(!r)throw new Error(`Folder not found with name: ${e.name}`);const l=r.contents.map(i=>({uuid:i.uuid,id:i.id,name:i.name,type:i.documentName,img:"img"in i?i.img:null}));t==null||t.send({type:"get-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((o=r.folder)==null?void 0:o.id)||null,contents:l}})}catch(u){ModuleLogger.error("Error getting folder:",u),t==null||t.send({type:"get-folder-result",requestId:e.requestId,error:u.message,data:null})}}});router$6.addRoute({actionType:"create-folder",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received create-folder request:",e);try{const u={name:e.name,type:e.folderType};if(e.parentFolderId){if(!((n=game.folders)==null?void 0:n.get(e.parentFolderId)))throw new Error(`Parent folder not found with ID: ${e.parentFolderId}`);u.folder=e.parentFolderId}const r=await Folder.create(u);t==null||t.send({type:"create-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((o=r.folder)==null?void 0:o.id)||null}})}catch(u){ModuleLogger.error("Error creating folder:",u),t==null||t.send({type:"create-folder-result",requestId:e.requestId,error:u.message,data:null})}}});router$6.addRoute({actionType:"delete-folder",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received delete-folder request:",e);try{const u=(n=game.folders)==null?void 0:n.get(e.folderId);if(!u)throw new Error(`Folder not found with ID: ${e.folderId}`);const r=e.deleteAll??!1;let l=0,i=0;const d=async a=>{var m;let c=0,p=0;const h=(((m=game.folders)==null?void 0:m.contents)||[]).filter(g=>{var w;return((w=g.folder)==null?void 0:w.id)===a.id});for(const g of h){const w=await d(g);c+=w.entities,p+=w.folders}const f=a.contents;c+=f.length;for(const g of f)await g.delete();return await a.delete(),p+=1,{entities:c,folders:p}};if(r){const a=await d(u);l=a.entities,i=a.folders}else{const c=(((o=game.folders)==null?void 0:o.contents)||[]).filter(p=>{var y;return((y=p.folder)==null?void 0:y.id)===u.id});if(u.contents.length>0)throw new Error(`Folder contains ${u.contents.length} entities. Use deleteAll=true to delete them or move them first.`);if(c.length>0)throw new Error(`Folder contains ${c.length} child folders. Use deleteAll=true to delete them or move them first.`);await u.delete(),i=1}t==null||t.send({type:"delete-folder-result",requestId:e.requestId,data:{deleted:!0,folderId:e.folderId,entitiesDeleted:l,foldersDeleted:i}})}catch(u){ModuleLogger.error("Error deleting folder:",u),t==null||t.send({type:"delete-folder-result",requestId:e.requestId,error:u.message,data:null})}}});router$6.addRoute({actionType:"contents",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received contents request for path: ${e.path}`);try{let o=[];if(e.path.startsWith("Compendium.")){const u=game.packs.get(e.path.replace("Compendium.",""));if(!u)throw new Error(`Compendium not found: ${e.path}`);o=(await u.getIndex()).contents.map(l=>({...l}))}else{const u=e.path.match(/Folder\.([a-zA-Z0-9]+)/);if(!u)throw new Error(`Invalid folder path: ${e.path}`);const r=u[1],l=(n=game.folders)==null?void 0:n.get(r);if(!l)throw new Error(`Folder not found: ${e.path}`);o=l.contents.map(i=>({uuid:i.uuid,id:i.id,name:i.name,img:"img"in i?i.img:null,type:i.documentName}))}t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,entities:o})}catch(o){ModuleLogger.error("Error getting contents:",o),t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,error:o.message,entities:[]})}}});function getFoundryVersion(){return game.version}function getFoundryVersionMajor(){return parseInt(getFoundryVersion().split(".")[0],10)}const router$5=new Router("sheetRouter");router$5.addRoute({actionType:"get-sheet",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;if(ModuleLogger.info(`Received sheet request for UUID: ${e.uuid}`),getFoundryVersionMajor()>12){ModuleLogger.error(`Foundry version ${getFoundryVersionMajor()} does not support this endpoint`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"This endpoint is only supported in Foundry VTT version 12"}});return}try{let u=null;if(e.uuid)u=await fromUuid(e.uuid);else if(e.selected){const l=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;l&&l.length>0&&(e.actor?u=l[0].actor:u=l[0].document)}if(!u){ModuleLogger.error(`Entity not found for UUID: ${e.uuid}`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Entity not found",uuid:e.uuid}});return}const r=(o=u.sheet)==null?void 0:o.render(!0);setTimeout(async()=>{try{let l=function(T){T.classList&&T.classList.length&&T.classList.forEach(b=>h.add(b)),T.id&&f.add(T.id);for(let b=0;b<T.children.length;b++)l(T.children[b])};if(!r.element||!r.element[0])throw new Error("Failed to render actor sheet");let i=r.element[0].outerHTML,d="";const a=String(r.appId);document.querySelectorAll("style[data-appid]").forEach(T=>{T.dataset.appid===a&&(d+=T.textContent+`
`)}),document.querySelectorAll(`style[id^="system-${u.type}"]`).forEach(T=>{d+=T.textContent+`
`});const y=document.createElement("div");y.innerHTML=i;const h=new Set,f=new Set;l(y);const m=Array.from(h),g=Array.from(f);ModuleLogger.debug(`Extracted ${m.length} unique classes and ${g.length} unique IDs`);const w=document.querySelectorAll("style"),I=document.querySelectorAll('link[rel="stylesheet"]');w.forEach(T=>{if(T.dataset.appid&&T.dataset.appid===a)return;const b=T.textContent||"";(m.some(q=>b.includes(`.${q}`))||g.some(q=>b.includes(`#${q}`))||b.includes(".window-app")||b.includes(".sheet")||b.includes(".actor-sheet")||b.includes(`.${u.type}-sheet`))&&(ModuleLogger.debug("Adding relevant inline style"),d+=b+`
`)});const E=Array.from(I).map(async T=>{try{const b=T.getAttribute("href");if(!b||b.includes("fonts.googleapis.com"))return"";ModuleLogger.debug(`Fetching external CSS from: ${b}`);const k=b.startsWith("http")?b:b.startsWith("/")?`${window.location.origin}${b}`:`${window.location.origin}/${b}`,q=await fetch(k);return q.ok?await q.text():(ModuleLogger.warn(`Failed to fetch CSS: ${k}, status: ${q.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch external CSS: ${b}`),""}}),v=window.location.origin;ModuleLogger.debug(`Base URL for fetching CSS: ${v}`);const L=[`${v}/css/style.css`,`${v}/styles/style.css`,`${v}/styles/foundry.css`,`${v}/ui/sheets.css`,`${v}/game/styles/foundry.css`,`${v}/game/ui/sheets.css`,`${v}/systems/${game.system.id}/system.css`,`${v}/systems/${game.system.id}/styles/system.css`,`${v}/game/systems/${game.system.id}/system.css`,`${v}/game/systems/${game.system.id}/styles/system.css`];ModuleLogger.debug("All stylesheet links in document:",Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(Boolean));const R=Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(T=>T!==null&&!T.includes("fonts.googleapis.com")&&!T.includes("//"));L.push(...R),ModuleLogger.debug("All style elements in document:",document.querySelectorAll("style").length);const C=L.map(async T=>{try{ModuleLogger.debug(`Fetching core CSS from: ${T}`);const b=await fetch(T);return b.ok?(ModuleLogger.info(`Successfully loaded CSS from: ${T}`),await b.text()):(ModuleLogger.warn(`Failed to fetch CSS: ${T}, status: ${b.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch core CSS: ${b}`),""}}),N=[...E,...C];(await Promise.all(N)).forEach(T=>{d+=T+`
`}),d.length<100&&(ModuleLogger.warn("CSS fetch failed or returned minimal content. Adding fallback styles."),d+=`
              .window-app {
                font-family: "Signika", sans-serif;
                background: #f0f0e0;
                border-radius: 5px;
                box-shadow: 0 0 20px #000;
                color: #191813;
              }
              .window-content {
                background: rgba(255, 255, 240, 0.9);
                padding: 8px;
                overflow-y: auto;
                background: url(${window.location.origin}/ui/parchment.jpg) repeat;
              }
              input, select, textarea {
                border: 1px solid #7a7971;
                background: rgba(255, 255, 255, 0.8);
              }
              button {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid #7a7971;
                border-radius: 3px;
                cursor: pointer;
              }
              .profile-img {
                border: none;
                max-width: 100%;
                max-height: 220px;
              }
            `),ModuleLogger.debug(`Collected CSS: ${d.length} bytes`),i=i.replace(/src="([^"]+)"/g,(T,b)=>b.startsWith("http")?T:b.startsWith("/")?`src="${window.location.origin}${b}"`:`src="${window.location.origin}/${b}"`),d=d.replace(/url\(['"]?([^'")]+)['"]?\)/g,(T,b)=>b.startsWith("http")||b.startsWith("data:")?T:b.startsWith("/")?`url('${window.location.origin}${b}')`:`url('${window.location.origin}/${b}')`),r.close(),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{html:i,css:d,uuid:e.uuid}}),ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${e.requestId}`),ModuleLogger.debug(`HTML length: ${i.length}, CSS length: ${d.length}`)}catch(l){ModuleLogger.error("Error capturing actor sheet HTML:",l),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to capture actor sheet HTML",uuid:e.uuid}}),r&&typeof r.close=="function"&&r.close()}},500)}catch(u){ModuleLogger.error("Error rendering actor sheet:",u),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to render actor sheet",uuid:e.uuid}})}}});const router$4=new Router("macroRouter");router$4.addRoute({actionType:"macros",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for macros");try{const o=((n=game.macros)==null?void 0:n.contents.map(u=>{var r,l;return{uuid:u.uuid,id:u.id,name:u.name,type:u.type||((r=u.data)==null?void 0:r.type)||"unknown",author:((l=u.author)==null?void 0:l.name)||"unknown",command:u.command||"",img:u.img,scope:u.scope,canExecute:u.canExecute}}))||[];t==null||t.send({type:"macros-result",requestId:e.requestId,macros:o})}catch(o){ModuleLogger.error("Error getting macros list:",o),t==null||t.send({type:"macros-result",requestId:e.requestId,error:o.message,macros:[]})}}});router$4.addRoute({actionType:"macro-execute",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to execute macro: ${e.uuid}`);try{if(!e.uuid)throw new Error("Macro UUID is required");const n=await fromUuid(e.uuid);if(!n)throw new Error(`Macro not found with UUID: ${e.uuid}`);if(!(n instanceof CONFIG.Macro.documentClass))throw new Error(`Entity with UUID ${e.uuid} is not a macro`);if(!n.canExecute)throw new Error(`Macro '${n.name}' cannot be executed by the current user`);const o=e.args||{};let u;typeof o=="object"?u=await n.execute({args:o}):u=await n.execute(),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid,success:!0,result:typeof u=="object"?u:{value:u}})}catch(n){ModuleLogger.error("Error executing macro:",n),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid||"",success:!1,error:n.message})}}});const router$3=new Router("utilityRouter");router$3.addRoute({actionType:"execute-js",handler:async(data,context)=>{const socketManager=context==null?void 0:context.socketManager;ModuleLogger.info("Received execute-js request:",data);try{const{script,requestId}=data;if(!script||typeof script!="string")throw new Error("Invalid script provided");let result;try{result=await(async()=>eval(`(async () => { ${script} })()`))()}catch(e){const s=e instanceof Error?e.message:String(e);throw new Error(`Error executing script: ${s}`)}socketManager==null||socketManager.send({type:"execute-js-result",requestId,success:!0,result})}catch(e){ModuleLogger.error("Error in execute-js handler:",e),socketManager==null||socketManager.send({type:"execute-js-result",requestId:data.requestId,success:!1,error:e.message})}}});router$3.addRoute({actionType:"select",handler:async(e,s)=>{var n,o,u,r,l,i,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received select entities request:",e);try{const a=(n=game.scenes)==null?void 0:n.active;if(!a)throw new Error("No active scene found");e.overwrite&&((o=canvas==null?void 0:canvas.tokens)==null||o.releaseAll());const c=new Set;e.all&&(((u=a.tokens)==null?void 0:u.contents)||[]).forEach(f=>c.add(f)),e.uuids&&Array.isArray(e.uuids)&&(((r=a.tokens)==null?void 0:r.filter(f=>e.uuids.includes(f.uuid)))||[]).forEach(f=>c.add(f)),e.name&&(((l=a.tokens)==null?void 0:l.filter(f=>{var m,g;return((m=f.name)==null?void 0:m.toLowerCase())===((g=e.name)==null?void 0:g.toLowerCase())}))||[]).forEach(f=>c.add(f)),e.data&&(((i=a.tokens)==null?void 0:i.filter(f=>Object.entries(e.data).every(([m,g])=>{if(m.startsWith("actor.")&&f.actor){const I=m.replace("actor.","");return getProperty(f.actor,I)===g}const w=f.toObject();return getProperty(w,m)===g})))||[]).forEach(f=>c.add(f));const p=Array.from(c);if(p.length===0)throw new Error("No matching entities found");for(const h of p){const f=h.id?(d=canvas==null?void 0:canvas.tokens)==null?void 0:d.get(h.id):null;f&&f.control({releaseOthers:!1})}const y=p.map(h=>h.uuid);t==null||t.send({type:"select-result",requestId:e.requestId,success:!0,count:p.length,message:`${p.length} entities selected`,selected:y})}catch(a){ModuleLogger.error("Error selecting entities:",a),t==null||t.send({type:"select-result",requestId:e.requestId,success:!1,error:a.message})}}});router$3.addRoute({actionType:"selected",handler:async(e,s)=>{var n,o;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get selected entities request:",e);try{if(!((n=game.scenes)==null?void 0:n.active))throw new Error("No active scene found");const l=(((o=canvas==null?void 0:canvas.tokens)==null?void 0:o.controlled)||[]).map(i=>{var d;return{tokenUuid:i.document.uuid,actorUuid:((d=i.actor)==null?void 0:d.uuid)||null}});t==null||t.send({type:"selected-result",requestId:e.requestId,success:!0,selected:l})}catch(u){ModuleLogger.error("Error getting selected entities:",u),t==null||t.send({type:"selected-result",requestId:e.requestId,success:!1,error:u.message})}}});const router$2=new Router("fileSystemRouter");router$2.addRoute({actionType:"file-system",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get file system request:",e);try{const n=e.path||"",o=e.source||"data",u=!!e.recursive,r=await FilePicker.browse(o,n),l=Array.isArray(r.dirs)?r.dirs.map(c=>({name:c.split("/").pop()||c,path:c,type:"directory"})):[],i=Array.isArray(r.files)?r.files.map(c=>({name:c.split("/").pop()||c,path:c,type:"file"})):[];let d=[];if(u&&l.length>0)for(const c of l)try{const p=await FilePicker.browse(o,c.path),y=Array.isArray(p.dirs)?p.dirs.map(f=>({name:f.split("/").pop()||f,path:f,type:"directory"})):[],h=Array.isArray(p.files)?p.files.map(f=>({name:f.split("/").pop()||f,path:f,type:"file"})):[];if(d=d.concat(y,h),u===!0&&y.length>0&&c.path.split("/").length<3)for(const f of y)try{const m=await FilePicker.browse(o,f.path),g=Array.isArray(m.dirs)?m.dirs.map(I=>({name:I.split("/").pop()||I,path:I,type:"directory"})):[],w=Array.isArray(m.files)?m.files.map(I=>({name:I.split("/").pop()||I,path:I,type:"file"})):[];d=d.concat(g,w)}catch(m){ModuleLogger.error(`Error processing deep subdirectory ${f.path}:`,m)}}catch(p){ModuleLogger.error(`Error processing subdirectory ${c.path}:`,p)}const a=[...l,...i];u&&a.push(...d),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!0,path:n,source:o,results:a,recursive:u})}catch(n){ModuleLogger.error("Error getting file system:",n),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!1,error:n.message})}}});router$2.addRoute({actionType:"upload-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received upload file request:",e);try{const{path:n,filename:o,source:u,fileData:r,mimeType:l,binaryData:i,overwrite:d}=e;if(!n||!o)throw new Error("Missing required parameters (path, filename)");let a;if(i){if(!Array.isArray(i)||i.length===0)throw new Error("Invalid binary data: must be non-empty array");const f=new Uint8Array(i),m=new Blob([f],{type:l||"application/octet-stream"});a=new File([m],o,{type:l||"application/octet-stream"}),ModuleLogger.info(`Created file from binary data: ${f.length} bytes`)}else if(r){if(!r.includes(",")||!r.startsWith("data:"))throw new Error("Invalid file data format: must be data URL with base64 content");const f=r.split(",")[1];if(!f)throw new Error("No base64 data found in file data");let m;try{m=atob(f)}catch(I){throw new Error(`Invalid base64 data: ${I.message}`)}if(m.length===0)throw new Error("Decoded file data is empty");const g=new Uint8Array(m.length);for(let I=0;I<m.length;I++)g[I]=m.charCodeAt(I);const w=new Blob([g],{type:l||"application/octet-stream"});a=new File([w],o,{type:l||"application/octet-stream"}),ModuleLogger.info(`Created file from base64 data: ${g.length} bytes`)}else throw new Error("Missing file data (either binaryData or fileData is required)");const c=u||"data";if(n&&n!=="/"&&n!=="")try{const f=n.split("/").filter(g=>g.length>0);let m="";for(const g of f){m=m?`${m}/${g}`:g;try{await FilePicker.createDirectory(c,m),ModuleLogger.info(`Created/verified directory: ${m}`)}catch(w){const I=w.message||String(w);if(!I.includes("already exists"))throw ModuleLogger.error(`Error creating directory ${m}:`,w),new Error(`Could not create directory '${m}': ${I}`)}}}catch(f){throw ModuleLogger.error(`Error creating directories for path '${n}':`,f),new Error(`Could not create directory structure: ${f.message}`)}let p=null;try{const f=n&&n!=="/"?`${n}/${o}`:o;p=await FilePicker.browse(c,f)}catch{}if(p&&!d)throw new Error("File already exists. Set overwrite to true to replace it.");const y=await FilePicker.upload(c,n,a);if(!y)throw new Error("FilePicker.upload returned null/undefined result");const h=y&&typeof y=="object"&&"path"in y?y.path:`${n}/${o}`;ModuleLogger.info(`File uploaded successfully: ${h}`),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!0,path:h})}catch(n){ModuleLogger.error("Error uploading file:",n),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!1,error:n.message})}}});router$2.addRoute({actionType:"download-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received download file request:",e);try{const{path:n}=e;if(!n)throw new Error("Missing required parameter (path)");const o=await fetch(n.startsWith("http")?n:foundry.utils.getRoute(n));if(!o.ok)throw new Error(`Failed to download file: ${o.status} ${o.statusText}`);const u=await o.blob(),r=new FileReader,l=await new Promise((i,d)=>{r.onload=()=>i(r.result),r.onerror=d,r.readAsDataURL(u)});t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!0,path:n,fileData:l,filename:n.split("/").pop()||"file",mimeType:u.type})}catch(n){ModuleLogger.error("Error downloading file:",n),t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!1,error:n.message})}}});const router$1=new Router("dnd5eRouter");Hooks.once("init",()=>{if(game.system.id==="dnd5e"){router$1.addRoute({actionType:"get-actor-details",handler:async(t,n)=>{const o=n==null?void 0:n.socketManager;ModuleLogger.info("Received get-actor-details request:",t);try{const{actorUuid:u,details:r}=t;if(!u)throw new Error("actorUuid is required");if(!r||!Array.isArray(r)||r.length===0)throw new Error("details array is required and cannot be empty");const l=await fromUuid(u);if(!l)throw new Error(`Actor not found with UUID: ${u}`);const i={uuid:u};r.includes("resources")&&(i.resources=l.system.resources),r.includes("spells")&&(i.spells=l.items.filter(d=>d.type==="spell")),r.includes("items")&&(i.items=l.items.filter(d=>["weapon","equipment","consumable","tool","loot","backpack"].includes(d.type))),r.includes("features")&&(i.features=l.items.filter(d=>["feat","background","class"].includes(d.type))),o==null||o.send({type:"get-actor-details-result",requestId:t.requestId,data:i})}catch(u){ModuleLogger.error("Error in get-actor-details:",u),o==null||o.send({type:"get-actor-details-result",requestId:t.requestId,error:u.message})}}}),router$1.addRoute({actionType:"modify-item-charges",handler:async(t,n)=>{const o=n==null?void 0:n.socketManager;ModuleLogger.info("Received modify-item-charges request:",t);try{const{actorUuid:u,itemUuid:r,itemName:l,amount:i}=t;if(!u)throw new Error("actorUuid is required");if(!r&&!l)throw new Error("itemUuid or itemName is required");if(typeof i!="number")throw new Error("amount must be a number");const d=await fromUuid(u);if(!d)throw new Error(`Actor not found with UUID: ${u}`);let a=null;if(r?a=d.items.get(r.split(".").pop()):l&&(a=d.items.find(w=>w.name.toLowerCase()===l.toLowerCase())),!a)throw new Error(`Item not found on actor ${d.name}`);const c=a.system.uses||{},p=c.spent||0,y=c.value??c.max??0,h=c.max||0,f=Math.max(0,Math.min(h,p-i)),m=Math.max(0,Math.min(h,y+i)),g={system:{...a.system,uses:{...a.system.uses,spent:f,value:m}}};await a.update(g),o==null||o.send({type:"modify-item-charges-result",requestId:t.requestId,data:{itemUuid:a.uuid,oldCharges:y,newCharges:m}})}catch(u){ModuleLogger.error("Error in modify-item-charges:",u),o==null||o.send({type:"modify-item-charges-result",requestId:t.requestId,error:u.message})}}});const s=async(t,n,o)=>{var l,i,d;const u=n==null?void 0:n.socketManager,r=o?`use-${o}`:"use-ability";ModuleLogger.info(`Received ${r} request:`,t);try{const{actorUuid:a,abilityUuid:c,abilityName:p,targetUuid:y}=t;if(!a)throw new Error("actorUuid is required");if(!c&&!p)throw new Error("abilityUuid or abilityName is required");const h=await fromUuid(a);if(!h)throw new Error(`Actor not found with UUID: ${a}`);let f=null;if(c?f=await fromUuid(c):p&&(f=h.items.find(I=>I.name.toLowerCase()===p.toLowerCase()?o?o==="item"?I.type!=="feat"&&I.type!=="spell":I.type===o:!0:!1)),!f)throw new Error(`Ability not found on actor ${h.name}`);let m=null;if(y){const w=await fromUuid(y);if(w&&w.documentName==="Token")m=w;else if(w&&w.documentName==="Actor"){const I=(l=game.scenes)==null?void 0:l.active;if(I){const E=(i=I.tokens)==null?void 0:i.filter(v=>{var L;return((L=v.actor)==null?void 0:L.id)===w.id});E&&E.length>0&&(m=E[0])}}if(m&&(canvas!=null&&canvas.tokens)){(d=game.user)==null||d.targets.forEach(E=>E.setTarget(!1,{releaseOthers:!1}));const I=canvas.tokens.get(m.id);I&&I.setTarget(!0,{releaseOthers:!0})}}const g=await f.use();u==null||u.send({type:`${r}-result`,requestId:t.requestId,data:{uuid:a,ability:f.name,result:g?g.id:null}})}catch(a){ModuleLogger.error(`Error in ${r}:`,a),u==null||u.send({type:`${r}-result`,requestId:t.requestId,error:a.message})}};router$1.addRoute({actionType:"use-ability",handler:(t,n)=>s(t,n,null)}),router$1.addRoute({actionType:"use-feature",handler:(t,n)=>s(t,n,"feat")}),router$1.addRoute({actionType:"use-spell",handler:(t,n)=>s(t,n,"spell")}),router$1.addRoute({actionType:"use-item",handler:(t,n)=>s(t,n,"item")}),router$1.addRoute({actionType:"modify-experience",handler:async(t,n)=>{var u;const o=n==null?void 0:n.socketManager;ModuleLogger.info("Received modify-experience request:",t);try{const{actorUuid:r,selected:l,amount:i}=t;if(!r&&!l)throw new Error("Either actorUuid or selected must be provided");if(typeof i!="number")throw new Error("amount must be a number");let d=null;if(r)d=await fromUuid(r);else if(l){const p=(u=canvas.tokens)==null?void 0:u.controlled;if(!p||p.length===0)throw new Error("No token selected");p.length>1&&ModuleLogger.warn("Multiple tokens selected, using the first one."),d=p[0].actor}if(!d)throw new Error("Actor not found");const a=d.system.details.xp.value,c=a+i;await d.update({"system.details.xp.value":c}),o==null||o.send({type:"modify-experience-result",requestId:t.requestId,data:{actorUuid:d.uuid,oldXp:a,newXp:c}})}catch(r){ModuleLogger.error("Error in modify-experience:",r),o==null||o.send({type:"modify-experience-result",requestId:t.requestId,error:r.message})}}})}});function mapToFoundryMessageType(e){return["base","ic","ooc","roll","emote","other","player-chat"].includes(e)?e:{"gm-message":"base",gm:"base",dm:"base","player-chat":"base",whisper:"ic",blind:"base",private:"ic"}[e]||"base"}function refreshChatData(){var e;try{const s=((e=game.messages)==null?void 0:e.contents)||[];window.recentChatMessages||(window.recentChatMessages=[]),window.recentChatMessages.length=0,s.forEach(n=>{var o,u;if(!n.isRoll){const r={id:n.id,messageId:n.id,user:{id:(o=n.user)==null?void 0:o.id,name:(u=n.user)==null?void 0:u.name},content:n.content,flavor:n.flavor||"",type:mapToFoundryMessageType(n.type)||"player-chat",timestamp:n.timestamp||Date.now(),speaker:n.speaker,whisper:n.whisper||[],blind:n.blind||!1};window.recentChatMessages.unshift(r)}});const t=100;window.recentChatMessages.length>t&&(window.recentChatMessages.length=t),ModuleLogger.debug(`Refreshed chat messages: ${window.recentChatMessages.length} messages`)}catch(s){ModuleLogger.error("Error refreshing chat messages:",s)}}const router=new Router("chatRouter");router.addRoute({actionType:"chat",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received incoming chat message from relay server:",e);try{const n=e.message||e;if(!n||!n.message){ModuleLogger.warn("Invalid chat message format - missing message content");return}const o={content:n.message,speaker:{alias:n.speaker||"The Gold Box AI"},type:mapToFoundryMessageType(n.type)||"ic",flavor:n.flavor||""};await ChatMessage.create(o),ModuleLogger.info(`Successfully created chat message from relay server: ${n.message.substring(0,50)}...`),t==null||t.send({type:"chat-result",requestId:e.requestId,success:!0,message:"Chat message delivered successfully"})}catch(n){ModuleLogger.error("Error processing incoming chat message:",n),t==null||t.send({type:"chat-result",requestId:e.requestId,success:!1,error:n instanceof Error?n.message:String(n)})}}});router.addRoute({actionType:"chat-messages",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for chat messages:",e);try{const n=e.limit||50,o=e.sort||"timestamp",u=e.order||"desc",r=e.refresh||!1,l=game.modules.get(moduleId);let i=[];l&&l.api&&l.api.getChatMessages?i=[...l.api.getChatMessages()]:ModuleLogger.warn("Module API or getChatMessages method not available"),r&&(ModuleLogger.info(`Refreshing chat data before returning messages. Current count: ${i.length}, refresh flag: ${r}`),refreshChatData(),l&&l.api&&l.api.getChatMessages&&(i=[...l.api.getChatMessages()]),ModuleLogger.info(`After refresh - new message count: ${i.length}`)),o==="timestamp"&&i.sort((a,c)=>u==="desc"?c.timestamp-a.timestamp:a.timestamp-c.timestamp);const d=i.slice(0,n);ModuleLogger.info(`Returning ${d.length} chat messages`),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,messages:d,total:i.length})}catch(n){ModuleLogger.error("Error processing chat messages request:",n),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,error:n instanceof Error?n.message:String(n),messages:[]})}}});const routers=[router$b,router$a,router$9,router,router$8,router$7,router$6,router$5,router$4,router$3,router$2,router$1];function initializeWebSocket(){const e=game.settings.get(moduleId,"wsRelayUrl"),s=game.settings.get(moduleId,"apiKey"),t=game.modules.get(moduleId);if(!e){ModuleLogger.error("WebSocket relay URL is empty. Please configure it in module settings.");return}ModuleLogger.info(`Initializing WebSocket with URL: ${e}`);try{if(t.socketManager?ModuleLogger.info("WebSocket manager already exists, not creating a new one"):(t.socketManager=WebSocketManager.getInstance(e,s),t.socketManager&&t.socketManager.connect()),!t.socketManager){ModuleLogger.warn("No WebSocket manager available, skipping message handler setup");return}const n=t.socketManager;routers.forEach(o=>{o.reflect(n)}),ModuleLogger.info(`Registered ${routers.length} routers with WebSocket manager`)}catch(n){ModuleLogger.error("Error initializing WebSocket:",n)}}Hooks.once("init",()=>{console.log(`Initializing ${moduleId}`);for(let[s,t]of Object.entries(SETTINGS.GET_DEFAULT()))game.settings.register(CONSTANTS.MODULE_ID,s,t);const e=game.modules.get(moduleId);e.api={getWebSocketManager:()=>e.socketManager?e.socketManager:(ModuleLogger.warn("WebSocketManager requested but not initialized"),null),search:async(s,t)=>{if(!window.QuickInsert)return ModuleLogger.error("QuickInsert not available"),[];if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(o=>setTimeout(o,500))}catch(o){ModuleLogger.error("Failed to force QuickInsert index:",o)}}let n=null;return t&&(n=o=>o.documentType===t),window.QuickInsert.search(s,n,100)},getByUuid:async s=>{try{return await fromUuid(s)}catch(t){return ModuleLogger.error("Error getting entity by UUID:",t),null}},getChatMessages:(s=50)=>{var t;return ModuleLogger.info(`getChatMessages called with limit: ${s}`),((t=window.recentChatMessages)==null?void 0:t.slice(0,s))||[]}}});Hooks.on("renderSettingsConfig",(e,s)=>{const t=s instanceof HTMLElement?$(s):s,n=t.find(`input[name="${moduleId}.apiKey"]`);if(n.length){n.attr("type","password");const u=$('<button type="button" style="margin-left: 10px;"><i class="fas fa-info-circle"></i> Show Client Info</button>');n.after(u),u.on("click",()=>{const l=game.modules.get(moduleId).api.getWebSocketManager();if(l){const i=l.getClientId(),d=game.world.id,a=game.world.title,c=game.version,p=game.system.id,y=game.system.title||game.system.id,h=game.system.version||"unknown",f=game.settings.get(moduleId,"customName");new Dialog({title:"Client Information",content:`
            <div class="form-group">
                <label>Client ID</label>
                <div class="form-fields">
                    <input type="text" value="${i}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World ID</label>
                <div class="form-fields">
                    <input type="text" value="${d}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World Title</label>
                <div class="form-fields">
                    <input type="text" value="${a}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Foundry Version</label>
                <div class="form-fields">
                    <input type="text" value="${c}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System ID</label>
                <div class="form-fields">
                    <input type="text" value="${p}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Title</label>
                <div class="form-fields">
                    <input type="text" value="${y}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Version</label>
                <div class="form-fields">
                    <input type="text" value="${h}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Custom Name</label>
                <div class="form-fields">
                    <input type="text" value="${f}" readonly>
                </div>
            </div>
            <p class="notes">Click any field to copy its value.</p>
          `,buttons:{ok:{label:"OK"}},render:m=>{const w=(m instanceof HTMLElement?$(m):m).find('input[type="text"]');w.css("cursor","pointer"),w.on("click",I=>{const E=I.currentTarget;navigator.clipboard.writeText(E.value).then(()=>{ui.notifications.info("Copied to clipboard."),E.select()})})}}).render(!0)}else ui.notifications.warn("WebSocketManager is not available.")}),n.on("change",r=>{const l=r.target.value;game.settings.set(moduleId,"apiKey",l).then(()=>{new Dialog({title:"Reload Required",content:"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})}const o=t.find(`input[name="${moduleId}.customName"]`);o.length&&o.on("change",u=>{const r=u.target.value;game.settings.set(moduleId,"customName",r).then(()=>{new Dialog({title:"Reload Required",content:"<p>The Custom Name has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})});Hooks.once("ready",()=>{var e;window.recentChatMessages||(window.recentChatMessages=[]);try{const s=((e=game.messages)==null?void 0:e.contents)||[];ModuleLogger.info(`Found ${s.length} existing chat messages to populate recentChatMessages and recentRolls`),s.forEach(o=>{var u,r,l,i,d,a,c;if(o.isRoll){if(o.isRoll&&((l=o.rolls)==null?void 0:l.length)>0){const p=o.id,y={id:p,messageId:o.id,user:{id:(i=o.user)==null?void 0:i.id,name:(d=o.user)==null?void 0:d.name},speaker:o.speaker,flavor:o.flavor||"",rollTotal:o.rolls[0].total,formula:o.rolls[0].formula,isCritical:o.rolls[0].isCritical||!1,isFumble:o.rolls[0].isFumble||!1,dice:(a=o.rolls[0].dice)==null?void 0:a.map(f=>({faces:f.faces,results:f.results.map(m=>({result:m.result,active:m.active}))})),timestamp:o.timestamp||Date.now()},h=recentRolls.findIndex(f=>f.id===p);h!==-1?recentRolls[h]=y:recentRolls.unshift(y),ModuleLogger.debug(`Populated historical roll: ${y.formula} = ${y.rollTotal} from ${(c=y.user)==null?void 0:c.name}`)}}else{const p={id:o.id,messageId:o.id,user:{id:(u=o.user)==null?void 0:u.id,name:(r=o.user)==null?void 0:r.name},content:o.content,flavor:o.flavor||"",type:o.type||"player-chat",timestamp:o.timestamp||Date.now(),speaker:o.speaker,whisper:o.whisper||[],blind:o.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const y=window.recentChatMessages.findIndex(h=>h.id===o.id);y!==-1?window.recentChatMessages[y]=p:window.recentChatMessages.unshift(p)}});const t=100;window.recentChatMessages.length>t&&(window.recentChatMessages.length=t);const n=game.settings.get(moduleId,SETTINGS.MAX_ROLLS_STORED);recentRolls.length>n&&(recentRolls.length=n),ModuleLogger.info(`Populated recentChatMessages with ${window.recentChatMessages.length} messages from existing chat log`),ModuleLogger.info(`Populated recentRolls with ${recentRolls.length} rolls from existing chat log`)}catch(s){ModuleLogger.error("Error populating chat messages and rolls from existing log:",s)}setTimeout(()=>{initializeWebSocket()},1e3)});Hooks.on("createChatMessage",e=>{var s,t,n,o,u,r,l,i,d;if(!e.isRoll){ModuleLogger.info(`Collecting chat message from ${((s=e.user)==null?void 0:s.name)||"unknown"}`);const a={id:e.id,messageId:e.id,user:{id:(t=e.user)==null?void 0:t.id,name:(n=e.user)==null?void 0:n.name},content:e.content,flavor:e.flavor||"",type:e.type||"player-chat",timestamp:Date.now(),speaker:e.speaker,whisper:e.whisper||[],blind:e.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const c=window.recentChatMessages.findIndex(y=>y.id===e.id);c!==-1?window.recentChatMessages[c]=a:window.recentChatMessages.unshift(a);const p=100;window.recentChatMessages.length>p&&(window.recentChatMessages.length=p)}if(e.isRoll&&((o=e.rolls)==null?void 0:o.length)>0){ModuleLogger.info(`Detected dice roll from ${((u=e.user)==null?void 0:u.name)||"unknown"}`);const a=e.id,c={id:a,messageId:e.id,user:{id:(r=e.user)==null?void 0:r.id,name:(l=e.user)==null?void 0:l.name},speaker:e.speaker,flavor:e.flavor||"",rollTotal:e.rolls[0].total,formula:e.rolls[0].formula,isCritical:e.rolls[0].isCritical||!1,isFumble:e.rolls[0].isFumble||!1,dice:(i=e.rolls[0].dice)==null?void 0:i.map(h=>({faces:h.faces,results:h.results.map(f=>({result:f.result,active:f.active}))})),timestamp:Date.now()},p=recentRolls.findIndex(h=>h.id===a);if(p!==-1)recentRolls[p]=c;else{recentRolls.unshift(c);const h=game.settings.get(moduleId,SETTINGS.MAX_ROLLS_STORED);recentRolls.length>h&&(recentRolls.length=h)}const y=game.modules.get(moduleId);(d=y.socketManager)!=null&&d.isConnected()&&y.socketManager.send({type:"roll-data",data:c})}});
//# sourceMappingURL=module.js.map
