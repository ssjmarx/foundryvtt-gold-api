var U=Object.defineProperty;var C=(e,s,t)=>s in e?U(e,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[s]=t;var q=(e,s,t)=>C(e,typeof s!="symbol"?s+"":s,t);const id="foundryvtt-gold-api";class dnd5e{constructor(){q(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}class a5e{constructor(){q(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}const SYSTEMS={SUPPORTED_SYSTEMS:{dnd5e:{latest:dnd5e},a5e:{latest:a5e}},DEFAULT_SETTINGS:{ACTOR_CURRENCY_ATTRIBUTE:""},_currentSystem:!1,get DATA(){var u;if(this._currentSystem)return this._currentSystem;const e=(u=this.SUPPORTED_SYSTEMS)==null?void 0:u[game.system.id.toLowerCase()];if(!e)return this.DEFAULT_SETTINGS;if(e[game.system.version])return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[game.system.version]),this._currentSystem;const s=Object.keys(e);if(s.length===1)return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[s[0]]),this._currentSystem;s.sort((i,n)=>i==="latest"||n==="latest"?-1/0:isNewerVersion(n,i)?-1:1);const t=s.find(i=>i==="latest"||!isNewerVersion(game.system.version,i));return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[t]),this._currentSystem}},CONSTANTS={MODULE_ID:id},moduleId=id,recentRolls=[],MAX_ROLLS_STORED=20,SETTINGS={ACTOR_CURRENCY_ATTRIBUTE:"actorCurrencyAttribute",WS_RELAY_URL:"wsRelayUrl",API_KEY:"apiKey",CUSTOM_NAME:"customName",LOG_LEVEL:"logLevel",PING_INTERVAL:"pingInterval",RECONNECT_MAX_ATTEMPTS:"reconnectMaxAttempts",RECONNECT_BASE_DELAY:"reconnectBaseDelay",SYSTEM_FOUND:"systemFound",SYSTEM_NOT_FOUND_WARNING_SHOWN:"systemNotFoundWarningShown",SYSTEM_VERSION:"systemVersion",GET_DEFAULT(){return foundry.utils.deepClone(SETTINGS.DEFAULTS())},GET_SYSTEM_DEFAULTS(){return Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).filter(e=>e[1].system))},DEFAULTS:()=>({[SETTINGS.ACTOR_CURRENCY_ATTRIBUTE]:{name:"Actor Currency attribute",hint:"Reference path to the actor currency attribute",scope:"world",config:!1,system:!0,default:SYSTEMS.DATA.ACTOR_CURRENCY_ATTRIBUTE,type:String},[SETTINGS.SYSTEM_VERSION]:{scope:"world",config:!1,default:"0.0.0",type:String},[SETTINGS.SYSTEM_FOUND]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.WS_RELAY_URL]:{name:"WebSocket Relay URL",hint:"URL for the WebSocket relay server",scope:"world",config:!0,type:String,default:"wss://foundryvtt-rest-api-relay.fly.dev",requiresReload:!0},[SETTINGS.API_KEY]:{name:"API Key",hint:"API Key for authentication with the relay server",scope:"world",config:!0,type:String,default:game.world.id,requiresReload:!0},[SETTINGS.CUSTOM_NAME]:{name:"Custom Client Name",hint:"A custom name to identify this client (optional)",scope:"world",config:!0,type:String,default:"",requiresReload:!0},[SETTINGS.LOG_LEVEL]:{name:"Log Level",hint:"Set the level of detail for module logging",scope:"world",config:!0,type:Number,choices:{0:"debug",1:"info",2:"warn",3:"error"},default:2},[SETTINGS.PING_INTERVAL]:{name:"Ping Interval (seconds)",hint:"How often (in seconds) the module sends a ping to the relay server to keep the connection alive.",scope:"world",config:!0,type:Number,default:30,range:{min:5,max:600,step:1},requiresReload:!0},[SETTINGS.RECONNECT_MAX_ATTEMPTS]:{name:"Max Reconnect Attempts",hint:"Maximum number of times the module will try to reconnect after losing connection.",scope:"world",config:!0,type:Number,default:20,requiresReload:!0},[SETTINGS.RECONNECT_BASE_DELAY]:{name:"Reconnect Base Delay (ms)",hint:"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.",scope:"world",config:!0,type:Number,default:1e3,requiresReload:!0}})};class ModuleLogger{static debugLevel(){return game.settings.get(moduleId,"logLevel")}static debug(s,...t){return this.debugLevel()<1&&console.log(`${moduleId} | ${s}`,...t),s}static info(s,...t){return this.debugLevel()<2&&console.log(`${moduleId} | ${s}`,...t),s}static warn(s,...t){return this.debugLevel()<3&&console.warn(`${moduleId} | ${s}`,...t),s}static error(s,...t){return this.debugLevel()<4&&console.error(`${moduleId} | ${s}`,...t),s}}var WSCloseCodes=(e=>(e[e.Normal=1e3]="Normal",e[e.NoClientId=4001]="NoClientId",e[e.NoAuth=4002]="NoAuth",e[e.NoConnectedGuild=4003]="NoConnectedGuild",e[e.InternalError=4e3]="InternalError",e[e.DuplicateConnection=4004]="DuplicateConnection",e[e.ServerShutdown=4005]="ServerShutdown",e))(WSCloseCodes||{});const M=class M{constructor(s,t){q(this,"url");q(this,"token");q(this,"socket",null);q(this,"messageHandlers",new Map);q(this,"reconnectTimer",null);q(this,"reconnectAttempts",0);q(this,"clientId");q(this,"pingInterval",null);q(this,"isConnecting",!1);q(this,"isPrimaryGM",!1);var u,i,n;this.url=s,this.token=t,this.clientId=`foundry-${((u=game.user)==null?void 0:u.id)||Math.random().toString(36).substring(2,15)}`,this.isPrimaryGM=this.checkIfPrimaryGM(),ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`),(i=game.user)!=null&&i.isGM&&((n=game.user)==null?void 0:n.role)===4&&(Hooks.on("userConnected",this.reevaluatePrimaryGM.bind(this)),Hooks.on("userDisconnected",this.reevaluatePrimaryGM.bind(this)))}static getInstance(s,t){var u,i;return!((u=game.user)!=null&&u.isGM)||((i=game.user)==null?void 0:i.role)!==4?(ModuleLogger.info("WebSocketManager not created - user is not a full GM"),null):(M.instance||(ModuleLogger.info("Creating new WebSocketManager instance"),M.instance=new M(s,t)),M.instance)}checkIfPrimaryGM(){var n,r,d,o,l,c;if(!((n=game.user)!=null&&n.isGM)||((r=game.user)==null?void 0:r.role)!==4)return!1;const s=(d=game.user)==null?void 0:d.id,t=((o=game.users)==null?void 0:o.filter(a=>a.role===4&&a.active))||[];if(t.length===0)return!1;const u=[...t].sort((a,y)=>(a.id||"").localeCompare(y.id||"")),i=((l=u[0])==null?void 0:l.id)===s;return ModuleLogger.info(`Primary GM check - Current user: ${s}, Primary GM: ${(c=u[0])==null?void 0:c.id}, isPrimary: ${i}`),i}reevaluatePrimaryGM(){const s=this.isPrimaryGM;this.isPrimaryGM=this.checkIfPrimaryGM(),s!==this.isPrimaryGM&&(ModuleLogger.info(`Primary GM status changed: ${s} -> ${this.isPrimaryGM}`),this.isPrimaryGM&&!this.isConnected()&&(ModuleLogger.info("Taking over as primary GM, connecting WebSocket"),this.connect()),!this.isPrimaryGM&&this.isConnected()&&(ModuleLogger.info("No longer primary GM, disconnecting WebSocket"),this.disconnect()))}connect(){var s,t;if(!((s=game.user)!=null&&s.isGM)||((t=game.user)==null?void 0:t.role)!==4){ModuleLogger.info("WebSocket connection aborted - user is not a full GM");return}if(!this.isPrimaryGM){ModuleLogger.info("WebSocket connection aborted - user is not the primary GM");return}if(this.isConnecting){ModuleLogger.info("Already attempting to connect");return}if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){ModuleLogger.info("WebSocket already connected or connecting");return}this.isConnecting=!0;try{const u=new URL(this.url);u.searchParams.set("id",this.clientId),u.searchParams.set("token",this.token),game.world&&(u.searchParams.set("worldId",game.world.id),u.searchParams.set("worldTitle",game.world.title)),u.searchParams.set("foundryVersion",game.version),u.searchParams.set("systemId",game.system.id),u.searchParams.set("systemTitle",game.system.title||game.system.id),u.searchParams.set("systemVersion",game.system.version||"unknown");const i=game.settings.get(moduleId,"customName");i&&u.searchParams.set("customName",i),ModuleLogger.info(`Connecting to WebSocket at ${u.toString()}`),this.socket=new WebSocket(u.toString());const n=window.setTimeout(()=>{this.socket&&this.socket.readyState===WebSocket.CONNECTING&&(ModuleLogger.error("Connection timed out"),this.socket.close(),this.socket=null,this.isConnecting=!1,this.scheduleReconnect())},5e3);this.socket.addEventListener("open",r=>{window.clearTimeout(n),this.onOpen(r)}),this.socket.addEventListener("close",r=>{window.clearTimeout(n),this.onClose(r)}),this.socket.addEventListener("error",r=>{window.clearTimeout(n),this.onError(r)}),this.socket.addEventListener("message",this.onMessage.bind(this))}catch(u){ModuleLogger.error("Error creating WebSocket:",u),this.isConnecting=!1,this.scheduleReconnect()}}disconnect(){this.socket&&(ModuleLogger.info("Disconnecting WebSocket"),this.socket.close(WSCloseCodes.Normal,"Disconnecting"),this.socket=null),this.reconnectTimer!==null&&(window.clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),this.reconnectAttempts=0,this.isConnecting=!1}isConnected(){return this.socket!==null&&this.socket.readyState===WebSocket.OPEN}getClientId(){return this.clientId}send(s){var t,u;if(ModuleLogger.info(`Send called, readyState: ${(t=this.socket)==null?void 0:t.readyState}`),this.socket&&this.socket.readyState===WebSocket.OPEN)try{return ModuleLogger.info("Sending message:",s),this.socket.send(JSON.stringify(s)),!0}catch(i){return ModuleLogger.error("Error sending message:",i),!1}else return ModuleLogger.warn(`WebSocket not ready, state: ${(u=this.socket)==null?void 0:u.readyState}`),!1}onMessageType(s,t){this.messageHandlers.set(s,t)}onOpen(s){ModuleLogger.info("WebSocket connected"),this.isConnecting=!1,this.reconnectAttempts=0,this.send({type:"ping"});const t=game.settings.get(moduleId,SETTINGS.PING_INTERVAL),u=t*1e3;ModuleLogger.info(`Starting application ping interval: ${t} seconds`),this.pingInterval!==null&&window.clearInterval(this.pingInterval),this.pingInterval=window.setInterval(()=>{this.isConnected()&&this.send({type:"ping"})},u)}onClose(s){ModuleLogger.info(`WebSocket disconnected: ${s.code} - ${s.reason}`),this.socket=null,this.isConnecting=!1,this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),s.code!==WSCloseCodes.Normal&&this.isPrimaryGM&&this.scheduleReconnect()}onError(s){ModuleLogger.error("WebSocket error:",s),this.isConnecting=!1}async onMessage(s){try{const t=JSON.parse(s.data);ModuleLogger.info("Received message:",t),t.type&&this.messageHandlers.has(t.type)?(ModuleLogger.info(`Handling message of type: ${t.type}`),this.messageHandlers.get(t.type)(t,{socketManager:this})):t.type&&ModuleLogger.warn(`No handler for message type: ${t.type}`)}catch(t){ModuleLogger.error("Error processing message:",t)}}scheduleReconnect(){if(this.reconnectTimer!==null)return;const s=game.settings.get(moduleId,SETTINGS.RECONNECT_MAX_ATTEMPTS),t=game.settings.get(moduleId,SETTINGS.RECONNECT_BASE_DELAY);if(this.reconnectAttempts++,this.reconnectAttempts>s){ModuleLogger.error(`Maximum reconnection attempts (${s}) reached`),this.reconnectAttempts=0;return}const u=Math.min(3e4,t*Math.pow(2,this.reconnectAttempts-1));ModuleLogger.info(`Scheduling reconnect in ${u}ms (attempt ${this.reconnectAttempts}/${s})`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=null,this.isPrimaryGM?(ModuleLogger.info("Attempting reconnect..."),this.connect()):(ModuleLogger.info("Reconnect attempt aborted - no longer primary GM."),this.reconnectAttempts=0)},u)}};q(M,"instance",null);let WebSocketManager=M;class Router{constructor(s,t=[]){q(this,"title");q(this,"routes");this.title=s,this.routes=t}addRoute(s){this.routes.push(s)}reflect(s){this.routes.forEach(t=>s.onMessageType(t.actionType,t.handler))}}const router$a=new Router("pingRouter");router$a.addRoute({actionType:"ping",handler:e=>{ModuleLogger.info("Received ping, sending pong"),e.socketManager.send({type:"pong"})}});router$a.addRoute({actionType:"pong",handler:()=>{ModuleLogger.info("Received pong")}});function deepSerializeEntity(e){var s,t,u,i,n;if(!e)return null;try{let r=e.toObject?e.toObject(!0):JSON.parse(JSON.stringify(e));if(e.system){if(e.system.attributes){for(const[d,o]of Object.entries(e.system.attributes))if(((t=(s=r.system)==null?void 0:s.attributes)==null?void 0:t[d])===null&&o!==null&&(r.system.attributes||(r.system.attributes={}),r.system.attributes[d]=JSON.parse(JSON.stringify(o))),typeof o=="object"&&o!==null)for(const[l,c]of Object.entries(o))((n=(i=(u=r.system)==null?void 0:u.attributes)==null?void 0:i[d])==null?void 0:n[l])===null&&c!==null&&(r.system.attributes[d]||(r.system.attributes[d]={}),r.system.attributes[d][l]=JSON.parse(JSON.stringify(c)))}["traits","abilities","skills","resources"].forEach(d=>{var o,l,c,a,y;if(e.system[d]){for(const[h,p]of Object.entries(e.system[d]))if(((l=(o=r.system)==null?void 0:o[d])==null?void 0:l[h])===null&&p!==null&&(r.system[d]||(r.system[d]={}),r.system[d][h]=JSON.parse(JSON.stringify(p))),typeof p=="object"&&p!==null)for(const[m,f]of Object.entries(p))((y=(a=(c=r.system)==null?void 0:c[d])==null?void 0:a[h])==null?void 0:y[m])===null&&f!==null&&(r.system[d][h]||(r.system[d][h]={}),r.system[d][h][m]=JSON.parse(JSON.stringify(f)))}})}if(e.items&&e.items.size>0&&Array.isArray(r.items))try{const d=e.items;if(Array.isArray(d.contents))for(let o=0;o<d.contents.length;o++)o<r.items.length&&(r.items[o]=deepSerializeEntity(d.contents[o]));else if(typeof d.entries=="function"){const o=Array.from(d.entries());for(let l=0;l<o.length;l++){const[c,a]=o[l];l<r.items.length&&(r.items[l]=deepSerializeEntity(a))}}}catch(d){ModuleLogger.warn("Failed to process entity.items collection:",d)}if(e.effects&&e.effects.size>0&&Array.isArray(r.effects))try{const d=e.effects;if(Array.isArray(d.contents))for(let o=0;o<d.contents.length;o++)o<r.effects.length&&(r.effects[o]=deepSerializeEntity(d.contents[o]));else if(typeof d.entries=="function"){const o=Array.from(d.entries());for(let l=0;l<o.length;l++){const[c,a]=o[l];l<r.effects.length&&(r.effects[l]=deepSerializeEntity(a))}}}catch(d){ModuleLogger.warn("Failed to process entity.effects collection:",d)}return r}catch(r){return ModuleLogger.error("Error deep serializing entity:",r),e.toObject?e.toObject():e}}const router$9=new Router("entityRouter");router$9.addRoute({actionType:"entity",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received entity request:",e);try{let i,n=[],r=e.uuid;if(e.selected){const d=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled;if(d)for(let o of d)e.actor?i=o.actor:i=o.document,i&&(r=i.uuid,n.push(deepSerializeEntity(i)))}else i=await fromUuid(e.uuid),n=i?deepSerializeEntity(i):null;if(!n){ModuleLogger.error(`Entity not found: ${e.uuid}`),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:"Entity not found",data:null});return}ModuleLogger.info(`Sending entity data for: ${e.uuid}`,n),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:r,data:n})}catch(i){ModuleLogger.error("Error getting entity:",i),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:i.message,data:null})}}});router$9.addRoute({actionType:"create",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received create entity request for type: ${e.entityType}`);try{const u=getDocumentClass(e.entityType);if(!u)throw new Error(`Invalid entity type: ${e.entityType}`);const i={...e.data,folder:e.folder||null},n=await u.create(i);if(!n)throw new Error("Failed to create entity");t==null||t.send({type:"create-result",requestId:e.requestId,uuid:n.uuid,entity:n.toObject()})}catch(u){ModuleLogger.error("Error creating entity:",u),t==null||t.send({type:"create-result",requestId:e.requestId,error:u.message,message:"Failed to create entity"})}}});router$9.addRoute({actionType:"decrease",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received decrease attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const i=[];if(e.selected){const r=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[];for(const d of r)d.actor&&i.push(d.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&i.push(r)}if(i.length===0)throw new Error("No entities found to modify");const n=[];for(const r of i){const d=getProperty(r,e.attribute);if(typeof d!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof d}`);const o=d-e.amount,l={};l[e.attribute]=o,await r.update(l),n.push({uuid:r.uuid,attribute:e.attribute,oldValue:d,newValue:o})}t==null||t.send({type:"decrease-result",requestId:e.requestId,results:n,success:!0})}catch(i){ModuleLogger.error("Error decreasing attribute:",i),t==null||t.send({type:"decrease-result",requestId:e.requestId,success:!1,error:i.message})}}});router$9.addRoute({actionType:"increase",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received increase attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const i=[];if(e.selected){const r=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[];for(const d of r)d.actor&&i.push(d.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&i.push(r)}if(i.length===0)throw new Error("No entities found to modify");const n=[];for(const r of i){const d=getProperty(r,e.attribute);if(typeof d!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof d}`);const o=d+e.amount,l={};l[e.attribute]=o,await r.update(l),n.push({uuid:r.uuid,attribute:e.attribute,oldValue:d,newValue:o})}t==null||t.send({type:"increase-result",requestId:e.requestId,results:n,success:!0})}catch(i){ModuleLogger.error("Error increasing attribute:",i),t==null||t.send({type:"increase-result",requestId:e.requestId,success:!1,error:i.message})}}});router$9.addRoute({actionType:"update",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received update entity request for UUID: ${e.uuid}`);try{let i=[];if(e.uuid)i.push(await fromUuid(e.uuid));else if(e.selected){const r=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled;if(r)for(let d of r)e.actor?i.push(d.actor):i.push(d.document)}if(i.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let r of i)await(r==null?void 0:r.update(e.data));let n=[];for(let r of i)n.push(await fromUuid(r.uuid));t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,entity:n.map(r=>r==null?void 0:r.toObject())})}catch(i){ModuleLogger.error("Error updating entity:",i),t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,error:i.message,message:"Failed to update entity"})}}});router$9.addRoute({actionType:"delete",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received delete entity request for UUID: ${e.uuid}`);try{let i=[];if(e.uuid)i.push(await fromUuid(e.uuid));else if(e.selected){const n=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled;if(n)for(let r of n)e.actor?i.push(r.actor):i.push(r.document)}if(!i||i.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let n of i)await(n==null?void 0:n.delete());t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,success:!0})}catch(i){ModuleLogger.error("Error deleting entity:",i),t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,error:i.message,message:"Failed to delete entity"})}}});router$9.addRoute({actionType:"kill",handler:async(e,s)=>{var u,i,n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received kill request for UUID: ${e.uuid}`);try{const r=[];if(e.uuid){const o=await fromUuid(e.uuid);if(o)r.push(o);else throw new Error(`Entity not found: ${e.uuid}`)}else if(e.selected){const o=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[];for(const l of o)l.document&&r.push(l.document)}if(r.length===0)throw new Error("No entities found to mark as defeated");const d=[];for(const o of r){let l=!1,c="";if(o.documentName==="Token"){const a=o,y=a.actor;if(!y)throw new Error("Token has no associated actor");const h=game.combat;if(h){const p=h.combatants.find(m=>{var f,g,w,I;return((f=m.token)==null?void 0:f.id)===a.id&&((w=(g=m.token)==null?void 0:g.parent)==null?void 0:w.id)===((I=a.parent)==null?void 0:I.id)});p&&(await p.update({defeated:!0}),ModuleLogger.info("Marked token as defeated in combat"))}try{hasProperty(y,"system.attributes.hp")?await y.update({"system.attributes.hp.value":0}):hasProperty(y,"system.health")?await y.update({"system.health.value":0}):hasProperty(y,"system.hp")?await y.update({"system.hp.value":0}):hasProperty(y,"data.attributes.hp")&&await y.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(p){ModuleLogger.warn(`Could not set HP to 0: ${p}`)}try{const p=(i=CONFIG.statusEffects)==null?void 0:i.find(m=>m.id==="dead"||m.id==="unconscious"||m.id==="defeated");p?(await a.toggleActiveEffect(p),ModuleLogger.info(`Added ${p.id} status effect to token`)):ModuleLogger.warn("No dead status effect found")}catch(p){ModuleLogger.warn(`Could not apply status effect: ${p}`)}l=!0,c="Token marked as defeated, HP set to 0, and dead effect applied"}else if(o.documentName==="Actor"){const a=o;let y=0;const h=game.scenes;if(h!=null&&h.viewed){const m=h.viewed.tokens.filter(f=>{var g;return((g=f.actor)==null?void 0:g.id)===a.id});for(const f of m)try{const g=(n=CONFIG.statusEffects)==null?void 0:n.find(w=>w.id==="dead"||w.id==="unconscious"||w.id==="defeated");g&&(await f.toggleActiveEffect(g),y++)}catch(g){ModuleLogger.warn(`Could not apply status effect to token: ${g}`)}}const p=game.combat;if(p){const m=p.combatants.filter(f=>{var g;return((g=f.actor)==null?void 0:g.id)===a.id});m.length>0&&(await Promise.all(m.map(f=>f.update({defeated:!0}))),ModuleLogger.info(`Marked ${m.length} combatants as defeated`))}try{hasProperty(a,"system.attributes.hp")?await a.update({"system.attributes.hp.value":0}):hasProperty(a,"system.health")?await a.update({"system.health.value":0}):hasProperty(a,"system.hp")?await a.update({"system.hp.value":0}):hasProperty(a,"data.attributes.hp")&&await a.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(m){ModuleLogger.warn(`Could not set HP to 0: ${m}`)}l=!0,c=`Actor marked as defeated, HP set to 0, and dead effect applied to ${y} tokens`}else throw new Error(`Cannot mark entity type ${o.documentName} as defeated`);d.push({uuid:o.uuid,success:l,message:c})}t==null||t.send({type:"kill-result",requestId:e.requestId,results:d})}catch(r){ModuleLogger.error("Error marking entities as defeated:",r),t==null||t.send({type:"kill-result",requestId:e.requestId,success:!1,error:r.message})}}});router$9.addRoute({actionType:"give",handler:async(e,s)=>{var u,i,n,r;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received give item request from ${e.fromUuid} to ${e.toUuid}`);try{if(!e.toUuid&&!e.selected)throw new Error("Target UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");let d=null;if(e.fromUuid&&(d=await fromUuid(e.fromUuid),(d==null?void 0:d.documentName)!=="Actor"))throw new Error(`Source entity must be an Actor, got ${d==null?void 0:d.documentName}`);e.selected&&(e.toUuid=(n=(i=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled[0])==null?void 0:i.actor)==null?void 0:n.uuid);const o=await fromUuid(e.toUuid);if(!o)throw new Error(`Target entity not found: ${e.toUuid}`);if(o.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${o.documentName}`);let l=null,c=null;if(e.itemUuid)l=await fromUuid(e.itemUuid),l&&(c=l.toObject());else if(e.itemName)if(d)l=d.items.find(f=>f.name.toLowerCase()===e.itemName.toLowerCase()),l&&(c=l.toObject());else{if(!window.QuickInsert)throw new Error("QuickInsert is not available for global item search.");window.QuickInsert.hasIndex||(ModuleLogger.info("QuickInsert index not ready, forcing index creation"),window.QuickInsert.forceIndex(),await new Promise(w=>setTimeout(w,500)));const g=(await window.QuickInsert.search(e.itemName,null,20)).find(w=>{var I;return((I=w.item)==null?void 0:I.documentType)==="Item"});if(g){const w=await g.item.get();w&&(c=w.toObject())}}if(!c)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);if(l&&l.documentName!=="Item")throw new Error(`Entity must be an Item, got ${l.documentName}`);if(l&&d&&((r=l.parent)==null?void 0:r.id)!==d.id)throw new Error(`Item ${e.itemUuid||e.itemName} does not belong to source actor ${e.fromUuid}`);const a=e.quantity||1,y=o.items.find(f=>f.name===c.name),h=y&&hasProperty(y.system,"quantity");if(l&&d){const f=getProperty(l,"system.quantity");typeof f=="number"&&a<f?await l.update({"system.quantity":f-a}):await l.delete()}let p,m;if(h){const f=y.system.quantity+a;await y.update({"system.quantity":f}),p=y.id,m=f}else delete c._id,(hasProperty(c,"system.quantity")||c.system)&&(c.system.quantity=a),m=a,p=(await o.createEmbeddedDocuments("Item",[c]))[0].id;t==null||t.send({type:"give-result",requestId:e.requestId,fromUuid:e.fromUuid,selected:e.selected,toUuid:e.toUuid,quantity:m,itemUuid:e.itemUuid,newItemId:p,success:!0})}catch(d){ModuleLogger.error("Error giving item:",d),t==null||t.send({type:"give-result",requestId:e.requestId,selected:e.selected,fromUuid:e.fromUuid||"",toUuid:e.toUuid||"",quantity:e.quantity,itemUuid:e.itemUuid||"",success:!1,error:d.message})}}});router$9.addRoute({actionType:"remove",handler:async(e,s)=>{var u,i,n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove item request from actor: ${e.actorUuid}`);try{if(!e.actorUuid&&!e.selected)throw new Error("Target actor UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");e.selected&&(e.actorUuid=(n=(i=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled[0])==null?void 0:i.actor)==null?void 0:n.uuid);const r=await fromUuid(e.actorUuid);if(!r)throw new Error(`Target actor not found: ${e.actorUuid}`);if(r.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${r.documentName}`);let d=null;if(e.itemUuid?d=await fromUuid(e.itemUuid):e.itemName&&(d=r.items.find(a=>a.name.toLowerCase()===e.itemName.toLowerCase())),!d)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);const o=e.quantity||null,l=getProperty(d,"system.quantity");let c=0;o&&typeof l=="number"&&l>o?(c=l-o,await d.update({"system.quantity":c})):await d.delete(),t==null||t.send({type:"remove-result",requestId:e.requestId,actorUuid:e.actorUuid,itemUuid:d.uuid,quantity:c,success:!0})}catch(r){ModuleLogger.error("Error removing item:",r),t==null||t.send({type:"remove-result",requestId:e.requestId,success:!1,error:r.message})}}});const router$8=new Router("encounterRouter");router$8.addRoute({actionType:"encounters",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for encounters");try{const i=((u=game.combats)==null?void 0:u.contents.map(n=>{var r;return{id:n.id,name:n.name,round:n.round,turn:n.turn,current:n.id===((r=game.combat)==null?void 0:r.id),combatants:n.combatants.contents.map(d=>{var o,l;return{id:d.id,name:d.name,tokenUuid:(o=d.token)==null?void 0:o.uuid,actorUuid:(l=d.actor)==null?void 0:l.uuid,img:d.img,initiative:d.initiative,hidden:d.hidden,defeated:d.isDefeated}})}}))||[];t==null||t.send({type:"encounters-result",requestId:e.requestId,encounters:i})}catch(i){ModuleLogger.error("Error getting encounters list:",i),t==null||t.send({type:"encounters-result",requestId:e.requestId,error:i.message,encounters:[]})}}});router$8.addRoute({actionType:"start-encounter",handler:async(e,s)=>{var u,i,n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request to start encounter with options:",e);try{const r=await Combat.create({name:e.name||"New Encounter"});if(r){if(await r.startCombat(),e.tokenUuids&&e.tokenUuids.length>0){const o=[];for(const l of e.tokenUuids)try{const c=await fromUuid(l);c&&o.push({tokenId:c.id??"",sceneId:c.parent.id})}catch(c){ModuleLogger.warn(`Failed to add token ${l} to combat:`,c)}o.length>0&&await r.createEmbeddedDocuments("Combatant",o)}let d=new Set;if(e.startWithPlayers){const o=(u=game.scenes)==null?void 0:u.viewed;if(o){const c=(((i=o.tokens)==null?void 0:i.filter(a=>!!a.actor&&a.actor.hasPlayerOwner))??[]).map(a=>(d.add(a.id),{tokenId:a.id,sceneId:o.id}));c.length>0&&await r.createEmbeddedDocuments("Combatant",c)}}if(e.startWithSelected){const o=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled.filter(l=>!d.has(l.id)).map(l=>({tokenId:l.id,sceneId:l.scene.id})))??[];o.length>0&&await r.createEmbeddedDocuments("Combatant",o)}e.rollNPC&&await r.rollNPC(),e.rollAll&&await r.rollAll(),await r.activate(),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,encounterId:r.id,encounter:{id:r.id,name:r.name,round:r.round,turn:r.turn,combatants:r.combatants.contents.map(o=>{var l,c;return{id:o.id,name:o.name,tokenUuid:(l=o.token)==null?void 0:l.uuid,actorUuid:(c=o.actor)==null?void 0:c.uuid,img:o.img,initiative:o.initiative,hidden:o.hidden,defeated:o.isDefeated}})}})}else throw new Error("Failed to create encounter")}catch(r){ModuleLogger.error("Error starting encounter:",r),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,error:r.message})}}});router$8.addRoute({actionType:"next-turn",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next turn in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.nextTurn(),t==null||t.send({type:"next-turn-result",requestId:e.requestId,encounterId:o.id,action:"nextTurn",currentTurn:o.turn,currentRound:o.round,actorTurn:(n=(i=o.combatant)==null?void 0:i.actor)==null?void 0:n.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error advancing to next turn:",o),t==null||t.send({type:"next-turn-result",requestId:e.requestId,error:o.message})}}});router$8.addRoute({actionType:"next-round",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next round in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.nextRound(),t==null||t.send({type:"next-round-result",requestId:e.requestId,encounterId:o.id,action:"nextRound",currentTurn:o.turn,currentRound:o.round,actorTurn:(n=(i=o.combatant)==null?void 0:i.actor)==null?void 0:n.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error advancing to next round:",o),t==null||t.send({type:"next-round-result",requestId:e.requestId,error:o.message})}}});router$8.addRoute({actionType:"last-turn",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous turn in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.previousTurn(),t==null||t.send({type:"last-turn-result",requestId:e.requestId,encounterId:o.id,action:"previousTurn",currentTurn:o.turn,currentRound:o.round,actorTurn:(n=(i=o.combatant)==null?void 0:i.actor)==null?void 0:n.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error going back to previous turn:",o),t==null||t.send({type:"last-turn-result",requestId:e.requestId,error:o.message})}}});router$8.addRoute({actionType:"last-round",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous round in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.previousRound(),t==null||t.send({type:"last-round-result",requestId:e.requestId,encounterId:o.id,action:"previousRound",currentTurn:o.turn,currentRound:o.round,actorTurn:(n=(i=o.combatant)==null?void 0:i.actor)==null?void 0:n.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error going back to previous round:",o),t==null||t.send({type:"encounter-navigation",requestId:e.requestId,error:o.message})}}});router$8.addRoute({actionType:"end-encounter",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to end encounter: ${e.encounterId}`);try{let n=e.encounterId;n||(n=(u=game.combat)==null?void 0:u.id);const r=(i=game.combats)==null?void 0:i.get(n);if(!r)throw new Error("No encounter not found");await r.delete(),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,encounterId:n,message:"Encounter successfully ended"})}catch(n){ModuleLogger.error("Error ending encounter:",n),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,error:n.message})}}});router$8.addRoute({actionType:"add-to-encounter",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received add-to-encounter request for encounter: ${e.encounterId}`);try{const o=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const l=[],c=[];if(e.uuids&&Array.isArray(e.uuids))for(const a of e.uuids)try{const y=await fromUuid(a);if(!y){c.push({uuid:a,reason:"Entity not found"});continue}if(y.documentName==="Token"){const h=y,p={tokenId:h.id,sceneId:(i=h.parent)==null?void 0:i.id};await o.createEmbeddedDocuments("Combatant",[p]),l.push(a)}else if(y.documentName==="Actor"){const h=(n=game.scenes)==null?void 0:n.viewed;if(h){const p=(r=h.tokens)==null?void 0:r.find(m=>{var f;return((f=m.actor)==null?void 0:f.id)===y.id});if(p){const m={tokenId:p.id,sceneId:h.id};await o.createEmbeddedDocuments("Combatant",[m]),l.push(a)}else c.push({uuid:a,reason:"No token found for this actor in the current scene"})}else c.push({uuid:a,reason:"No active scene"})}else c.push({uuid:a,reason:"Entity must be a Token or Actor"})}catch(y){c.push({uuid:a,reason:y.message})}if(e.selected===!0){const a=((d=canvas==null?void 0:canvas.tokens)==null?void 0:d.controlled)||[];for(const y of a)try{if(!o.combatants.find(h=>{var p,m,f;return((p=h.token)==null?void 0:p.id)===y.id&&((f=(m=h.combat)==null?void 0:m.scene)==null?void 0:f.id)===y.scene.id})){const h={tokenId:y.id,sceneId:y.scene.id};await o.createEmbeddedDocuments("Combatant",[h]),l.push(y.document.uuid)}}catch(h){c.push({uuid:y.document.uuid,reason:h.message})}}e.rollInitiative===!0&&l.length>0&&o.rollAll(),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,encounterId:o.id,added:l,failed:c})}catch(o){ModuleLogger.error("Error adding to encounter:",o),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,error:o.message})}}});router$8.addRoute({actionType:"remove-from-encounter",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove-from-encounter request for encounter: ${e.encounterId}`);try{const n=e.encounterId?(u=game.combats)==null?void 0:u.get(e.encounterId):game.combat;if(!n)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const r=[],d=[],o=[];if(e.uuids&&Array.isArray(e.uuids))for(const l of e.uuids)try{const c=await fromUuid(l);if(!c){d.push({uuid:l,reason:"Entity not found"});continue}let a=!1;if(c.documentName==="Token"){const y=n.combatants.find(h=>{var p,m,f,g;return((p=h.token)==null?void 0:p.id)===c.id&&((f=(m=h.combat)==null?void 0:m.scene)==null?void 0:f.id)===((g=c.parent)==null?void 0:g.id)});y&&(o.push(y.id),a=!0)}else if(c.documentName==="Actor"){const y=n.combatants.filter(h=>{var p;return((p=h.actor)==null?void 0:p.id)===c.id});y.length>0&&(o.push(...y.map(h=>h.id)),a=!0)}a?r.push(l):d.push({uuid:l,reason:"No combatant found for this entity"})}catch(c){d.push({uuid:l,reason:c.message})}if(e.selected===!0){const l=((i=canvas==null?void 0:canvas.tokens)==null?void 0:i.controlled)||[];for(const c of l){const a=n.combatants.find(y=>y.tokenId===c.id&&y.sceneId===c.scene.id);a&&(o.push(a.id),r.push(c.document.uuid))}}if(o.length>0){const l=o.filter(c=>c!==null);l.length>0&&await n.deleteEmbeddedDocuments("Combatant",l)}t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,encounterId:n.id,removed:r,failed:d})}catch(n){ModuleLogger.error("Error removing from encounter:",n),t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,error:n.message})}}});const router$7=new Router("rollRouter");router$7.addRoute({actionType:"rolls",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for roll data"),t==null||t.send({type:"rolls-result",requestId:e.requestId,data:recentRolls.slice(0,e.limit||20)})}});router$7.addRoute({actionType:"last-roll",handler:(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for last roll data"),t==null||t.send({type:"last-roll-result",requestId:e.requestId,data:recentRolls.length>0?recentRolls[0]:null})}});router$7.addRoute({actionType:"roll",handler:async(e,s)=>{var u,i,n,r,d;const t=s==null?void 0:s.socketManager;try{const{formula:o,flavor:l,createChatMessage:c,speaker:a,whisper:y,requestId:h}=e;let p,m={},f=y&&y.length>0?CONST.DICE_ROLL_MODES.PRIVATE:CONST.DICE_ROLL_MODES.PUBLIC;if(a)try{const g=await fromUuid(a);if(g){if(g instanceof TokenDocument)m={token:g==null?void 0:g.id,actor:(u=g==null?void 0:g.actor)==null?void 0:u.id,scene:(i=g==null?void 0:g.parent)==null?void 0:i.id,alias:(g==null?void 0:g.name)||((n=g==null?void 0:g.actor)==null?void 0:n.name)};else if(g instanceof Actor){const w=(r=game.scenes)==null?void 0:r.active;if(w){const I=(d=w.tokens)==null?void 0:d.filter(E=>{var v;return((v=E.actor)==null?void 0:v.id)===g.id});if(I&&I.length>0){const E=I[0];m={token:E.id,actor:g.id,scene:w.id,alias:E.name||g.name}}else m={actor:g.id,alias:g.name}}}}}catch(g){ModuleLogger.warn(`Failed to process speaker: ${g}`)}try{const g=new Roll(o);await g.evaluate(),c&&await g.toMessage({speaker:m,flavor:l||"",rollMode:f,whisper:y||[]}),p={id:`manual_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!!c,roll:{formula:o,total:g.total,isCritical:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===g.terms[0].faces)}),isFumble:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===1)}),dice:g.dice.map(w=>({faces:w.faces,results:w.results.map(I=>({result:I.result,active:I.active}))})),timestamp:Date.now()}}}catch(g){ModuleLogger.error(`Error rolling formula: ${g}`),t==null||t.send({type:"roll-result",requestId:h,success:!1,error:`Failed to roll formula: ${g.message}`});return}t==null||t.send({type:"roll-result",requestId:h,success:!0,data:p})}catch(o){ModuleLogger.error(`Error in roll handler: ${o}`),t==null||t.send({type:"roll-result",requestId:e.requestId,success:!1,error:o.message||"Unknown error occurred during roll"})}}});function parseFilterString(e){if(!e.includes(":"))return{documentType:e};const s={},t=e.split(",");for(const u of t)if(u.includes(":")){const[i,n]=u.split(":");i&&n&&(s[i.trim()]=n.trim())}return s}function matchesAllFilters(e,s){var t,u;for(const[i,n]of Object.entries(s)){if(!n)continue;if(i==="resultType"){const d=(u=(t=e.item)==null?void 0:t.constructor)==null?void 0:u.name;if(!d||d.toLowerCase()!==n.toLowerCase())return!1;continue}if(i==="package"&&e.item){const d=e.item.package;if(!d||d.toLowerCase()!==n.toLowerCase()&&`Compendium.${d}`.toLowerCase()!==n.toLowerCase())return!1;continue}if(i==="folder"&&e.item){const d=e.item.folder;if(!d&&n)return!1;if(d){const o=typeof d=="object"?d.id:d;if(n===o||n===`Folder.${o}`||`Folder.${n}`===o)continue;return!1}continue}let r;if(!i.includes(".")&&e.item&&e.item[i]!==void 0)r=e.item[i];else{const d=i.split(".");let o=e;for(const l of d){if(o==null){r=void 0;break}o=o[l]}r=o}if(r===void 0||typeof r=="string"&&r.toLowerCase()!==n.toLowerCase())return!1}return!0}const router$6=new Router("searchRouter");router$6.addRoute({actionType:"search",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received search request:",e);try{if(!window.QuickInsert){ModuleLogger.error("QuickInsert not available"),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert not available",results:[]});return}if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(n=>setTimeout(n,500))}catch(n){ModuleLogger.error("Failed to force QuickInsert index:",n),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert index not ready",results:[]});return}}let u=null;if(e.filter){const n=typeof e.filter=="string"?parseFilterString(e.filter):e.filter;u=r=>matchesAllFilters(r,n)}const i=await window.QuickInsert.search(e.query,u,200);ModuleLogger.info(`Search returned ${i.length} results`),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,filter:e.filter,results:i.map(n=>{var d;const r=n.item;return{documentType:r.documentType,folder:r.folder,id:r.id,name:r.name,package:r.package,packageName:r.packageName,subType:r.subType,uuid:r.uuid,icon:r.icon,journalLink:r.journalLink,tagline:r.tagline||"",formattedMatch:n.formattedMatch||"",resultType:(d=r.constructor)==null?void 0:d.name}})})}catch(u){ModuleLogger.error("Error performing search:",u),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:u.message,results:[]})}}});const router$5=new Router("structureRouter");router$5.addRoute({actionType:"structure",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received structure request with params:",e);try{const n=e.includeEntityData??!1,r=e.path||null,d=e.recursive??!1,o=e.recursiveDepth??5,l=e.type?Array.isArray(e.types)?e.types:[e.types]:["Scene","Actor","Item","JournalEntry","RollTable","Cards","Macro","Playlist"],c={Scene:game.scenes,Actor:game.actors,Item:game.items,JournalEntry:game.journal,RollTable:game.tables,Cards:game.cards,Macro:game.macros,Playlist:game.playlists},a=p=>n?p.toObject(!1):{uuid:p.uuid,name:p.name,id:p.id,type:p.documentName},y=(p,m=0)=>{var I;if(!d||m>=o)return{};const f={},w=(((I=game.folders)==null?void 0:I.contents)||[]).filter(E=>{var v;return((v=E.folder)==null?void 0:v.id)===(p==null?void 0:p.id)&&l.includes(E.type)});for(const E of w){const v=E.name||E.id;f[v]={id:E.id,uuid:E.uuid,type:E.type,...y(E,m+1)};const L=E.contents.filter(R=>l.includes(R.documentName)).map(a);L.length>0&&(f[v].entities=L)}return f};let h={};if(r&&r.startsWith("Compendium.")){const p=game.packs.get(r.replace("Compendium.",""));if(!p)throw new Error(`Compendium not found: ${r}`);const f=(await p.getIndex()).contents.map(g=>n?{...g}:{uuid:g.uuid||`${p.collection}.${g._id}`,name:g.name,id:g._id,type:p.documentName});h={compendium:{name:p.title,type:p.documentName,entities:f}}}else if(r&&r.startsWith("Folder.")){const p=r.match(/Folder\.([a-zA-Z0-9]+)/);if(!p)throw new Error(`Invalid folder path: ${r}`);const m=p[1],f=(u=game.folders)==null?void 0:u.get(m);if(!f)throw new Error(`Folder not found: ${r}`);if(!l.includes(f.type))throw new Error(`Folder type ${f.type} not included in requested types`);h.folders=y(f);const g=f.contents.filter(w=>l.includes(w.documentName)).map(a);g.length>0&&(h.entities=g)}else{if(d)h.folders=y(null);else{const m=((i=game.folders)==null?void 0:i.contents)||[];h.folders={};for(const f of l){const g=m.filter(w=>w.type===f&&!w.folder);for(const w of g){const I=w.name||w.id;if(h.folders[I]={id:w.id,uuid:w.uuid,type:w.type},n||!d){const E=w.contents.filter(v=>l.includes(v.documentName)).map(a);E.length>0&&(h.folders[I].entities=E)}}}}const p={};for(const m of l){const f=c[m];if(f){const g=f.filter(w=>!w.folder).map(a);g.length>0&&(p[m.toLowerCase()+"s"]=g)}}if(Object.keys(p).length>0&&(h.entities=p),!r){const m={};for(const f of game.packs.contents)if(l.includes(f.documentName)){const g=f.title||f.collection;m[g]={id:f.collection,name:f.title,type:f.documentName,uuid:`Compendium.${f.collection}`};try{const I=(await f.getIndex()).contents.map(E=>n?{...E}:{uuid:E.uuid||`${f.collection}.${E._id}`,name:E.name,id:E._id,type:f.documentName});I.length>0&&(m[g].entities=I)}catch(w){ModuleLogger.warn(`Failed to load entities for compendium ${f.collection}:`,w)}}Object.keys(m).length>0&&(h.compendiumPacks=m)}}t==null||t.send({type:"structure-result",requestId:e.requestId,data:h})}catch(n){ModuleLogger.error("Error getting structure:",n),t==null||t.send({type:"structure-result",requestId:e.requestId,error:n.message,data:{}})}}});router$5.addRoute({actionType:"get-folder",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received get-folder request for name: ${e.name}`);try{const r=(((u=game.folders)==null?void 0:u.contents)||[]).find(o=>o.name===e.name);if(!r)throw new Error(`Folder not found with name: ${e.name}`);const d=r.contents.map(o=>({uuid:o.uuid,id:o.id,name:o.name,type:o.documentName,img:"img"in o?o.img:null}));t==null||t.send({type:"get-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((i=r.folder)==null?void 0:i.id)||null,contents:d}})}catch(n){ModuleLogger.error("Error getting folder:",n),t==null||t.send({type:"get-folder-result",requestId:e.requestId,error:n.message,data:null})}}});router$5.addRoute({actionType:"create-folder",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received create-folder request:",e);try{const n={name:e.name,type:e.folderType};if(e.parentFolderId){if(!((u=game.folders)==null?void 0:u.get(e.parentFolderId)))throw new Error(`Parent folder not found with ID: ${e.parentFolderId}`);n.folder=e.parentFolderId}const r=await Folder.create(n);t==null||t.send({type:"create-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((i=r.folder)==null?void 0:i.id)||null}})}catch(n){ModuleLogger.error("Error creating folder:",n),t==null||t.send({type:"create-folder-result",requestId:e.requestId,error:n.message,data:null})}}});router$5.addRoute({actionType:"delete-folder",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received delete-folder request:",e);try{const n=(u=game.folders)==null?void 0:u.get(e.folderId);if(!n)throw new Error(`Folder not found with ID: ${e.folderId}`);const r=e.deleteAll??!1;let d=0,o=0;const l=async c=>{var f;let a=0,y=0;const p=(((f=game.folders)==null?void 0:f.contents)||[]).filter(g=>{var w;return((w=g.folder)==null?void 0:w.id)===c.id});for(const g of p){const w=await l(g);a+=w.entities,y+=w.folders}const m=c.contents;a+=m.length;for(const g of m)await g.delete();return await c.delete(),y+=1,{entities:a,folders:y}};if(r){const c=await l(n);d=c.entities,o=c.folders}else{const a=(((i=game.folders)==null?void 0:i.contents)||[]).filter(y=>{var h;return((h=y.folder)==null?void 0:h.id)===n.id});if(n.contents.length>0)throw new Error(`Folder contains ${n.contents.length} entities. Use deleteAll=true to delete them or move them first.`);if(a.length>0)throw new Error(`Folder contains ${a.length} child folders. Use deleteAll=true to delete them or move them first.`);await n.delete(),o=1}t==null||t.send({type:"delete-folder-result",requestId:e.requestId,data:{deleted:!0,folderId:e.folderId,entitiesDeleted:d,foldersDeleted:o}})}catch(n){ModuleLogger.error("Error deleting folder:",n),t==null||t.send({type:"delete-folder-result",requestId:e.requestId,error:n.message,data:null})}}});router$5.addRoute({actionType:"contents",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received contents request for path: ${e.path}`);try{let i=[];if(e.path.startsWith("Compendium.")){const n=game.packs.get(e.path.replace("Compendium.",""));if(!n)throw new Error(`Compendium not found: ${e.path}`);i=(await n.getIndex()).contents.map(d=>({...d}))}else{const n=e.path.match(/Folder\.([a-zA-Z0-9]+)/);if(!n)throw new Error(`Invalid folder path: ${e.path}`);const r=n[1],d=(u=game.folders)==null?void 0:u.get(r);if(!d)throw new Error(`Folder not found: ${e.path}`);i=d.contents.map(o=>({uuid:o.uuid,id:o.id,name:o.name,img:"img"in o?o.img:null,type:o.documentName}))}t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,entities:i})}catch(i){ModuleLogger.error("Error getting contents:",i),t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,error:i.message,entities:[]})}}});function getFoundryVersion(){return game.version}function getFoundryVersionMajor(){return parseInt(getFoundryVersion().split(".")[0],10)}const router$4=new Router("sheetRouter");router$4.addRoute({actionType:"get-sheet",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;if(ModuleLogger.info(`Received sheet request for UUID: ${e.uuid}`),getFoundryVersionMajor()>12){ModuleLogger.error(`Foundry version ${getFoundryVersionMajor()} does not support this endpoint`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"This endpoint is only supported in Foundry VTT version 12"}});return}try{let n=null;if(e.uuid)n=await fromUuid(e.uuid);else if(e.selected){const d=(u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled;d&&d.length>0&&(e.actor?n=d[0].actor:n=d[0].document)}if(!n){ModuleLogger.error(`Entity not found for UUID: ${e.uuid}`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Entity not found",uuid:e.uuid}});return}const r=(i=n.sheet)==null?void 0:i.render(!0);setTimeout(async()=>{try{let d=function(T){T.classList&&T.classList.length&&T.classList.forEach(b=>p.add(b)),T.id&&m.add(T.id);for(let b=0;b<T.children.length;b++)d(T.children[b])};if(!r.element||!r.element[0])throw new Error("Failed to render actor sheet");let o=r.element[0].outerHTML,l="";const c=String(r.appId);document.querySelectorAll("style[data-appid]").forEach(T=>{T.dataset.appid===c&&(l+=T.textContent+`
`)}),document.querySelectorAll(`style[id^="system-${n.type}"]`).forEach(T=>{l+=T.textContent+`
`});const h=document.createElement("div");h.innerHTML=o;const p=new Set,m=new Set;d(h);const f=Array.from(p),g=Array.from(m);ModuleLogger.debug(`Extracted ${f.length} unique classes and ${g.length} unique IDs`);const w=document.querySelectorAll("style"),I=document.querySelectorAll('link[rel="stylesheet"]');w.forEach(T=>{if(T.dataset.appid&&T.dataset.appid===c)return;const b=T.textContent||"";(f.some(S=>b.includes(`.${S}`))||g.some(S=>b.includes(`#${S}`))||b.includes(".window-app")||b.includes(".sheet")||b.includes(".actor-sheet")||b.includes(`.${n.type}-sheet`))&&(ModuleLogger.debug("Adding relevant inline style"),l+=b+`
`)});const E=Array.from(I).map(async T=>{try{const b=T.getAttribute("href");if(!b||b.includes("fonts.googleapis.com"))return"";ModuleLogger.debug(`Fetching external CSS from: ${b}`);const k=b.startsWith("http")?b:b.startsWith("/")?`${window.location.origin}${b}`:`${window.location.origin}/${b}`,S=await fetch(k);return S.ok?await S.text():(ModuleLogger.warn(`Failed to fetch CSS: ${k}, status: ${S.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch external CSS: ${b}`),""}}),v=window.location.origin;ModuleLogger.debug(`Base URL for fetching CSS: ${v}`);const L=[`${v}/css/style.css`,`${v}/styles/style.css`,`${v}/styles/foundry.css`,`${v}/ui/sheets.css`,`${v}/game/styles/foundry.css`,`${v}/game/ui/sheets.css`,`${v}/systems/${game.system.id}/system.css`,`${v}/systems/${game.system.id}/styles/system.css`,`${v}/game/systems/${game.system.id}/system.css`,`${v}/game/systems/${game.system.id}/styles/system.css`];ModuleLogger.debug("All stylesheet links in document:",Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(Boolean));const R=Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(T=>T!==null&&!T.includes("fonts.googleapis.com")&&!T.includes("//"));L.push(...R),ModuleLogger.debug("All style elements in document:",document.querySelectorAll("style").length);const N=L.map(async T=>{try{ModuleLogger.debug(`Fetching core CSS from: ${T}`);const b=await fetch(T);return b.ok?(ModuleLogger.info(`Successfully loaded CSS from: ${T}`),await b.text()):(ModuleLogger.warn(`Failed to fetch CSS: ${T}, status: ${b.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch core CSS: ${b}`),""}}),A=[...E,...N];(await Promise.all(A)).forEach(T=>{l+=T+`
`}),l.length<100&&(ModuleLogger.warn("CSS fetch failed or returned minimal content. Adding fallback styles."),l+=`
              .window-app {
                font-family: "Signika", sans-serif;
                background: #f0f0e0;
                border-radius: 5px;
                box-shadow: 0 0 20px #000;
                color: #191813;
              }
              .window-content {
                background: rgba(255, 255, 240, 0.9);
                padding: 8px;
                overflow-y: auto;
                background: url(${window.location.origin}/ui/parchment.jpg) repeat;
              }
              input, select, textarea {
                border: 1px solid #7a7971;
                background: rgba(255, 255, 255, 0.8);
              }
              button {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid #7a7971;
                border-radius: 3px;
                cursor: pointer;
              }
              .profile-img {
                border: none;
                max-width: 100%;
                max-height: 220px;
              }
            `),ModuleLogger.debug(`Collected CSS: ${l.length} bytes`),o=o.replace(/src="([^"]+)"/g,(T,b)=>b.startsWith("http")?T:b.startsWith("/")?`src="${window.location.origin}${b}"`:`src="${window.location.origin}/${b}"`),l=l.replace(/url\(['"]?([^'")]+)['"]?\)/g,(T,b)=>b.startsWith("http")||b.startsWith("data:")?T:b.startsWith("/")?`url('${window.location.origin}${b}')`:`url('${window.location.origin}/${b}')`),r.close(),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{html:o,css:l,uuid:e.uuid}}),ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${e.requestId}`),ModuleLogger.debug(`HTML length: ${o.length}, CSS length: ${l.length}`)}catch(d){ModuleLogger.error("Error capturing actor sheet HTML:",d),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to capture actor sheet HTML",uuid:e.uuid}}),r&&typeof r.close=="function"&&r.close()}},500)}catch(n){ModuleLogger.error("Error rendering actor sheet:",n),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to render actor sheet",uuid:e.uuid}})}}});const router$3=new Router("macroRouter");router$3.addRoute({actionType:"macros",handler:async(e,s)=>{var u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for macros");try{const i=((u=game.macros)==null?void 0:u.contents.map(n=>{var r,d;return{uuid:n.uuid,id:n.id,name:n.name,type:n.type||((r=n.data)==null?void 0:r.type)||"unknown",author:((d=n.author)==null?void 0:d.name)||"unknown",command:n.command||"",img:n.img,scope:n.scope,canExecute:n.canExecute}}))||[];t==null||t.send({type:"macros-result",requestId:e.requestId,macros:i})}catch(i){ModuleLogger.error("Error getting macros list:",i),t==null||t.send({type:"macros-result",requestId:e.requestId,error:i.message,macros:[]})}}});router$3.addRoute({actionType:"macro-execute",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to execute macro: ${e.uuid}`);try{if(!e.uuid)throw new Error("Macro UUID is required");const u=await fromUuid(e.uuid);if(!u)throw new Error(`Macro not found with UUID: ${e.uuid}`);if(!(u instanceof CONFIG.Macro.documentClass))throw new Error(`Entity with UUID ${e.uuid} is not a macro`);if(!u.canExecute)throw new Error(`Macro '${u.name}' cannot be executed by the current user`);const i=e.args||{};let n;typeof i=="object"?n=await u.execute({args:i}):n=await u.execute(),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid,success:!0,result:typeof n=="object"?n:{value:n}})}catch(u){ModuleLogger.error("Error executing macro:",u),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid||"",success:!1,error:u.message})}}});const router$2=new Router("utilityRouter");router$2.addRoute({actionType:"execute-js",handler:async(data,context)=>{const socketManager=context==null?void 0:context.socketManager;ModuleLogger.info("Received execute-js request:",data);try{const{script,requestId}=data;if(!script||typeof script!="string")throw new Error("Invalid script provided");let result;try{result=await(async()=>eval(`(async () => { ${script} })()`))()}catch(e){const s=e instanceof Error?e.message:String(e);throw new Error(`Error executing script: ${s}`)}socketManager==null||socketManager.send({type:"execute-js-result",requestId,success:!0,result})}catch(e){ModuleLogger.error("Error in execute-js handler:",e),socketManager==null||socketManager.send({type:"execute-js-result",requestId:data.requestId,success:!1,error:e.message})}}});router$2.addRoute({actionType:"select",handler:async(e,s)=>{var u,i,n,r,d,o,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received select entities request:",e);try{const c=(u=game.scenes)==null?void 0:u.active;if(!c)throw new Error("No active scene found");e.overwrite&&((i=canvas==null?void 0:canvas.tokens)==null||i.releaseAll());const a=new Set;e.all&&(((n=c.tokens)==null?void 0:n.contents)||[]).forEach(m=>a.add(m)),e.uuids&&Array.isArray(e.uuids)&&(((r=c.tokens)==null?void 0:r.filter(m=>e.uuids.includes(m.uuid)))||[]).forEach(m=>a.add(m)),e.name&&(((d=c.tokens)==null?void 0:d.filter(m=>{var f,g;return((f=m.name)==null?void 0:f.toLowerCase())===((g=e.name)==null?void 0:g.toLowerCase())}))||[]).forEach(m=>a.add(m)),e.data&&(((o=c.tokens)==null?void 0:o.filter(m=>Object.entries(e.data).every(([f,g])=>{if(f.startsWith("actor.")&&m.actor){const I=f.replace("actor.","");return getProperty(m.actor,I)===g}const w=m.toObject();return getProperty(w,f)===g})))||[]).forEach(m=>a.add(m));const y=Array.from(a);if(y.length===0)throw new Error("No matching entities found");for(const p of y){const m=p.id?(l=canvas==null?void 0:canvas.tokens)==null?void 0:l.get(p.id):null;m&&m.control({releaseOthers:!1})}const h=y.map(p=>p.uuid);t==null||t.send({type:"select-result",requestId:e.requestId,success:!0,count:y.length,message:`${y.length} entities selected`,selected:h})}catch(c){ModuleLogger.error("Error selecting entities:",c),t==null||t.send({type:"select-result",requestId:e.requestId,success:!1,error:c.message})}}});router$2.addRoute({actionType:"selected",handler:async(e,s)=>{var u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get selected entities request:",e);try{if(!((u=game.scenes)==null?void 0:u.active))throw new Error("No active scene found");const d=(((i=canvas==null?void 0:canvas.tokens)==null?void 0:i.controlled)||[]).map(o=>{var l;return{tokenUuid:o.document.uuid,actorUuid:((l=o.actor)==null?void 0:l.uuid)||null}});t==null||t.send({type:"selected-result",requestId:e.requestId,success:!0,selected:d})}catch(n){ModuleLogger.error("Error getting selected entities:",n),t==null||t.send({type:"selected-result",requestId:e.requestId,success:!1,error:n.message})}}});const router$1=new Router("fileSystemRouter");router$1.addRoute({actionType:"file-system",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get file system request:",e);try{const u=e.path||"",i=e.source||"data",n=!!e.recursive,r=await FilePicker.browse(i,u),d=Array.isArray(r.dirs)?r.dirs.map(a=>({name:a.split("/").pop()||a,path:a,type:"directory"})):[],o=Array.isArray(r.files)?r.files.map(a=>({name:a.split("/").pop()||a,path:a,type:"file"})):[];let l=[];if(n&&d.length>0)for(const a of d)try{const y=await FilePicker.browse(i,a.path),h=Array.isArray(y.dirs)?y.dirs.map(m=>({name:m.split("/").pop()||m,path:m,type:"directory"})):[],p=Array.isArray(y.files)?y.files.map(m=>({name:m.split("/").pop()||m,path:m,type:"file"})):[];if(l=l.concat(h,p),n===!0&&h.length>0&&a.path.split("/").length<3)for(const m of h)try{const f=await FilePicker.browse(i,m.path),g=Array.isArray(f.dirs)?f.dirs.map(I=>({name:I.split("/").pop()||I,path:I,type:"directory"})):[],w=Array.isArray(f.files)?f.files.map(I=>({name:I.split("/").pop()||I,path:I,type:"file"})):[];l=l.concat(g,w)}catch(f){ModuleLogger.error(`Error processing deep subdirectory ${m.path}:`,f)}}catch(y){ModuleLogger.error(`Error processing subdirectory ${a.path}:`,y)}const c=[...d,...o];n&&c.push(...l),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!0,path:u,source:i,results:c,recursive:n})}catch(u){ModuleLogger.error("Error getting file system:",u),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!1,error:u.message})}}});router$1.addRoute({actionType:"upload-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received upload file request:",e);try{const{path:u,filename:i,source:n,fileData:r,mimeType:d,binaryData:o,overwrite:l}=e;if(!u||!i)throw new Error("Missing required parameters (path, filename)");let c;if(o){if(!Array.isArray(o)||o.length===0)throw new Error("Invalid binary data: must be non-empty array");const m=new Uint8Array(o),f=new Blob([m],{type:d||"application/octet-stream"});c=new File([f],i,{type:d||"application/octet-stream"}),ModuleLogger.info(`Created file from binary data: ${m.length} bytes`)}else if(r){if(!r.includes(",")||!r.startsWith("data:"))throw new Error("Invalid file data format: must be data URL with base64 content");const m=r.split(",")[1];if(!m)throw new Error("No base64 data found in file data");let f;try{f=atob(m)}catch(I){throw new Error(`Invalid base64 data: ${I.message}`)}if(f.length===0)throw new Error("Decoded file data is empty");const g=new Uint8Array(f.length);for(let I=0;I<f.length;I++)g[I]=f.charCodeAt(I);const w=new Blob([g],{type:d||"application/octet-stream"});c=new File([w],i,{type:d||"application/octet-stream"}),ModuleLogger.info(`Created file from base64 data: ${g.length} bytes`)}else throw new Error("Missing file data (either binaryData or fileData is required)");const a=n||"data";if(u&&u!=="/"&&u!=="")try{const m=u.split("/").filter(g=>g.length>0);let f="";for(const g of m){f=f?`${f}/${g}`:g;try{await FilePicker.createDirectory(a,f),ModuleLogger.info(`Created/verified directory: ${f}`)}catch(w){const I=w.message||String(w);if(!I.includes("already exists"))throw ModuleLogger.error(`Error creating directory ${f}:`,w),new Error(`Could not create directory '${f}': ${I}`)}}}catch(m){throw ModuleLogger.error(`Error creating directories for path '${u}':`,m),new Error(`Could not create directory structure: ${m.message}`)}let y=null;try{const m=u&&u!=="/"?`${u}/${i}`:i;y=await FilePicker.browse(a,m)}catch{}if(y&&!l)throw new Error("File already exists. Set overwrite to true to replace it.");const h=await FilePicker.upload(a,u,c);if(!h)throw new Error("FilePicker.upload returned null/undefined result");const p=h&&typeof h=="object"&&"path"in h?h.path:`${u}/${i}`;ModuleLogger.info(`File uploaded successfully: ${p}`),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!0,path:p})}catch(u){ModuleLogger.error("Error uploading file:",u),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!1,error:u.message})}}});router$1.addRoute({actionType:"download-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received download file request:",e);try{const{path:u}=e;if(!u)throw new Error("Missing required parameter (path)");const i=await fetch(u.startsWith("http")?u:foundry.utils.getRoute(u));if(!i.ok)throw new Error(`Failed to download file: ${i.status} ${i.statusText}`);const n=await i.blob(),r=new FileReader,d=await new Promise((o,l)=>{r.onload=()=>o(r.result),r.onerror=l,r.readAsDataURL(n)});t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!0,path:u,fileData:d,filename:u.split("/").pop()||"file",mimeType:n.type})}catch(u){ModuleLogger.error("Error downloading file:",u),t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!1,error:u.message})}}});const router=new Router("dnd5eRouter");Hooks.once("init",()=>{if(game.system.id==="dnd5e"){router.addRoute({actionType:"get-actor-details",handler:async(t,u)=>{const i=u==null?void 0:u.socketManager;ModuleLogger.info("Received get-actor-details request:",t);try{const{actorUuid:n,details:r}=t;if(!n)throw new Error("actorUuid is required");if(!r||!Array.isArray(r)||r.length===0)throw new Error("details array is required and cannot be empty");const d=await fromUuid(n);if(!d)throw new Error(`Actor not found with UUID: ${n}`);const o={uuid:n};r.includes("resources")&&(o.resources=d.system.resources),r.includes("spells")&&(o.spells=d.items.filter(l=>l.type==="spell")),r.includes("items")&&(o.items=d.items.filter(l=>["weapon","equipment","consumable","tool","loot","backpack"].includes(l.type))),r.includes("features")&&(o.features=d.items.filter(l=>["feat","background","class"].includes(l.type))),i==null||i.send({type:"get-actor-details-result",requestId:t.requestId,data:o})}catch(n){ModuleLogger.error("Error in get-actor-details:",n),i==null||i.send({type:"get-actor-details-result",requestId:t.requestId,error:n.message})}}}),router.addRoute({actionType:"modify-item-charges",handler:async(t,u)=>{const i=u==null?void 0:u.socketManager;ModuleLogger.info("Received modify-item-charges request:",t);try{const{actorUuid:n,itemUuid:r,itemName:d,amount:o}=t;if(!n)throw new Error("actorUuid is required");if(!r&&!d)throw new Error("itemUuid or itemName is required");if(typeof o!="number")throw new Error("amount must be a number");const l=await fromUuid(n);if(!l)throw new Error(`Actor not found with UUID: ${n}`);let c=null;if(r?c=l.items.get(r.split(".").pop()):d&&(c=l.items.find(w=>w.name.toLowerCase()===d.toLowerCase())),!c)throw new Error(`Item not found on actor ${l.name}`);const a=c.system.uses||{},y=a.spent||0,h=a.value??a.max??0,p=a.max||0,m=Math.max(0,Math.min(p,y-o)),f=Math.max(0,Math.min(p,h+o)),g={system:{...c.system,uses:{...c.system.uses,spent:m,value:f}}};await c.update(g),i==null||i.send({type:"modify-item-charges-result",requestId:t.requestId,data:{itemUuid:c.uuid,oldCharges:h,newCharges:f}})}catch(n){ModuleLogger.error("Error in modify-item-charges:",n),i==null||i.send({type:"modify-item-charges-result",requestId:t.requestId,error:n.message})}}});const s=async(t,u,i)=>{var d,o,l;const n=u==null?void 0:u.socketManager,r=i?`use-${i}`:"use-ability";ModuleLogger.info(`Received ${r} request:`,t);try{const{actorUuid:c,abilityUuid:a,abilityName:y,targetUuid:h}=t;if(!c)throw new Error("actorUuid is required");if(!a&&!y)throw new Error("abilityUuid or abilityName is required");const p=await fromUuid(c);if(!p)throw new Error(`Actor not found with UUID: ${c}`);let m=null;if(a?m=await fromUuid(a):y&&(m=p.items.find(I=>I.name.toLowerCase()===y.toLowerCase()?i?i==="item"?I.type!=="feat"&&I.type!=="spell":I.type===i:!0:!1)),!m)throw new Error(`Ability not found on actor ${p.name}`);let f=null;if(h){const w=await fromUuid(h);if(w&&w.documentName==="Token")f=w;else if(w&&w.documentName==="Actor"){const I=(d=game.scenes)==null?void 0:d.active;if(I){const E=(o=I.tokens)==null?void 0:o.filter(v=>{var L;return((L=v.actor)==null?void 0:L.id)===w.id});E&&E.length>0&&(f=E[0])}}if(f&&(canvas!=null&&canvas.tokens)){(l=game.user)==null||l.targets.forEach(E=>E.setTarget(!1,{releaseOthers:!1}));const I=canvas.tokens.get(f.id);I&&I.setTarget(!0,{releaseOthers:!0})}}const g=await m.use();n==null||n.send({type:`${r}-result`,requestId:t.requestId,data:{uuid:c,ability:m.name,result:g?g.id:null}})}catch(c){ModuleLogger.error(`Error in ${r}:`,c),n==null||n.send({type:`${r}-result`,requestId:t.requestId,error:c.message})}};router.addRoute({actionType:"use-ability",handler:(t,u)=>s(t,u,null)}),router.addRoute({actionType:"use-feature",handler:(t,u)=>s(t,u,"feat")}),router.addRoute({actionType:"use-spell",handler:(t,u)=>s(t,u,"spell")}),router.addRoute({actionType:"use-item",handler:(t,u)=>s(t,u,"item")}),router.addRoute({actionType:"modify-experience",handler:async(t,u)=>{var n;const i=u==null?void 0:u.socketManager;ModuleLogger.info("Received modify-experience request:",t);try{const{actorUuid:r,selected:d,amount:o}=t;if(!r&&!d)throw new Error("Either actorUuid or selected must be provided");if(typeof o!="number")throw new Error("amount must be a number");let l=null;if(r)l=await fromUuid(r);else if(d){const y=(n=canvas.tokens)==null?void 0:n.controlled;if(!y||y.length===0)throw new Error("No token selected");y.length>1&&ModuleLogger.warn("Multiple tokens selected, using the first one."),l=y[0].actor}if(!l)throw new Error("Actor not found");const c=l.system.details.xp.value,a=c+o;await l.update({"system.details.xp.value":a}),i==null||i.send({type:"modify-experience-result",requestId:t.requestId,data:{actorUuid:l.uuid,oldXp:c,newXp:a}})}catch(r){ModuleLogger.error("Error in modify-experience:",r),i==null||i.send({type:"modify-experience-result",requestId:t.requestId,error:r.message})}}})}});const routers=[router$a,router$9,router$8,router$7,router$6,router$5,router$4,router$3,router$2,router$1,router];function initializeWebSocket(){const e=game.settings.get(moduleId,"wsRelayUrl"),s=game.settings.get(moduleId,"apiKey"),t=game.modules.get(moduleId);if(!e){ModuleLogger.error("WebSocket relay URL is empty. Please configure it in module settings.");return}ModuleLogger.info(`Initializing WebSocket with URL: ${e}`);try{if(t.socketManager?ModuleLogger.info("WebSocket manager already exists, not creating a new one"):(t.socketManager=WebSocketManager.getInstance(e,s),t.socketManager&&t.socketManager.connect()),!t.socketManager){ModuleLogger.warn("No WebSocket manager available, skipping message handler setup");return}const u=t.socketManager;routers.forEach(i=>{i.reflect(u)}),ModuleLogger.info(`Registered ${routers.length} routers with WebSocket manager`)}catch(u){ModuleLogger.error("Error initializing WebSocket:",u)}}Hooks.once("init",()=>{console.log(`Initializing ${moduleId}`);for(let[s,t]of Object.entries(SETTINGS.GET_DEFAULT()))game.settings.register(CONSTANTS.MODULE_ID,s,t);const e=game.modules.get(moduleId);e.api={getWebSocketManager:()=>e.socketManager?e.socketManager:(ModuleLogger.warn("WebSocketManager requested but not initialized"),null),search:async(s,t)=>{if(!window.QuickInsert)return ModuleLogger.error("QuickInsert not available"),[];if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(i=>setTimeout(i,500))}catch(i){ModuleLogger.error("Failed to force QuickInsert index:",i)}}let u=null;return t&&(u=i=>i.documentType===t),window.QuickInsert.search(s,u,100)},getByUuid:async s=>{try{return await fromUuid(s)}catch(t){return ModuleLogger.error("Error getting entity by UUID:",t),null}}}});Hooks.on("renderSettingsConfig",(e,s)=>{const t=s instanceof HTMLElement?$(s):s,u=t.find(`input[name="${moduleId}.apiKey"]`);if(u.length){u.attr("type","password");const n=$('<button type="button" style="margin-left: 10px;"><i class="fas fa-info-circle"></i> Show Client Info</button>');u.after(n),n.on("click",()=>{const d=game.modules.get(moduleId).api.getWebSocketManager();if(d){const o=d.getClientId(),l=game.world.id,c=game.world.title,a=game.version,y=game.system.id,h=game.system.title||game.system.id,p=game.system.version||"unknown",m=game.settings.get(moduleId,"customName");new Dialog({title:"Client Information",content:`
            <div class="form-group">
                <label>Client ID</label>
                <div class="form-fields">
                    <input type="text" value="${o}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World ID</label>
                <div class="form-fields">
                    <input type="text" value="${l}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World Title</label>
                <div class="form-fields">
                    <input type="text" value="${c}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Foundry Version</label>
                <div class="form-fields">
                    <input type="text" value="${a}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System ID</label>
                <div class="form-fields">
                    <input type="text" value="${y}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Title</label>
                <div class="form-fields">
                    <input type="text" value="${h}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Version</label>
                <div class="form-fields">
                    <input type="text" value="${p}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Custom Name</label>
                <div class="form-fields">
                    <input type="text" value="${m}" readonly>
                </div>
            </div>
            <p class="notes">Click any field to copy its value.</p>
          `,buttons:{ok:{label:"OK"}},render:f=>{const w=(f instanceof HTMLElement?$(f):f).find('input[type="text"]');w.css("cursor","pointer"),w.on("click",I=>{const E=I.currentTarget;navigator.clipboard.writeText(E.value).then(()=>{ui.notifications.info("Copied to clipboard."),E.select()})})}}).render(!0)}else ui.notifications.warn("WebSocketManager is not available.")}),u.on("change",r=>{const d=r.target.value;game.settings.set(moduleId,"apiKey",d).then(()=>{new Dialog({title:"Reload Required",content:"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})}const i=t.find(`input[name="${moduleId}.customName"]`);i.length&&i.on("change",n=>{const r=n.target.value;game.settings.set(moduleId,"customName",r).then(()=>{new Dialog({title:"Reload Required",content:"<p>The Custom Name has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})});Hooks.once("ready",()=>{setTimeout(()=>{initializeWebSocket()},1e3)});Hooks.on("createChatMessage",e=>{var s,t,u,i,n,r;if(e.isRoll&&((s=e.rolls)==null?void 0:s.length)>0){ModuleLogger.info(`Detected dice roll from ${((t=e.user)==null?void 0:t.name)||"unknown"}`);const d=e.id,o={id:d,messageId:e.id,user:{id:(u=e.user)==null?void 0:u.id,name:(i=e.user)==null?void 0:i.name},speaker:e.speaker,flavor:e.flavor||"",rollTotal:e.rolls[0].total,formula:e.rolls[0].formula,isCritical:e.rolls[0].isCritical||!1,isFumble:e.rolls[0].isFumble||!1,dice:(n=e.rolls[0].dice)==null?void 0:n.map(a=>({faces:a.faces,results:a.results.map(y=>({result:y.result,active:y.active}))})),timestamp:Date.now()},l=recentRolls.findIndex(a=>a.id===d);l!==-1?recentRolls[l]=o:(recentRolls.unshift(o),recentRolls.length>MAX_ROLLS_STORED&&(recentRolls.length=MAX_ROLLS_STORED));const c=game.modules.get(moduleId);(r=c.socketManager)!=null&&r.isConnected()&&c.socketManager.send({type:"roll-data",data:o})}});
//# sourceMappingURL=module.js.map
