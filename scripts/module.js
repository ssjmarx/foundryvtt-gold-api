var A=Object.defineProperty;var U=(e,s,t)=>s in e?A(e,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[s]=t;var q=(e,s,t)=>U(e,typeof s!="symbol"?s+"":s,t);const id="foundryvtt-gold-api";class dnd5e{constructor(){q(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}class a5e{constructor(){q(this,"ACTOR_CURRENCY_ATTRIBUTE","system.currency")}}const SYSTEMS={SUPPORTED_SYSTEMS:{dnd5e:{latest:dnd5e},a5e:{latest:a5e}},DEFAULT_SETTINGS:{ACTOR_CURRENCY_ATTRIBUTE:""},_currentSystem:!1,get DATA(){var n;if(this._currentSystem)return this._currentSystem;const e=(n=this.SUPPORTED_SYSTEMS)==null?void 0:n[game.system.id.toLowerCase()];if(!e)return this.DEFAULT_SETTINGS;if(e[game.system.version])return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[game.system.version]),this._currentSystem;const s=Object.keys(e);if(s.length===1)return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[s[0]]),this._currentSystem;s.sort((u,i)=>u==="latest"||i==="latest"?-1/0:isNewerVersion(i,u)?-1:1);const t=s.find(u=>u==="latest"||!isNewerVersion(game.system.version,u));return this._currentSystem=foundry.utils.mergeObject(this.DEFAULT_SETTINGS,e[t]),this._currentSystem}},CONSTANTS={MODULE_ID:id},moduleId=id,recentRolls=[],MAX_ROLLS_STORED=20,SETTINGS={ACTOR_CURRENCY_ATTRIBUTE:"actorCurrencyAttribute",WS_RELAY_URL:"wsRelayUrl",API_KEY:"apiKey",CUSTOM_NAME:"customName",LOG_LEVEL:"logLevel",PING_INTERVAL:"pingInterval",RECONNECT_MAX_ATTEMPTS:"reconnectMaxAttempts",RECONNECT_BASE_DELAY:"reconnectBaseDelay",SYSTEM_FOUND:"systemFound",SYSTEM_NOT_FOUND_WARNING_SHOWN:"systemNotFoundWarningShown",SYSTEM_VERSION:"systemVersion",GET_DEFAULT(){return foundry.utils.deepClone(SETTINGS.DEFAULTS())},GET_SYSTEM_DEFAULTS(){return Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).filter(e=>e[1].system))},DEFAULTS:()=>({[SETTINGS.ACTOR_CURRENCY_ATTRIBUTE]:{name:"Actor Currency attribute",hint:"Reference path to the actor currency attribute",scope:"world",config:!1,system:!0,default:SYSTEMS.DATA.ACTOR_CURRENCY_ATTRIBUTE,type:String},[SETTINGS.SYSTEM_VERSION]:{scope:"world",config:!1,default:"0.0.0",type:String},[SETTINGS.SYSTEM_FOUND]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN]:{scope:"world",config:!1,default:!1,type:Boolean},[SETTINGS.WS_RELAY_URL]:{name:"WebSocket Relay URL",hint:"URL for the WebSocket relay server",scope:"world",config:!0,type:String,default:"http://localhost:3010",requiresReload:!0},[SETTINGS.API_KEY]:{name:"API Key",hint:"API Key for authentication with the relay server",scope:"world",config:!0,type:String,default:game.world.id,requiresReload:!0},[SETTINGS.CUSTOM_NAME]:{name:"Custom Client Name",hint:"A custom name to identify this client (optional)",scope:"world",config:!0,type:String,default:"",requiresReload:!0},[SETTINGS.LOG_LEVEL]:{name:"Log Level",hint:"Set the level of detail for module logging",scope:"world",config:!0,type:Number,choices:{0:"debug",1:"info",2:"warn",3:"error"},default:2},[SETTINGS.PING_INTERVAL]:{name:"Ping Interval (seconds)",hint:"How often (in seconds) the module sends a ping to the relay server to keep the connection alive.",scope:"world",config:!0,type:Number,default:30,range:{min:5,max:600,step:1},requiresReload:!0},[SETTINGS.RECONNECT_MAX_ATTEMPTS]:{name:"Max Reconnect Attempts",hint:"Maximum number of times the module will try to reconnect after losing connection.",scope:"world",config:!0,type:Number,default:20,requiresReload:!0},[SETTINGS.RECONNECT_BASE_DELAY]:{name:"Reconnect Base Delay (ms)",hint:"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.",scope:"world",config:!0,type:Number,default:1e3,requiresReload:!0}})};class ModuleLogger{static debugLevel(){return game.settings.get(moduleId,"logLevel")}static debug(s,...t){return this.debugLevel()<1&&console.log(`${moduleId} | ${s}`,...t),s}static info(s,...t){return this.debugLevel()<2&&console.log(`${moduleId} | ${s}`,...t),s}static warn(s,...t){return this.debugLevel()<3&&console.warn(`${moduleId} | ${s}`,...t),s}static error(s,...t){return this.debugLevel()<4&&console.error(`${moduleId} | ${s}`,...t),s}}var WSCloseCodes=(e=>(e[e.Normal=1e3]="Normal",e[e.NoClientId=4001]="NoClientId",e[e.NoAuth=4002]="NoAuth",e[e.NoConnectedGuild=4003]="NoConnectedGuild",e[e.InternalError=4e3]="InternalError",e[e.DuplicateConnection=4004]="DuplicateConnection",e[e.ServerShutdown=4005]="ServerShutdown",e))(WSCloseCodes||{});const S=class S{constructor(s,t){q(this,"url");q(this,"token");q(this,"socket",null);q(this,"messageHandlers",new Map);q(this,"reconnectTimer",null);q(this,"reconnectAttempts",0);q(this,"clientId");q(this,"pingInterval",null);q(this,"isConnecting",!1);q(this,"isPrimaryGM",!1);var n,u,i;this.url=s,this.token=t,this.clientId=`foundry-${((n=game.user)==null?void 0:n.id)||Math.random().toString(36).substring(2,15)}`,this.isPrimaryGM=this.checkIfPrimaryGM(),ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`),(u=game.user)!=null&&u.isGM&&((i=game.user)==null?void 0:i.role)===4&&(Hooks.on("userConnected",this.reevaluatePrimaryGM.bind(this)),Hooks.on("userDisconnected",this.reevaluatePrimaryGM.bind(this)))}static getInstance(s,t){var n,u;return!((n=game.user)!=null&&n.isGM)||((u=game.user)==null?void 0:u.role)!==4?(ModuleLogger.info("WebSocketManager not created - user is not a full GM"),null):(S.instance||(ModuleLogger.info("Creating new WebSocketManager instance"),S.instance=new S(s,t)),S.instance)}checkIfPrimaryGM(){var i,r,d,o,l,a;if(!((i=game.user)!=null&&i.isGM)||((r=game.user)==null?void 0:r.role)!==4)return!1;const s=(d=game.user)==null?void 0:d.id,t=((o=game.users)==null?void 0:o.filter(c=>c.role===4&&c.active))||[];if(t.length===0)return!1;const n=[...t].sort((c,y)=>(c.id||"").localeCompare(y.id||"")),u=((l=n[0])==null?void 0:l.id)===s;return ModuleLogger.info(`Primary GM check - Current user: ${s}, Primary GM: ${(a=n[0])==null?void 0:a.id}, isPrimary: ${u}`),u}reevaluatePrimaryGM(){const s=this.isPrimaryGM;this.isPrimaryGM=this.checkIfPrimaryGM(),s!==this.isPrimaryGM&&(ModuleLogger.info(`Primary GM status changed: ${s} -> ${this.isPrimaryGM}`),this.isPrimaryGM&&!this.isConnected()&&(ModuleLogger.info("Taking over as primary GM, connecting WebSocket"),this.connect()),!this.isPrimaryGM&&this.isConnected()&&(ModuleLogger.info("No longer primary GM, disconnecting WebSocket"),this.disconnect()))}connect(){var s,t;if(!((s=game.user)!=null&&s.isGM)||((t=game.user)==null?void 0:t.role)!==4){ModuleLogger.info("WebSocket connection aborted - user is not a full GM");return}if(!this.isPrimaryGM){ModuleLogger.info("WebSocket connection aborted - user is not the primary GM");return}if(this.isConnecting){ModuleLogger.info("Already attempting to connect");return}if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){ModuleLogger.info("WebSocket already connected or connecting");return}this.isConnecting=!0;try{const n=new URL(this.url);n.searchParams.set("id",this.clientId),n.searchParams.set("token",this.token),game.world&&(n.searchParams.set("worldId",game.world.id),n.searchParams.set("worldTitle",game.world.title)),n.searchParams.set("foundryVersion",game.version),n.searchParams.set("systemId",game.system.id),n.searchParams.set("systemTitle",game.system.title||game.system.id),n.searchParams.set("systemVersion",game.system.version||"unknown");const u=game.settings.get(moduleId,"customName");u&&n.searchParams.set("customName",u),ModuleLogger.info(`Connecting to WebSocket at ${n.toString()}`),this.socket=new WebSocket(n.toString());const i=window.setTimeout(()=>{this.socket&&this.socket.readyState===WebSocket.CONNECTING&&(ModuleLogger.error("Connection timed out"),this.socket.close(),this.socket=null,this.isConnecting=!1,this.scheduleReconnect())},5e3);this.socket.addEventListener("open",r=>{window.clearTimeout(i),this.onOpen(r)}),this.socket.addEventListener("close",r=>{window.clearTimeout(i),this.onClose(r)}),this.socket.addEventListener("error",r=>{window.clearTimeout(i),this.onError(r)}),this.socket.addEventListener("message",this.onMessage.bind(this))}catch(n){ModuleLogger.error("Error creating WebSocket:",n),this.isConnecting=!1,this.scheduleReconnect()}}disconnect(){this.socket&&(ModuleLogger.info("Disconnecting WebSocket"),this.socket.close(WSCloseCodes.Normal,"Disconnecting"),this.socket=null),this.reconnectTimer!==null&&(window.clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),this.reconnectAttempts=0,this.isConnecting=!1}isConnected(){return this.socket!==null&&this.socket.readyState===WebSocket.OPEN}getClientId(){return this.clientId}send(s){var t,n;if(ModuleLogger.info(`Send called, readyState: ${(t=this.socket)==null?void 0:t.readyState}`),this.socket&&this.socket.readyState===WebSocket.OPEN)try{return ModuleLogger.info("Sending message:",s),this.socket.send(JSON.stringify(s)),!0}catch(u){return ModuleLogger.error("Error sending message:",u),!1}else return ModuleLogger.warn(`WebSocket not ready, state: ${(n=this.socket)==null?void 0:n.readyState}`),!1}onMessageType(s,t){this.messageHandlers.set(s,t)}onOpen(s){ModuleLogger.info("WebSocket connected"),this.isConnecting=!1,this.reconnectAttempts=0,this.send({type:"ping"});const t=game.settings.get(moduleId,SETTINGS.PING_INTERVAL),n=t*1e3;ModuleLogger.info(`Starting application ping interval: ${t} seconds`),this.pingInterval!==null&&window.clearInterval(this.pingInterval),this.pingInterval=window.setInterval(()=>{this.isConnected()&&this.send({type:"ping"})},n)}onClose(s){ModuleLogger.info(`WebSocket disconnected: ${s.code} - ${s.reason}`),this.socket=null,this.isConnecting=!1,this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),s.code!==WSCloseCodes.Normal&&this.isPrimaryGM&&this.scheduleReconnect()}onError(s){ModuleLogger.error("WebSocket error:",s),this.isConnecting=!1}async onMessage(s){try{const t=JSON.parse(s.data);ModuleLogger.info("Received message:",t),t.type&&this.messageHandlers.has(t.type)?(ModuleLogger.info(`Handling message of type: ${t.type}`),this.messageHandlers.get(t.type)(t,{socketManager:this})):t.type&&ModuleLogger.warn(`No handler for message type: ${t.type}`)}catch(t){ModuleLogger.error("Error processing message:",t)}}scheduleReconnect(){if(this.reconnectTimer!==null)return;const s=game.settings.get(moduleId,SETTINGS.RECONNECT_MAX_ATTEMPTS),t=game.settings.get(moduleId,SETTINGS.RECONNECT_BASE_DELAY);if(this.reconnectAttempts++,this.reconnectAttempts>s){ModuleLogger.error(`Maximum reconnection attempts (${s}) reached`),this.reconnectAttempts=0;return}const n=Math.min(3e4,t*Math.pow(2,this.reconnectAttempts-1));ModuleLogger.info(`Scheduling reconnect in ${n}ms (attempt ${this.reconnectAttempts}/${s})`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=null,this.isPrimaryGM?(ModuleLogger.info("Attempting reconnect..."),this.connect()):(ModuleLogger.info("Reconnect attempt aborted - no longer primary GM."),this.reconnectAttempts=0)},n)}};q(S,"instance",null);let WebSocketManager=S;class Router{constructor(s,t=[]){q(this,"title");q(this,"routes");this.title=s,this.routes=t}addRoute(s){this.routes.push(s)}reflect(s){this.routes.forEach(t=>s.onMessageType(t.actionType,t.handler))}}const router$b=new Router("pingRouter");router$b.addRoute({actionType:"ping",handler:e=>{ModuleLogger.info("Received ping, sending pong"),e.socketManager.send({type:"pong"})}});router$b.addRoute({actionType:"pong",handler:()=>{ModuleLogger.info("Received pong")}});function deepSerializeEntity(e){var s,t,n,u,i;if(!e)return null;try{let r=e.toObject?e.toObject(!0):JSON.parse(JSON.stringify(e));if(e.system){if(e.system.attributes){for(const[d,o]of Object.entries(e.system.attributes))if(((t=(s=r.system)==null?void 0:s.attributes)==null?void 0:t[d])===null&&o!==null&&(r.system.attributes||(r.system.attributes={}),r.system.attributes[d]=JSON.parse(JSON.stringify(o))),typeof o=="object"&&o!==null)for(const[l,a]of Object.entries(o))((i=(u=(n=r.system)==null?void 0:n.attributes)==null?void 0:u[d])==null?void 0:i[l])===null&&a!==null&&(r.system.attributes[d]||(r.system.attributes[d]={}),r.system.attributes[d][l]=JSON.parse(JSON.stringify(a)))}["traits","abilities","skills","resources"].forEach(d=>{var o,l,a,c,y;if(e.system[d]){for(const[p,h]of Object.entries(e.system[d]))if(((l=(o=r.system)==null?void 0:o[d])==null?void 0:l[p])===null&&h!==null&&(r.system[d]||(r.system[d]={}),r.system[d][p]=JSON.parse(JSON.stringify(h))),typeof h=="object"&&h!==null)for(const[f,m]of Object.entries(h))((y=(c=(a=r.system)==null?void 0:a[d])==null?void 0:c[p])==null?void 0:y[f])===null&&m!==null&&(r.system[d][p]||(r.system[d][p]={}),r.system[d][p][f]=JSON.parse(JSON.stringify(m)))}})}if(e.items&&e.items.size>0&&Array.isArray(r.items))try{const d=e.items;if(Array.isArray(d.contents))for(let o=0;o<d.contents.length;o++)o<r.items.length&&(r.items[o]=deepSerializeEntity(d.contents[o]));else if(typeof d.entries=="function"){const o=Array.from(d.entries());for(let l=0;l<o.length;l++){const[a,c]=o[l];l<r.items.length&&(r.items[l]=deepSerializeEntity(c))}}}catch(d){ModuleLogger.warn("Failed to process entity.items collection:",d)}if(e.effects&&e.effects.size>0&&Array.isArray(r.effects))try{const d=e.effects;if(Array.isArray(d.contents))for(let o=0;o<d.contents.length;o++)o<r.effects.length&&(r.effects[o]=deepSerializeEntity(d.contents[o]));else if(typeof d.entries=="function"){const o=Array.from(d.entries());for(let l=0;l<o.length;l++){const[a,c]=o[l];l<r.effects.length&&(r.effects[l]=deepSerializeEntity(c))}}}catch(d){ModuleLogger.warn("Failed to process entity.effects collection:",d)}return r}catch(r){return ModuleLogger.error("Error deep serializing entity:",r),e.toObject?e.toObject():e}}const router$a=new Router("entityRouter");router$a.addRoute({actionType:"entity",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received entity request:",e);try{let u,i=[],r=e.uuid;if(e.selected){const d=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(d)for(let o of d)e.actor?u=o.actor:u=o.document,u&&(r=u.uuid,i.push(deepSerializeEntity(u)))}else u=await fromUuid(e.uuid),i=u?deepSerializeEntity(u):null;if(!i){ModuleLogger.error(`Entity not found: ${e.uuid}`),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:"Entity not found",data:null});return}ModuleLogger.info(`Sending entity data for: ${e.uuid}`,i),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:r,data:i})}catch(u){ModuleLogger.error("Error getting entity:",u),t==null||t.send({type:"entity-result",requestId:e.requestId,uuid:e.uuid,error:u.message,data:null})}}});router$a.addRoute({actionType:"create",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received create entity request for type: ${e.entityType}`);try{const n=getDocumentClass(e.entityType);if(!n)throw new Error(`Invalid entity type: ${e.entityType}`);const u={...e.data,folder:e.folder||null},i=await n.create(u);if(!i)throw new Error("Failed to create entity");t==null||t.send({type:"create-result",requestId:e.requestId,uuid:i.uuid,entity:i.toObject()})}catch(n){ModuleLogger.error("Error creating entity:",n),t==null||t.send({type:"create-result",requestId:e.requestId,error:n.message,message:"Failed to create entity"})}}});router$a.addRoute({actionType:"decrease",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received decrease attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const u=[];if(e.selected){const r=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const d of r)d.actor&&u.push(d.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&u.push(r)}if(u.length===0)throw new Error("No entities found to modify");const i=[];for(const r of u){const d=getProperty(r,e.attribute);if(typeof d!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof d}`);const o=d-e.amount,l={};l[e.attribute]=o,await r.update(l),i.push({uuid:r.uuid,attribute:e.attribute,oldValue:d,newValue:o})}t==null||t.send({type:"decrease-result",requestId:e.requestId,results:i,success:!0})}catch(u){ModuleLogger.error("Error decreasing attribute:",u),t==null||t.send({type:"decrease-result",requestId:e.requestId,success:!1,error:u.message})}}});router$a.addRoute({actionType:"increase",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received increase attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const u=[];if(e.selected){const r=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const d of r)d.actor&&u.push(d.actor)}else if(e.uuid){const r=await fromUuid(e.uuid);r&&u.push(r)}if(u.length===0)throw new Error("No entities found to modify");const i=[];for(const r of u){const d=getProperty(r,e.attribute);if(typeof d!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof d}`);const o=d+e.amount,l={};l[e.attribute]=o,await r.update(l),i.push({uuid:r.uuid,attribute:e.attribute,oldValue:d,newValue:o})}t==null||t.send({type:"increase-result",requestId:e.requestId,results:i,success:!0})}catch(u){ModuleLogger.error("Error increasing attribute:",u),t==null||t.send({type:"increase-result",requestId:e.requestId,success:!1,error:u.message})}}});router$a.addRoute({actionType:"update",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received update entity request for UUID: ${e.uuid}`);try{let u=[];if(e.uuid)u.push(await fromUuid(e.uuid));else if(e.selected){const r=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(r)for(let d of r)e.actor?u.push(d.actor):u.push(d.document)}if(u.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let r of u)await(r==null?void 0:r.update(e.data));let i=[];for(let r of u)i.push(await fromUuid(r.uuid));t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,entity:i.map(r=>r==null?void 0:r.toObject())})}catch(u){ModuleLogger.error("Error updating entity:",u),t==null||t.send({type:"update-result",requestId:e.requestId,uuid:e.uuid,error:u.message,message:"Failed to update entity"})}}});router$a.addRoute({actionType:"delete",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received delete entity request for UUID: ${e.uuid}`);try{let u=[];if(e.uuid)u.push(await fromUuid(e.uuid));else if(e.selected){const i=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(i)for(let r of i)e.actor?u.push(r.actor):u.push(r.document)}if(!u||u.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let i of u)await(i==null?void 0:i.delete());t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,success:!0})}catch(u){ModuleLogger.error("Error deleting entity:",u),t==null||t.send({type:"delete-result",requestId:e.requestId,uuid:e.uuid,error:u.message,message:"Failed to delete entity"})}}});router$a.addRoute({actionType:"kill",handler:async(e,s)=>{var n,u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received kill request for UUID: ${e.uuid}`);try{const r=[];if(e.uuid){const o=await fromUuid(e.uuid);if(o)r.push(o);else throw new Error(`Entity not found: ${e.uuid}`)}else if(e.selected){const o=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const l of o)l.document&&r.push(l.document)}if(r.length===0)throw new Error("No entities found to mark as defeated");const d=[];for(const o of r){let l=!1,a="";if(o.documentName==="Token"){const c=o,y=c.actor;if(!y)throw new Error("Token has no associated actor");const p=game.combat;if(p){const h=p.combatants.find(f=>{var m,g,w,I;return((m=f.token)==null?void 0:m.id)===c.id&&((w=(g=f.token)==null?void 0:g.parent)==null?void 0:w.id)===((I=c.parent)==null?void 0:I.id)});h&&(await h.update({defeated:!0}),ModuleLogger.info("Marked token as defeated in combat"))}try{hasProperty(y,"system.attributes.hp")?await y.update({"system.attributes.hp.value":0}):hasProperty(y,"system.health")?await y.update({"system.health.value":0}):hasProperty(y,"system.hp")?await y.update({"system.hp.value":0}):hasProperty(y,"data.attributes.hp")&&await y.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(h){ModuleLogger.warn(`Could not set HP to 0: ${h}`)}try{const h=(u=CONFIG.statusEffects)==null?void 0:u.find(f=>f.id==="dead"||f.id==="unconscious"||f.id==="defeated");h?(await c.toggleActiveEffect(h),ModuleLogger.info(`Added ${h.id} status effect to token`)):ModuleLogger.warn("No dead status effect found")}catch(h){ModuleLogger.warn(`Could not apply status effect: ${h}`)}l=!0,a="Token marked as defeated, HP set to 0, and dead effect applied"}else if(o.documentName==="Actor"){const c=o;let y=0;const p=game.scenes;if(p!=null&&p.viewed){const f=p.viewed.tokens.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});for(const m of f)try{const g=(i=CONFIG.statusEffects)==null?void 0:i.find(w=>w.id==="dead"||w.id==="unconscious"||w.id==="defeated");g&&(await m.toggleActiveEffect(g),y++)}catch(g){ModuleLogger.warn(`Could not apply status effect to token: ${g}`)}}const h=game.combat;if(h){const f=h.combatants.filter(m=>{var g;return((g=m.actor)==null?void 0:g.id)===c.id});f.length>0&&(await Promise.all(f.map(m=>m.update({defeated:!0}))),ModuleLogger.info(`Marked ${f.length} combatants as defeated`))}try{hasProperty(c,"system.attributes.hp")?await c.update({"system.attributes.hp.value":0}):hasProperty(c,"system.health")?await c.update({"system.health.value":0}):hasProperty(c,"system.hp")?await c.update({"system.hp.value":0}):hasProperty(c,"data.attributes.hp")&&await c.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(f){ModuleLogger.warn(`Could not set HP to 0: ${f}`)}l=!0,a=`Actor marked as defeated, HP set to 0, and dead effect applied to ${y} tokens`}else throw new Error(`Cannot mark entity type ${o.documentName} as defeated`);d.push({uuid:o.uuid,success:l,message:a})}t==null||t.send({type:"kill-result",requestId:e.requestId,results:d})}catch(r){ModuleLogger.error("Error marking entities as defeated:",r),t==null||t.send({type:"kill-result",requestId:e.requestId,success:!1,error:r.message})}}});router$a.addRoute({actionType:"give",handler:async(e,s)=>{var n,u,i,r;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received give item request from ${e.fromUuid} to ${e.toUuid}`);try{if(!e.toUuid&&!e.selected)throw new Error("Target UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");let d=null;if(e.fromUuid&&(d=await fromUuid(e.fromUuid),(d==null?void 0:d.documentName)!=="Actor"))throw new Error(`Source entity must be an Actor, got ${d==null?void 0:d.documentName}`);e.selected&&(e.toUuid=(i=(u=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled[0])==null?void 0:u.actor)==null?void 0:i.uuid);const o=await fromUuid(e.toUuid);if(!o)throw new Error(`Target entity not found: ${e.toUuid}`);if(o.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${o.documentName}`);let l=null,a=null;if(e.itemUuid)l=await fromUuid(e.itemUuid),l&&(a=l.toObject());else if(e.itemName)if(d)l=d.items.find(m=>m.name.toLowerCase()===e.itemName.toLowerCase()),l&&(a=l.toObject());else{if(!window.QuickInsert)throw new Error("QuickInsert is not available for global item search.");window.QuickInsert.hasIndex||(ModuleLogger.info("QuickInsert index not ready, forcing index creation"),window.QuickInsert.forceIndex(),await new Promise(w=>setTimeout(w,500)));const g=(await window.QuickInsert.search(e.itemName,null,20)).find(w=>{var I;return((I=w.item)==null?void 0:I.documentType)==="Item"});if(g){const w=await g.item.get();w&&(a=w.toObject())}}if(!a)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);if(l&&l.documentName!=="Item")throw new Error(`Entity must be an Item, got ${l.documentName}`);if(l&&d&&((r=l.parent)==null?void 0:r.id)!==d.id)throw new Error(`Item ${e.itemUuid||e.itemName} does not belong to source actor ${e.fromUuid}`);const c=e.quantity||1,y=o.items.find(m=>m.name===a.name),p=y&&hasProperty(y.system,"quantity");if(l&&d){const m=getProperty(l,"system.quantity");typeof m=="number"&&c<m?await l.update({"system.quantity":m-c}):await l.delete()}let h,f;if(p){const m=y.system.quantity+c;await y.update({"system.quantity":m}),h=y.id,f=m}else delete a._id,(hasProperty(a,"system.quantity")||a.system)&&(a.system.quantity=c),f=c,h=(await o.createEmbeddedDocuments("Item",[a]))[0].id;t==null||t.send({type:"give-result",requestId:e.requestId,fromUuid:e.fromUuid,selected:e.selected,toUuid:e.toUuid,quantity:f,itemUuid:e.itemUuid,newItemId:h,success:!0})}catch(d){ModuleLogger.error("Error giving item:",d),t==null||t.send({type:"give-result",requestId:e.requestId,selected:e.selected,fromUuid:e.fromUuid||"",toUuid:e.toUuid||"",quantity:e.quantity,itemUuid:e.itemUuid||"",success:!1,error:d.message})}}});router$a.addRoute({actionType:"remove",handler:async(e,s)=>{var n,u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove item request from actor: ${e.actorUuid}`);try{if(!e.actorUuid&&!e.selected)throw new Error("Target actor UUID or selected is required");if(!e.itemUuid&&!e.itemName)throw new Error("Item UUID or Item Name is required");e.selected&&(e.actorUuid=(i=(u=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled[0])==null?void 0:u.actor)==null?void 0:i.uuid);const r=await fromUuid(e.actorUuid);if(!r)throw new Error(`Target actor not found: ${e.actorUuid}`);if(r.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${r.documentName}`);let d=null;if(e.itemUuid?d=await fromUuid(e.itemUuid):e.itemName&&(d=r.items.find(c=>c.name.toLowerCase()===e.itemName.toLowerCase())),!d)throw new Error(`Item not found: ${e.itemUuid||e.itemName}`);const o=e.quantity||null,l=getProperty(d,"system.quantity");let a=0;o&&typeof l=="number"&&l>o?(a=l-o,await d.update({"system.quantity":a})):await d.delete(),t==null||t.send({type:"remove-result",requestId:e.requestId,actorUuid:e.actorUuid,itemUuid:d.uuid,quantity:a,success:!0})}catch(r){ModuleLogger.error("Error removing item:",r),t==null||t.send({type:"remove-result",requestId:e.requestId,success:!1,error:r.message})}}});const router$9=new Router("encounterRouter");router$9.addRoute({actionType:"encounters",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for encounters");try{const u=((n=game.combats)==null?void 0:n.contents.map(i=>{var r;return{id:i.id,name:i.name,round:i.round,turn:i.turn,current:i.id===((r=game.combat)==null?void 0:r.id),combatants:i.combatants.contents.map(d=>{var o,l;return{id:d.id,name:d.name,tokenUuid:(o=d.token)==null?void 0:o.uuid,actorUuid:(l=d.actor)==null?void 0:l.uuid,img:d.img,initiative:d.initiative,hidden:d.hidden,defeated:d.isDefeated}})}}))||[];t==null||t.send({type:"encounters-result",requestId:e.requestId,encounters:u})}catch(u){ModuleLogger.error("Error getting encounters list:",u),t==null||t.send({type:"encounters-result",requestId:e.requestId,error:u.message,encounters:[]})}}});router$9.addRoute({actionType:"start-encounter",handler:async(e,s)=>{var n,u,i;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request to start encounter with options:",e);try{const r=await Combat.create({name:e.name||"New Encounter"});if(r){if(await r.startCombat(),e.tokenUuids&&e.tokenUuids.length>0){const o=[];for(const l of e.tokenUuids)try{const a=await fromUuid(l);a&&o.push({tokenId:a.id??"",sceneId:a.parent.id})}catch(a){ModuleLogger.warn(`Failed to add token ${l} to combat:`,a)}o.length>0&&await r.createEmbeddedDocuments("Combatant",o)}let d=new Set;if(e.startWithPlayers){const o=(n=game.scenes)==null?void 0:n.viewed;if(o){const a=(((u=o.tokens)==null?void 0:u.filter(c=>!!c.actor&&c.actor.hasPlayerOwner))??[]).map(c=>(d.add(c.id),{tokenId:c.id,sceneId:o.id}));a.length>0&&await r.createEmbeddedDocuments("Combatant",a)}}if(e.startWithSelected){const o=((i=canvas==null?void 0:canvas.tokens)==null?void 0:i.controlled.filter(l=>!d.has(l.id)).map(l=>({tokenId:l.id,sceneId:l.scene.id})))??[];o.length>0&&await r.createEmbeddedDocuments("Combatant",o)}e.rollNPC&&await r.rollNPC(),e.rollAll&&await r.rollAll(),await r.activate(),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,encounterId:r.id,encounter:{id:r.id,name:r.name,round:r.round,turn:r.turn,combatants:r.combatants.contents.map(o=>{var l,a;return{id:o.id,name:o.name,tokenUuid:(l=o.token)==null?void 0:l.uuid,actorUuid:(a=o.actor)==null?void 0:a.uuid,img:o.img,initiative:o.initiative,hidden:o.hidden,defeated:o.isDefeated}})}})}else throw new Error("Failed to create encounter")}catch(r){ModuleLogger.error("Error starting encounter:",r),t==null||t.send({type:"start-encounter-result",requestId:e.requestId,error:r.message})}}});router$9.addRoute({actionType:"next-turn",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next turn in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.nextTurn(),t==null||t.send({type:"next-turn-result",requestId:e.requestId,encounterId:o.id,action:"nextTurn",currentTurn:o.turn,currentRound:o.round,actorTurn:(i=(u=o.combatant)==null?void 0:u.actor)==null?void 0:i.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error advancing to next turn:",o),t==null||t.send({type:"next-turn-result",requestId:e.requestId,error:o.message})}}});router$9.addRoute({actionType:"next-round",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for next round in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.nextRound(),t==null||t.send({type:"next-round-result",requestId:e.requestId,encounterId:o.id,action:"nextRound",currentTurn:o.turn,currentRound:o.round,actorTurn:(i=(u=o.combatant)==null?void 0:u.actor)==null?void 0:i.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error advancing to next round:",o),t==null||t.send({type:"next-round-result",requestId:e.requestId,error:o.message})}}});router$9.addRoute({actionType:"last-turn",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous turn in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.previousTurn(),t==null||t.send({type:"last-turn-result",requestId:e.requestId,encounterId:o.id,action:"previousTurn",currentTurn:o.turn,currentRound:o.round,actorTurn:(i=(u=o.combatant)==null?void 0:u.actor)==null?void 0:i.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error going back to previous turn:",o),t==null||t.send({type:"last-turn-result",requestId:e.requestId,error:o.message})}}});router$9.addRoute({actionType:"last-round",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request for previous round in encounter: ${e.encounterId||"active"}`);try{const o=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await o.previousRound(),t==null||t.send({type:"last-round-result",requestId:e.requestId,encounterId:o.id,action:"previousRound",currentTurn:o.turn,currentRound:o.round,actorTurn:(i=(u=o.combatant)==null?void 0:u.actor)==null?void 0:i.uuid,tokenTurn:(d=(r=o.combatant)==null?void 0:r.token)==null?void 0:d.uuid,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn}})}catch(o){ModuleLogger.error("Error going back to previous round:",o),t==null||t.send({type:"encounter-navigation",requestId:e.requestId,error:o.message})}}});router$9.addRoute({actionType:"end-encounter",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to end encounter: ${e.encounterId}`);try{let i=e.encounterId;i||(i=(n=game.combat)==null?void 0:n.id);const r=(u=game.combats)==null?void 0:u.get(i);if(!r)throw new Error("No encounter not found");await r.delete(),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,encounterId:i,message:"Encounter successfully ended"})}catch(i){ModuleLogger.error("Error ending encounter:",i),t==null||t.send({type:"end-encounter-result",requestId:e.requestId,error:i.message})}}});router$9.addRoute({actionType:"add-to-encounter",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received add-to-encounter request for encounter: ${e.encounterId}`);try{const o=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!o)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const l=[],a=[];if(e.uuids&&Array.isArray(e.uuids))for(const c of e.uuids)try{const y=await fromUuid(c);if(!y){a.push({uuid:c,reason:"Entity not found"});continue}if(y.documentName==="Token"){const p=y,h={tokenId:p.id,sceneId:(u=p.parent)==null?void 0:u.id};await o.createEmbeddedDocuments("Combatant",[h]),l.push(c)}else if(y.documentName==="Actor"){const p=(i=game.scenes)==null?void 0:i.viewed;if(p){const h=(r=p.tokens)==null?void 0:r.find(f=>{var m;return((m=f.actor)==null?void 0:m.id)===y.id});if(h){const f={tokenId:h.id,sceneId:p.id};await o.createEmbeddedDocuments("Combatant",[f]),l.push(c)}else a.push({uuid:c,reason:"No token found for this actor in the current scene"})}else a.push({uuid:c,reason:"No active scene"})}else a.push({uuid:c,reason:"Entity must be a Token or Actor"})}catch(y){a.push({uuid:c,reason:y.message})}if(e.selected===!0){const c=((d=canvas==null?void 0:canvas.tokens)==null?void 0:d.controlled)||[];for(const y of c)try{if(!o.combatants.find(p=>{var h,f,m;return((h=p.token)==null?void 0:h.id)===y.id&&((m=(f=p.combat)==null?void 0:f.scene)==null?void 0:m.id)===y.scene.id})){const p={tokenId:y.id,sceneId:y.scene.id};await o.createEmbeddedDocuments("Combatant",[p]),l.push(y.document.uuid)}}catch(p){a.push({uuid:y.document.uuid,reason:p.message})}}e.rollInitiative===!0&&l.length>0&&o.rollAll(),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,encounterId:o.id,added:l,failed:a})}catch(o){ModuleLogger.error("Error adding to encounter:",o),t==null||t.send({type:"add-to-encounter-result",requestId:e.requestId,error:o.message})}}});router$9.addRoute({actionType:"remove-from-encounter",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received remove-from-encounter request for encounter: ${e.encounterId}`);try{const i=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!i)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const r=[],d=[],o=[];if(e.uuids&&Array.isArray(e.uuids))for(const l of e.uuids)try{const a=await fromUuid(l);if(!a){d.push({uuid:l,reason:"Entity not found"});continue}let c=!1;if(a.documentName==="Token"){const y=i.combatants.find(p=>{var h,f,m,g;return((h=p.token)==null?void 0:h.id)===a.id&&((m=(f=p.combat)==null?void 0:f.scene)==null?void 0:m.id)===((g=a.parent)==null?void 0:g.id)});y&&(o.push(y.id),c=!0)}else if(a.documentName==="Actor"){const y=i.combatants.filter(p=>{var h;return((h=p.actor)==null?void 0:h.id)===a.id});y.length>0&&(o.push(...y.map(p=>p.id)),c=!0)}c?r.push(l):d.push({uuid:l,reason:"No combatant found for this entity"})}catch(a){d.push({uuid:l,reason:a.message})}if(e.selected===!0){const l=((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[];for(const a of l){const c=i.combatants.find(y=>y.tokenId===a.id&&y.sceneId===a.scene.id);c&&(o.push(c.id),r.push(a.document.uuid))}}if(o.length>0){const l=o.filter(a=>a!==null);l.length>0&&await i.deleteEmbeddedDocuments("Combatant",l)}t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,encounterId:i.id,removed:r,failed:d})}catch(i){ModuleLogger.error("Error removing from encounter:",i),t==null||t.send({type:"remove-from-encounter-result",requestId:e.requestId,error:i.message})}}});const router$8=new Router("rollRouter");router$8.addRoute({actionType:"rolls",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for roll data"),t==null||t.send({type:"rolls-result",requestId:e.requestId,data:recentRolls.slice(0,e.limit||20)})}});router$8.addRoute({actionType:"last-roll",handler:(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for last roll data"),t==null||t.send({type:"last-roll-result",requestId:e.requestId,data:recentRolls.length>0?recentRolls[0]:null})}});router$8.addRoute({actionType:"roll",handler:async(e,s)=>{var n,u,i,r,d;const t=s==null?void 0:s.socketManager;try{const{formula:o,flavor:l,createChatMessage:a,speaker:c,whisper:y,requestId:p}=e;let h,f={},m=y&&y.length>0?CONST.DICE_ROLL_MODES.PRIVATE:CONST.DICE_ROLL_MODES.PUBLIC;if(c)try{const g=await fromUuid(c);if(g){if(g instanceof TokenDocument)f={token:g==null?void 0:g.id,actor:(n=g==null?void 0:g.actor)==null?void 0:n.id,scene:(u=g==null?void 0:g.parent)==null?void 0:u.id,alias:(g==null?void 0:g.name)||((i=g==null?void 0:g.actor)==null?void 0:i.name)};else if(g instanceof Actor){const w=(r=game.scenes)==null?void 0:r.active;if(w){const I=(d=w.tokens)==null?void 0:d.filter(E=>{var v;return((v=E.actor)==null?void 0:v.id)===g.id});if(I&&I.length>0){const E=I[0];f={token:E.id,actor:g.id,scene:w.id,alias:E.name||g.name}}else f={actor:g.id,alias:g.name}}}}}catch(g){ModuleLogger.warn(`Failed to process speaker: ${g}`)}try{const g=new Roll(o);await g.evaluate(),a&&await g.toMessage({speaker:f,flavor:l||"",rollMode:m,whisper:y||[]}),h={id:`manual_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!!a,roll:{formula:o,total:g.total,isCritical:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===g.terms[0].faces)}),isFumble:g.terms.some(w=>{var I;return(I=w.results)==null?void 0:I.some(E=>E.result===1)}),dice:g.dice.map(w=>({faces:w.faces,results:w.results.map(I=>({result:I.result,active:I.active}))})),timestamp:Date.now()}}}catch(g){ModuleLogger.error(`Error rolling formula: ${g}`),t==null||t.send({type:"roll-result",requestId:p,success:!1,error:`Failed to roll formula: ${g.message}`});return}t==null||t.send({type:"roll-result",requestId:p,success:!0,data:h})}catch(o){ModuleLogger.error(`Error in roll handler: ${o}`),t==null||t.send({type:"roll-result",requestId:e.requestId,success:!1,error:o.message||"Unknown error occurred during roll"})}}});function parseFilterString(e){if(!e.includes(":"))return{documentType:e};const s={},t=e.split(",");for(const n of t)if(n.includes(":")){const[u,i]=n.split(":");u&&i&&(s[u.trim()]=i.trim())}return s}function matchesAllFilters(e,s){var t,n;for(const[u,i]of Object.entries(s)){if(!i)continue;if(u==="resultType"){const d=(n=(t=e.item)==null?void 0:t.constructor)==null?void 0:n.name;if(!d||d.toLowerCase()!==i.toLowerCase())return!1;continue}if(u==="package"&&e.item){const d=e.item.package;if(!d||d.toLowerCase()!==i.toLowerCase()&&`Compendium.${d}`.toLowerCase()!==i.toLowerCase())return!1;continue}if(u==="folder"&&e.item){const d=e.item.folder;if(!d&&i)return!1;if(d){const o=typeof d=="object"?d.id:d;if(i===o||i===`Folder.${o}`||`Folder.${i}`===o)continue;return!1}continue}let r;if(!u.includes(".")&&e.item&&e.item[u]!==void 0)r=e.item[u];else{const d=u.split(".");let o=e;for(const l of d){if(o==null){r=void 0;break}o=o[l]}r=o}if(r===void 0||typeof r=="string"&&r.toLowerCase()!==i.toLowerCase())return!1}return!0}const router$7=new Router("searchRouter");router$7.addRoute({actionType:"search",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received search request:",e);try{if(!window.QuickInsert){ModuleLogger.error("QuickInsert not available"),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert not available",results:[]});return}if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(i=>setTimeout(i,500))}catch(i){ModuleLogger.error("Failed to force QuickInsert index:",i),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:"QuickInsert index not ready",results:[]});return}}let n=null;if(e.filter){const i=typeof e.filter=="string"?parseFilterString(e.filter):e.filter;n=r=>matchesAllFilters(r,i)}const u=await window.QuickInsert.search(e.query,n,200);ModuleLogger.info(`Search returned ${u.length} results`),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,filter:e.filter,results:u.map(i=>{var d;const r=i.item;return{documentType:r.documentType,folder:r.folder,id:r.id,name:r.name,package:r.package,packageName:r.packageName,subType:r.subType,uuid:r.uuid,icon:r.icon,journalLink:r.journalLink,tagline:r.tagline||"",formattedMatch:i.formattedMatch||"",resultType:(d=r.constructor)==null?void 0:d.name}})})}catch(n){ModuleLogger.error("Error performing search:",n),t==null||t.send({type:"search-result",requestId:e.requestId,query:e.query,error:n.message,results:[]})}}});const router$6=new Router("structureRouter");router$6.addRoute({actionType:"structure",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received structure request with params:",e);try{const i=e.includeEntityData??!1,r=e.path||null,d=e.recursive??!1,o=e.recursiveDepth??5,l=e.type?Array.isArray(e.types)?e.types:[e.types]:["Scene","Actor","Item","JournalEntry","RollTable","Cards","Macro","Playlist"],a={Scene:game.scenes,Actor:game.actors,Item:game.items,JournalEntry:game.journal,RollTable:game.tables,Cards:game.cards,Macro:game.macros,Playlist:game.playlists},c=h=>i?h.toObject(!1):{uuid:h.uuid,name:h.name,id:h.id,type:h.documentName},y=(h,f=0)=>{var I;if(!d||f>=o)return{};const m={},w=(((I=game.folders)==null?void 0:I.contents)||[]).filter(E=>{var v;return((v=E.folder)==null?void 0:v.id)===(h==null?void 0:h.id)&&l.includes(E.type)});for(const E of w){const v=E.name||E.id;m[v]={id:E.id,uuid:E.uuid,type:E.type,...y(E,f+1)};const L=E.contents.filter(R=>l.includes(R.documentName)).map(c);L.length>0&&(m[v].entities=L)}return m};let p={};if(r&&r.startsWith("Compendium.")){const h=game.packs.get(r.replace("Compendium.",""));if(!h)throw new Error(`Compendium not found: ${r}`);const m=(await h.getIndex()).contents.map(g=>i?{...g}:{uuid:g.uuid||`${h.collection}.${g._id}`,name:g.name,id:g._id,type:h.documentName});p={compendium:{name:h.title,type:h.documentName,entities:m}}}else if(r&&r.startsWith("Folder.")){const h=r.match(/Folder\.([a-zA-Z0-9]+)/);if(!h)throw new Error(`Invalid folder path: ${r}`);const f=h[1],m=(n=game.folders)==null?void 0:n.get(f);if(!m)throw new Error(`Folder not found: ${r}`);if(!l.includes(m.type))throw new Error(`Folder type ${m.type} not included in requested types`);p.folders=y(m);const g=m.contents.filter(w=>l.includes(w.documentName)).map(c);g.length>0&&(p.entities=g)}else{if(d)p.folders=y(null);else{const f=((u=game.folders)==null?void 0:u.contents)||[];p.folders={};for(const m of l){const g=f.filter(w=>w.type===m&&!w.folder);for(const w of g){const I=w.name||w.id;if(p.folders[I]={id:w.id,uuid:w.uuid,type:w.type},i||!d){const E=w.contents.filter(v=>l.includes(v.documentName)).map(c);E.length>0&&(p.folders[I].entities=E)}}}}const h={};for(const f of l){const m=a[f];if(m){const g=m.filter(w=>!w.folder).map(c);g.length>0&&(h[f.toLowerCase()+"s"]=g)}}if(Object.keys(h).length>0&&(p.entities=h),!r){const f={};for(const m of game.packs.contents)if(l.includes(m.documentName)){const g=m.title||m.collection;f[g]={id:m.collection,name:m.title,type:m.documentName,uuid:`Compendium.${m.collection}`};try{const I=(await m.getIndex()).contents.map(E=>i?{...E}:{uuid:E.uuid||`${m.collection}.${E._id}`,name:E.name,id:E._id,type:m.documentName});I.length>0&&(f[g].entities=I)}catch(w){ModuleLogger.warn(`Failed to load entities for compendium ${m.collection}:`,w)}}Object.keys(f).length>0&&(p.compendiumPacks=f)}}t==null||t.send({type:"structure-result",requestId:e.requestId,data:p})}catch(i){ModuleLogger.error("Error getting structure:",i),t==null||t.send({type:"structure-result",requestId:e.requestId,error:i.message,data:{}})}}});router$6.addRoute({actionType:"get-folder",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received get-folder request for name: ${e.name}`);try{const r=(((n=game.folders)==null?void 0:n.contents)||[]).find(o=>o.name===e.name);if(!r)throw new Error(`Folder not found with name: ${e.name}`);const d=r.contents.map(o=>({uuid:o.uuid,id:o.id,name:o.name,type:o.documentName,img:"img"in o?o.img:null}));t==null||t.send({type:"get-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((u=r.folder)==null?void 0:u.id)||null,contents:d}})}catch(i){ModuleLogger.error("Error getting folder:",i),t==null||t.send({type:"get-folder-result",requestId:e.requestId,error:i.message,data:null})}}});router$6.addRoute({actionType:"create-folder",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received create-folder request:",e);try{const i={name:e.name,type:e.folderType};if(e.parentFolderId){if(!((n=game.folders)==null?void 0:n.get(e.parentFolderId)))throw new Error(`Parent folder not found with ID: ${e.parentFolderId}`);i.folder=e.parentFolderId}const r=await Folder.create(i);t==null||t.send({type:"create-folder-result",requestId:e.requestId,data:{id:r.id,uuid:r.uuid,name:r.name,type:r.type,parentFolder:((u=r.folder)==null?void 0:u.id)||null}})}catch(i){ModuleLogger.error("Error creating folder:",i),t==null||t.send({type:"create-folder-result",requestId:e.requestId,error:i.message,data:null})}}});router$6.addRoute({actionType:"delete-folder",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received delete-folder request:",e);try{const i=(n=game.folders)==null?void 0:n.get(e.folderId);if(!i)throw new Error(`Folder not found with ID: ${e.folderId}`);const r=e.deleteAll??!1;let d=0,o=0;const l=async a=>{var m;let c=0,y=0;const h=(((m=game.folders)==null?void 0:m.contents)||[]).filter(g=>{var w;return((w=g.folder)==null?void 0:w.id)===a.id});for(const g of h){const w=await l(g);c+=w.entities,y+=w.folders}const f=a.contents;c+=f.length;for(const g of f)await g.delete();return await a.delete(),y+=1,{entities:c,folders:y}};if(r){const a=await l(i);d=a.entities,o=a.folders}else{const c=(((u=game.folders)==null?void 0:u.contents)||[]).filter(y=>{var p;return((p=y.folder)==null?void 0:p.id)===i.id});if(i.contents.length>0)throw new Error(`Folder contains ${i.contents.length} entities. Use deleteAll=true to delete them or move them first.`);if(c.length>0)throw new Error(`Folder contains ${c.length} child folders. Use deleteAll=true to delete them or move them first.`);await i.delete(),o=1}t==null||t.send({type:"delete-folder-result",requestId:e.requestId,data:{deleted:!0,folderId:e.folderId,entitiesDeleted:d,foldersDeleted:o}})}catch(i){ModuleLogger.error("Error deleting folder:",i),t==null||t.send({type:"delete-folder-result",requestId:e.requestId,error:i.message,data:null})}}});router$6.addRoute({actionType:"contents",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received contents request for path: ${e.path}`);try{let u=[];if(e.path.startsWith("Compendium.")){const i=game.packs.get(e.path.replace("Compendium.",""));if(!i)throw new Error(`Compendium not found: ${e.path}`);u=(await i.getIndex()).contents.map(d=>({...d}))}else{const i=e.path.match(/Folder\.([a-zA-Z0-9]+)/);if(!i)throw new Error(`Invalid folder path: ${e.path}`);const r=i[1],d=(n=game.folders)==null?void 0:n.get(r);if(!d)throw new Error(`Folder not found: ${e.path}`);u=d.contents.map(o=>({uuid:o.uuid,id:o.id,name:o.name,img:"img"in o?o.img:null,type:o.documentName}))}t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,entities:u})}catch(u){ModuleLogger.error("Error getting contents:",u),t==null||t.send({type:"contents-result",requestId:e.requestId,path:e.path,error:u.message,entities:[]})}}});function getFoundryVersion(){return game.version}function getFoundryVersionMajor(){return parseInt(getFoundryVersion().split(".")[0],10)}const router$5=new Router("sheetRouter");router$5.addRoute({actionType:"get-sheet",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;if(ModuleLogger.info(`Received sheet request for UUID: ${e.uuid}`),getFoundryVersionMajor()>12){ModuleLogger.error(`Foundry version ${getFoundryVersionMajor()} does not support this endpoint`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"This endpoint is only supported in Foundry VTT version 12"}});return}try{let i=null;if(e.uuid)i=await fromUuid(e.uuid);else if(e.selected){const d=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;d&&d.length>0&&(e.actor?i=d[0].actor:i=d[0].document)}if(!i){ModuleLogger.error(`Entity not found for UUID: ${e.uuid}`),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Entity not found",uuid:e.uuid}});return}const r=(u=i.sheet)==null?void 0:u.render(!0);setTimeout(async()=>{try{let d=function(T){T.classList&&T.classList.length&&T.classList.forEach(b=>h.add(b)),T.id&&f.add(T.id);for(let b=0;b<T.children.length;b++)d(T.children[b])};if(!r.element||!r.element[0])throw new Error("Failed to render actor sheet");let o=r.element[0].outerHTML,l="";const a=String(r.appId);document.querySelectorAll("style[data-appid]").forEach(T=>{T.dataset.appid===a&&(l+=T.textContent+`
`)}),document.querySelectorAll(`style[id^="system-${i.type}"]`).forEach(T=>{l+=T.textContent+`
`});const p=document.createElement("div");p.innerHTML=o;const h=new Set,f=new Set;d(p);const m=Array.from(h),g=Array.from(f);ModuleLogger.debug(`Extracted ${m.length} unique classes and ${g.length} unique IDs`);const w=document.querySelectorAll("style"),I=document.querySelectorAll('link[rel="stylesheet"]');w.forEach(T=>{if(T.dataset.appid&&T.dataset.appid===a)return;const b=T.textContent||"";(m.some(M=>b.includes(`.${M}`))||g.some(M=>b.includes(`#${M}`))||b.includes(".window-app")||b.includes(".sheet")||b.includes(".actor-sheet")||b.includes(`.${i.type}-sheet`))&&(ModuleLogger.debug("Adding relevant inline style"),l+=b+`
`)});const E=Array.from(I).map(async T=>{try{const b=T.getAttribute("href");if(!b||b.includes("fonts.googleapis.com"))return"";ModuleLogger.debug(`Fetching external CSS from: ${b}`);const k=b.startsWith("http")?b:b.startsWith("/")?`${window.location.origin}${b}`:`${window.location.origin}/${b}`,M=await fetch(k);return M.ok?await M.text():(ModuleLogger.warn(`Failed to fetch CSS: ${k}, status: ${M.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch external CSS: ${b}`),""}}),v=window.location.origin;ModuleLogger.debug(`Base URL for fetching CSS: ${v}`);const L=[`${v}/css/style.css`,`${v}/styles/style.css`,`${v}/styles/foundry.css`,`${v}/ui/sheets.css`,`${v}/game/styles/foundry.css`,`${v}/game/ui/sheets.css`,`${v}/systems/${game.system.id}/system.css`,`${v}/systems/${game.system.id}/styles/system.css`,`${v}/game/systems/${game.system.id}/system.css`,`${v}/game/systems/${game.system.id}/styles/system.css`];ModuleLogger.debug("All stylesheet links in document:",Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(Boolean));const R=Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(T=>T.getAttribute("href")).filter(T=>T!==null&&!T.includes("fonts.googleapis.com")&&!T.includes("//"));L.push(...R),ModuleLogger.debug("All style elements in document:",document.querySelectorAll("style").length);const N=L.map(async T=>{try{ModuleLogger.debug(`Fetching core CSS from: ${T}`);const b=await fetch(T);return b.ok?(ModuleLogger.info(`Successfully loaded CSS from: ${T}`),await b.text()):(ModuleLogger.warn(`Failed to fetch CSS: ${T}, status: ${b.status}`),"")}catch(b){return ModuleLogger.warn(`Failed to fetch core CSS: ${b}`),""}}),C=[...E,...N];(await Promise.all(C)).forEach(T=>{l+=T+`
`}),l.length<100&&(ModuleLogger.warn("CSS fetch failed or returned minimal content. Adding fallback styles."),l+=`
              .window-app {
                font-family: "Signika", sans-serif;
                background: #f0f0e0;
                border-radius: 5px;
                box-shadow: 0 0 20px #000;
                color: #191813;
              }
              .window-content {
                background: rgba(255, 255, 240, 0.9);
                padding: 8px;
                overflow-y: auto;
                background: url(${window.location.origin}/ui/parchment.jpg) repeat;
              }
              input, select, textarea {
                border: 1px solid #7a7971;
                background: rgba(255, 255, 255, 0.8);
              }
              button {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid #7a7971;
                border-radius: 3px;
                cursor: pointer;
              }
              .profile-img {
                border: none;
                max-width: 100%;
                max-height: 220px;
              }
            `),ModuleLogger.debug(`Collected CSS: ${l.length} bytes`),o=o.replace(/src="([^"]+)"/g,(T,b)=>b.startsWith("http")?T:b.startsWith("/")?`src="${window.location.origin}${b}"`:`src="${window.location.origin}/${b}"`),l=l.replace(/url\(['"]?([^'")]+)['"]?\)/g,(T,b)=>b.startsWith("http")||b.startsWith("data:")?T:b.startsWith("/")?`url('${window.location.origin}${b}')`:`url('${window.location.origin}/${b}')`),r.close(),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{html:o,css:l,uuid:e.uuid}}),ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${e.requestId}`),ModuleLogger.debug(`HTML length: ${o.length}, CSS length: ${l.length}`)}catch(d){ModuleLogger.error("Error capturing actor sheet HTML:",d),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to capture actor sheet HTML",uuid:e.uuid}}),r&&typeof r.close=="function"&&r.close()}},500)}catch(i){ModuleLogger.error("Error rendering actor sheet:",i),t==null||t.send({type:"get-sheet-response",requestId:e.requestId,data:{error:"Failed to render actor sheet",uuid:e.uuid}})}}});const router$4=new Router("macroRouter");router$4.addRoute({actionType:"macros",handler:async(e,s)=>{var n;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for macros");try{const u=((n=game.macros)==null?void 0:n.contents.map(i=>{var r,d;return{uuid:i.uuid,id:i.id,name:i.name,type:i.type||((r=i.data)==null?void 0:r.type)||"unknown",author:((d=i.author)==null?void 0:d.name)||"unknown",command:i.command||"",img:i.img,scope:i.scope,canExecute:i.canExecute}}))||[];t==null||t.send({type:"macros-result",requestId:e.requestId,macros:u})}catch(u){ModuleLogger.error("Error getting macros list:",u),t==null||t.send({type:"macros-result",requestId:e.requestId,error:u.message,macros:[]})}}});router$4.addRoute({actionType:"macro-execute",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info(`Received request to execute macro: ${e.uuid}`);try{if(!e.uuid)throw new Error("Macro UUID is required");const n=await fromUuid(e.uuid);if(!n)throw new Error(`Macro not found with UUID: ${e.uuid}`);if(!(n instanceof CONFIG.Macro.documentClass))throw new Error(`Entity with UUID ${e.uuid} is not a macro`);if(!n.canExecute)throw new Error(`Macro '${n.name}' cannot be executed by the current user`);const u=e.args||{};let i;typeof u=="object"?i=await n.execute({args:u}):i=await n.execute(),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid,success:!0,result:typeof i=="object"?i:{value:i}})}catch(n){ModuleLogger.error("Error executing macro:",n),t==null||t.send({type:"macro-execute-result",requestId:e.requestId,uuid:e.uuid||"",success:!1,error:n.message})}}});const router$3=new Router("utilityRouter");router$3.addRoute({actionType:"execute-js",handler:async(data,context)=>{const socketManager=context==null?void 0:context.socketManager;ModuleLogger.info("Received execute-js request:",data);try{const{script,requestId}=data;if(!script||typeof script!="string")throw new Error("Invalid script provided");let result;try{result=await(async()=>eval(`(async () => { ${script} })()`))()}catch(e){const s=e instanceof Error?e.message:String(e);throw new Error(`Error executing script: ${s}`)}socketManager==null||socketManager.send({type:"execute-js-result",requestId,success:!0,result})}catch(e){ModuleLogger.error("Error in execute-js handler:",e),socketManager==null||socketManager.send({type:"execute-js-result",requestId:data.requestId,success:!1,error:e.message})}}});router$3.addRoute({actionType:"select",handler:async(e,s)=>{var n,u,i,r,d,o,l;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received select entities request:",e);try{const a=(n=game.scenes)==null?void 0:n.active;if(!a)throw new Error("No active scene found");e.overwrite&&((u=canvas==null?void 0:canvas.tokens)==null||u.releaseAll());const c=new Set;e.all&&(((i=a.tokens)==null?void 0:i.contents)||[]).forEach(f=>c.add(f)),e.uuids&&Array.isArray(e.uuids)&&(((r=a.tokens)==null?void 0:r.filter(f=>e.uuids.includes(f.uuid)))||[]).forEach(f=>c.add(f)),e.name&&(((d=a.tokens)==null?void 0:d.filter(f=>{var m,g;return((m=f.name)==null?void 0:m.toLowerCase())===((g=e.name)==null?void 0:g.toLowerCase())}))||[]).forEach(f=>c.add(f)),e.data&&(((o=a.tokens)==null?void 0:o.filter(f=>Object.entries(e.data).every(([m,g])=>{if(m.startsWith("actor.")&&f.actor){const I=m.replace("actor.","");return getProperty(f.actor,I)===g}const w=f.toObject();return getProperty(w,m)===g})))||[]).forEach(f=>c.add(f));const y=Array.from(c);if(y.length===0)throw new Error("No matching entities found");for(const h of y){const f=h.id?(l=canvas==null?void 0:canvas.tokens)==null?void 0:l.get(h.id):null;f&&f.control({releaseOthers:!1})}const p=y.map(h=>h.uuid);t==null||t.send({type:"select-result",requestId:e.requestId,success:!0,count:y.length,message:`${y.length} entities selected`,selected:p})}catch(a){ModuleLogger.error("Error selecting entities:",a),t==null||t.send({type:"select-result",requestId:e.requestId,success:!1,error:a.message})}}});router$3.addRoute({actionType:"selected",handler:async(e,s)=>{var n,u;const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get selected entities request:",e);try{if(!((n=game.scenes)==null?void 0:n.active))throw new Error("No active scene found");const d=(((u=canvas==null?void 0:canvas.tokens)==null?void 0:u.controlled)||[]).map(o=>{var l;return{tokenUuid:o.document.uuid,actorUuid:((l=o.actor)==null?void 0:l.uuid)||null}});t==null||t.send({type:"selected-result",requestId:e.requestId,success:!0,selected:d})}catch(i){ModuleLogger.error("Error getting selected entities:",i),t==null||t.send({type:"selected-result",requestId:e.requestId,success:!1,error:i.message})}}});const router$2=new Router("fileSystemRouter");router$2.addRoute({actionType:"file-system",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received get file system request:",e);try{const n=e.path||"",u=e.source||"data",i=!!e.recursive,r=await FilePicker.browse(u,n),d=Array.isArray(r.dirs)?r.dirs.map(c=>({name:c.split("/").pop()||c,path:c,type:"directory"})):[],o=Array.isArray(r.files)?r.files.map(c=>({name:c.split("/").pop()||c,path:c,type:"file"})):[];let l=[];if(i&&d.length>0)for(const c of d)try{const y=await FilePicker.browse(u,c.path),p=Array.isArray(y.dirs)?y.dirs.map(f=>({name:f.split("/").pop()||f,path:f,type:"directory"})):[],h=Array.isArray(y.files)?y.files.map(f=>({name:f.split("/").pop()||f,path:f,type:"file"})):[];if(l=l.concat(p,h),i===!0&&p.length>0&&c.path.split("/").length<3)for(const f of p)try{const m=await FilePicker.browse(u,f.path),g=Array.isArray(m.dirs)?m.dirs.map(I=>({name:I.split("/").pop()||I,path:I,type:"directory"})):[],w=Array.isArray(m.files)?m.files.map(I=>({name:I.split("/").pop()||I,path:I,type:"file"})):[];l=l.concat(g,w)}catch(m){ModuleLogger.error(`Error processing deep subdirectory ${f.path}:`,m)}}catch(y){ModuleLogger.error(`Error processing subdirectory ${c.path}:`,y)}const a=[...d,...o];i&&a.push(...l),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!0,path:n,source:u,results:a,recursive:i})}catch(n){ModuleLogger.error("Error getting file system:",n),t==null||t.send({type:"file-system-result",requestId:e.requestId,success:!1,error:n.message})}}});router$2.addRoute({actionType:"upload-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received upload file request:",e);try{const{path:n,filename:u,source:i,fileData:r,mimeType:d,binaryData:o,overwrite:l}=e;if(!n||!u)throw new Error("Missing required parameters (path, filename)");let a;if(o){if(!Array.isArray(o)||o.length===0)throw new Error("Invalid binary data: must be non-empty array");const f=new Uint8Array(o),m=new Blob([f],{type:d||"application/octet-stream"});a=new File([m],u,{type:d||"application/octet-stream"}),ModuleLogger.info(`Created file from binary data: ${f.length} bytes`)}else if(r){if(!r.includes(",")||!r.startsWith("data:"))throw new Error("Invalid file data format: must be data URL with base64 content");const f=r.split(",")[1];if(!f)throw new Error("No base64 data found in file data");let m;try{m=atob(f)}catch(I){throw new Error(`Invalid base64 data: ${I.message}`)}if(m.length===0)throw new Error("Decoded file data is empty");const g=new Uint8Array(m.length);for(let I=0;I<m.length;I++)g[I]=m.charCodeAt(I);const w=new Blob([g],{type:d||"application/octet-stream"});a=new File([w],u,{type:d||"application/octet-stream"}),ModuleLogger.info(`Created file from base64 data: ${g.length} bytes`)}else throw new Error("Missing file data (either binaryData or fileData is required)");const c=i||"data";if(n&&n!=="/"&&n!=="")try{const f=n.split("/").filter(g=>g.length>0);let m="";for(const g of f){m=m?`${m}/${g}`:g;try{await FilePicker.createDirectory(c,m),ModuleLogger.info(`Created/verified directory: ${m}`)}catch(w){const I=w.message||String(w);if(!I.includes("already exists"))throw ModuleLogger.error(`Error creating directory ${m}:`,w),new Error(`Could not create directory '${m}': ${I}`)}}}catch(f){throw ModuleLogger.error(`Error creating directories for path '${n}':`,f),new Error(`Could not create directory structure: ${f.message}`)}let y=null;try{const f=n&&n!=="/"?`${n}/${u}`:u;y=await FilePicker.browse(c,f)}catch{}if(y&&!l)throw new Error("File already exists. Set overwrite to true to replace it.");const p=await FilePicker.upload(c,n,a);if(!p)throw new Error("FilePicker.upload returned null/undefined result");const h=p&&typeof p=="object"&&"path"in p?p.path:`${n}/${u}`;ModuleLogger.info(`File uploaded successfully: ${h}`),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!0,path:h})}catch(n){ModuleLogger.error("Error uploading file:",n),t==null||t.send({type:"upload-file-result",requestId:e.requestId,success:!1,error:n.message})}}});router$2.addRoute({actionType:"download-file",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received download file request:",e);try{const{path:n}=e;if(!n)throw new Error("Missing required parameter (path)");const u=await fetch(n.startsWith("http")?n:foundry.utils.getRoute(n));if(!u.ok)throw new Error(`Failed to download file: ${u.status} ${u.statusText}`);const i=await u.blob(),r=new FileReader,d=await new Promise((o,l)=>{r.onload=()=>o(r.result),r.onerror=l,r.readAsDataURL(i)});t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!0,path:n,fileData:d,filename:n.split("/").pop()||"file",mimeType:i.type})}catch(n){ModuleLogger.error("Error downloading file:",n),t==null||t.send({type:"download-file-result",requestId:e.requestId,success:!1,error:n.message})}}});const router$1=new Router("dnd5eRouter");Hooks.once("init",()=>{if(game.system.id==="dnd5e"){router$1.addRoute({actionType:"get-actor-details",handler:async(t,n)=>{const u=n==null?void 0:n.socketManager;ModuleLogger.info("Received get-actor-details request:",t);try{const{actorUuid:i,details:r}=t;if(!i)throw new Error("actorUuid is required");if(!r||!Array.isArray(r)||r.length===0)throw new Error("details array is required and cannot be empty");const d=await fromUuid(i);if(!d)throw new Error(`Actor not found with UUID: ${i}`);const o={uuid:i};r.includes("resources")&&(o.resources=d.system.resources),r.includes("spells")&&(o.spells=d.items.filter(l=>l.type==="spell")),r.includes("items")&&(o.items=d.items.filter(l=>["weapon","equipment","consumable","tool","loot","backpack"].includes(l.type))),r.includes("features")&&(o.features=d.items.filter(l=>["feat","background","class"].includes(l.type))),u==null||u.send({type:"get-actor-details-result",requestId:t.requestId,data:o})}catch(i){ModuleLogger.error("Error in get-actor-details:",i),u==null||u.send({type:"get-actor-details-result",requestId:t.requestId,error:i.message})}}}),router$1.addRoute({actionType:"modify-item-charges",handler:async(t,n)=>{const u=n==null?void 0:n.socketManager;ModuleLogger.info("Received modify-item-charges request:",t);try{const{actorUuid:i,itemUuid:r,itemName:d,amount:o}=t;if(!i)throw new Error("actorUuid is required");if(!r&&!d)throw new Error("itemUuid or itemName is required");if(typeof o!="number")throw new Error("amount must be a number");const l=await fromUuid(i);if(!l)throw new Error(`Actor not found with UUID: ${i}`);let a=null;if(r?a=l.items.get(r.split(".").pop()):d&&(a=l.items.find(w=>w.name.toLowerCase()===d.toLowerCase())),!a)throw new Error(`Item not found on actor ${l.name}`);const c=a.system.uses||{},y=c.spent||0,p=c.value??c.max??0,h=c.max||0,f=Math.max(0,Math.min(h,y-o)),m=Math.max(0,Math.min(h,p+o)),g={system:{...a.system,uses:{...a.system.uses,spent:f,value:m}}};await a.update(g),u==null||u.send({type:"modify-item-charges-result",requestId:t.requestId,data:{itemUuid:a.uuid,oldCharges:p,newCharges:m}})}catch(i){ModuleLogger.error("Error in modify-item-charges:",i),u==null||u.send({type:"modify-item-charges-result",requestId:t.requestId,error:i.message})}}});const s=async(t,n,u)=>{var d,o,l;const i=n==null?void 0:n.socketManager,r=u?`use-${u}`:"use-ability";ModuleLogger.info(`Received ${r} request:`,t);try{const{actorUuid:a,abilityUuid:c,abilityName:y,targetUuid:p}=t;if(!a)throw new Error("actorUuid is required");if(!c&&!y)throw new Error("abilityUuid or abilityName is required");const h=await fromUuid(a);if(!h)throw new Error(`Actor not found with UUID: ${a}`);let f=null;if(c?f=await fromUuid(c):y&&(f=h.items.find(I=>I.name.toLowerCase()===y.toLowerCase()?u?u==="item"?I.type!=="feat"&&I.type!=="spell":I.type===u:!0:!1)),!f)throw new Error(`Ability not found on actor ${h.name}`);let m=null;if(p){const w=await fromUuid(p);if(w&&w.documentName==="Token")m=w;else if(w&&w.documentName==="Actor"){const I=(d=game.scenes)==null?void 0:d.active;if(I){const E=(o=I.tokens)==null?void 0:o.filter(v=>{var L;return((L=v.actor)==null?void 0:L.id)===w.id});E&&E.length>0&&(m=E[0])}}if(m&&(canvas!=null&&canvas.tokens)){(l=game.user)==null||l.targets.forEach(E=>E.setTarget(!1,{releaseOthers:!1}));const I=canvas.tokens.get(m.id);I&&I.setTarget(!0,{releaseOthers:!0})}}const g=await f.use();i==null||i.send({type:`${r}-result`,requestId:t.requestId,data:{uuid:a,ability:f.name,result:g?g.id:null}})}catch(a){ModuleLogger.error(`Error in ${r}:`,a),i==null||i.send({type:`${r}-result`,requestId:t.requestId,error:a.message})}};router$1.addRoute({actionType:"use-ability",handler:(t,n)=>s(t,n,null)}),router$1.addRoute({actionType:"use-feature",handler:(t,n)=>s(t,n,"feat")}),router$1.addRoute({actionType:"use-spell",handler:(t,n)=>s(t,n,"spell")}),router$1.addRoute({actionType:"use-item",handler:(t,n)=>s(t,n,"item")}),router$1.addRoute({actionType:"modify-experience",handler:async(t,n)=>{var i;const u=n==null?void 0:n.socketManager;ModuleLogger.info("Received modify-experience request:",t);try{const{actorUuid:r,selected:d,amount:o}=t;if(!r&&!d)throw new Error("Either actorUuid or selected must be provided");if(typeof o!="number")throw new Error("amount must be a number");let l=null;if(r)l=await fromUuid(r);else if(d){const y=(i=canvas.tokens)==null?void 0:i.controlled;if(!y||y.length===0)throw new Error("No token selected");y.length>1&&ModuleLogger.warn("Multiple tokens selected, using the first one."),l=y[0].actor}if(!l)throw new Error("Actor not found");const a=l.system.details.xp.value,c=a+o;await l.update({"system.details.xp.value":c}),u==null||u.send({type:"modify-experience-result",requestId:t.requestId,data:{actorUuid:l.uuid,oldXp:a,newXp:c}})}catch(r){ModuleLogger.error("Error in modify-experience:",r),u==null||u.send({type:"modify-experience-result",requestId:t.requestId,error:r.message})}}})}});const router=new Router("chatRouter");router.addRoute({actionType:"chat-messages",handler:async(e,s)=>{const t=s==null?void 0:s.socketManager;ModuleLogger.info("Received request for chat messages:",e);try{const n=e.limit||50,u=e.sort||"timestamp",i=e.order||"desc",r=game.modules.get(moduleId);let d=[];r&&r.api&&r.api.getChatMessages?d=[...r.api.getChatMessages()]:ModuleLogger.warn("Module API or getChatMessages method not available"),u==="timestamp"&&d.sort((l,a)=>i==="desc"?a.timestamp-l.timestamp:l.timestamp-a.timestamp);const o=d.slice(0,n);ModuleLogger.info(`Returning ${o.length} chat messages`),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,messages:o,total:d.length})}catch(n){ModuleLogger.error("Error processing chat messages request:",n),t==null||t.send({type:"chat-messages-result",requestId:e.requestId,error:n instanceof Error?n.message:String(n),messages:[]})}}});const routers=[router$b,router$a,router$9,router,router$8,router$7,router$6,router$5,router$4,router$3,router$2,router$1];function initializeWebSocket(){const e=game.settings.get(moduleId,"wsRelayUrl"),s=game.settings.get(moduleId,"apiKey"),t=game.modules.get(moduleId);if(!e){ModuleLogger.error("WebSocket relay URL is empty. Please configure it in module settings.");return}ModuleLogger.info(`Initializing WebSocket with URL: ${e}`);try{if(t.socketManager?ModuleLogger.info("WebSocket manager already exists, not creating a new one"):(t.socketManager=WebSocketManager.getInstance(e,s),t.socketManager&&t.socketManager.connect()),!t.socketManager){ModuleLogger.warn("No WebSocket manager available, skipping message handler setup");return}const n=t.socketManager;routers.forEach(u=>{u.reflect(n)}),ModuleLogger.info(`Registered ${routers.length} routers with WebSocket manager`)}catch(n){ModuleLogger.error("Error initializing WebSocket:",n)}}Hooks.once("init",()=>{console.log(`Initializing ${moduleId}`);for(let[s,t]of Object.entries(SETTINGS.GET_DEFAULT()))game.settings.register(CONSTANTS.MODULE_ID,s,t);const e=game.modules.get(moduleId);e.api={getWebSocketManager:()=>e.socketManager?e.socketManager:(ModuleLogger.warn("WebSocketManager requested but not initialized"),null),search:async(s,t)=>{if(!window.QuickInsert)return ModuleLogger.error("QuickInsert not available"),[];if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(u=>setTimeout(u,500))}catch(u){ModuleLogger.error("Failed to force QuickInsert index:",u)}}let n=null;return t&&(n=u=>u.documentType===t),window.QuickInsert.search(s,n,100)},getByUuid:async s=>{try{return await fromUuid(s)}catch(t){return ModuleLogger.error("Error getting entity by UUID:",t),null}},getChatMessages:(s=50)=>{var t;return ModuleLogger.info(`getChatMessages called with limit: ${s}`),((t=window.recentChatMessages)==null?void 0:t.slice(0,s))||[]}}});Hooks.on("renderSettingsConfig",(e,s)=>{const t=s instanceof HTMLElement?$(s):s,n=t.find(`input[name="${moduleId}.apiKey"]`);if(n.length){n.attr("type","password");const i=$('<button type="button" style="margin-left: 10px;"><i class="fas fa-info-circle"></i> Show Client Info</button>');n.after(i),i.on("click",()=>{const d=game.modules.get(moduleId).api.getWebSocketManager();if(d){const o=d.getClientId(),l=game.world.id,a=game.world.title,c=game.version,y=game.system.id,p=game.system.title||game.system.id,h=game.system.version||"unknown",f=game.settings.get(moduleId,"customName");new Dialog({title:"Client Information",content:`
            <div class="form-group">
                <label>Client ID</label>
                <div class="form-fields">
                    <input type="text" value="${o}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World ID</label>
                <div class="form-fields">
                    <input type="text" value="${l}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>World Title</label>
                <div class="form-fields">
                    <input type="text" value="${a}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Foundry Version</label>
                <div class="form-fields">
                    <input type="text" value="${c}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System ID</label>
                <div class="form-fields">
                    <input type="text" value="${y}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Title</label>
                <div class="form-fields">
                    <input type="text" value="${p}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>System Version</label>
                <div class="form-fields">
                    <input type="text" value="${h}" readonly>
                </div>
            </div>
            <div class="form-group">
                <label>Custom Name</label>
                <div class="form-fields">
                    <input type="text" value="${f}" readonly>
                </div>
            </div>
            <p class="notes">Click any field to copy its value.</p>
          `,buttons:{ok:{label:"OK"}},render:m=>{const w=(m instanceof HTMLElement?$(m):m).find('input[type="text"]');w.css("cursor","pointer"),w.on("click",I=>{const E=I.currentTarget;navigator.clipboard.writeText(E.value).then(()=>{ui.notifications.info("Copied to clipboard."),E.select()})})}}).render(!0)}else ui.notifications.warn("WebSocketManager is not available.")}),n.on("change",r=>{const d=r.target.value;game.settings.set(moduleId,"apiKey",d).then(()=>{new Dialog({title:"Reload Required",content:"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})}const u=t.find(`input[name="${moduleId}.customName"]`);u.length&&u.on("change",i=>{const r=i.target.value;game.settings.set(moduleId,"customName",r).then(()=>{new Dialog({title:"Reload Required",content:"<p>The Custom Name has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})})});Hooks.once("ready",()=>{var e;window.recentChatMessages||(window.recentChatMessages=[]);try{const s=((e=game.messages)==null?void 0:e.contents)||[];ModuleLogger.info(`Found ${s.length} existing chat messages to populate recentChatMessages`),s.forEach(n=>{var u,i;if(!n.isRoll){const r={id:n.id,messageId:n.id,user:{id:(u=n.user)==null?void 0:u.id,name:(i=n.user)==null?void 0:i.name},content:n.content,flavor:n.flavor||"",type:n.type||"player-chat",timestamp:n.timestamp||Date.now(),speaker:n.speaker,whisper:n.whisper||[],blind:n.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const d=window.recentChatMessages.findIndex(o=>o.id===n.id);d!==-1?window.recentChatMessages[d]=r:window.recentChatMessages.unshift(r)}});const t=100;window.recentChatMessages.length>t&&(window.recentChatMessages.length=t),ModuleLogger.info(`Populated recentChatMessages with ${window.recentChatMessages.length} messages from existing chat log`)}catch(s){ModuleLogger.error("Error populating chat messages from existing log:",s)}setTimeout(()=>{initializeWebSocket()},1e3)});Hooks.on("createChatMessage",e=>{var s,t,n,u,i,r,d,o,l;if(!e.isRoll){ModuleLogger.info(`Collecting chat message from ${((s=e.user)==null?void 0:s.name)||"unknown"}`);const a={id:e.id,messageId:e.id,user:{id:(t=e.user)==null?void 0:t.id,name:(n=e.user)==null?void 0:n.name},content:e.content,flavor:e.flavor||"",type:e.type||"player-chat",timestamp:Date.now(),speaker:e.speaker,whisper:e.whisper||[],blind:e.blind||!1};window.recentChatMessages||(window.recentChatMessages=[]);const c=window.recentChatMessages.findIndex(p=>p.id===e.id);c!==-1?window.recentChatMessages[c]=a:window.recentChatMessages.unshift(a);const y=100;window.recentChatMessages.length>y&&(window.recentChatMessages.length=y)}if(e.isRoll&&((u=e.rolls)==null?void 0:u.length)>0){ModuleLogger.info(`Detected dice roll from ${((i=e.user)==null?void 0:i.name)||"unknown"}`);const a=e.id,c={id:a,messageId:e.id,user:{id:(r=e.user)==null?void 0:r.id,name:(d=e.user)==null?void 0:d.name},speaker:e.speaker,flavor:e.flavor||"",rollTotal:e.rolls[0].total,formula:e.rolls[0].formula,isCritical:e.rolls[0].isCritical||!1,isFumble:e.rolls[0].isFumble||!1,dice:(o=e.rolls[0].dice)==null?void 0:o.map(h=>({faces:h.faces,results:h.results.map(f=>({result:f.result,active:f.active}))})),timestamp:Date.now()},y=recentRolls.findIndex(h=>h.id===a);y!==-1?recentRolls[y]=c:(recentRolls.unshift(c),recentRolls.length>MAX_ROLLS_STORED&&(recentRolls.length=MAX_ROLLS_STORED));const p=game.modules.get(moduleId);(l=p.socketManager)!=null&&l.isConnected()&&p.socketManager.send({type:"roll-data",data:c})}});
//# sourceMappingURL=module.js.map
